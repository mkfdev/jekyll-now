<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Angular2 form 유효성 검증]]></title>
      <url>/2017/11/21/TIL-1121/</url>
      <content type="html"><![CDATA[<h2 id="form-submit"><a href="#form-submit" class="headerlink" title="form - submit"></a>form - submit</h2><ul>
<li>서버에 전송. </li>
<li>페이지 전환(깜박거림).</li>
<li>form안의 요소들(그룹)이 하나라도 유효하지 않으면 전송할 수 없다.</li>
</ul>
<h2 id="form-control"><a href="#form-control" class="headerlink" title="form control"></a>form control</h2><ul>
<li>name 어트리뷰트가 데이터의 이름이 된다.</li>
<li>ngModel을 써줘야 control이 만들어짐</li>
<li>각각의 input에 접근하기 위해서는 form 참조 변수를 사용한다.</li>
<li>ex) userForm.value (참조변수:#userForm)</li>
<li>#name=”ngModel”: 유효성 검증 상태 추적이 가능해진다.</li>
</ul>
<h2 id="템플릿-기반-폼-유효성-검증-AbstractControl클래스"><a href="#템플릿-기반-폼-유효성-검증-AbstractControl클래스" class="headerlink" title="템플릿 기반 폼 유효성 검증 - AbstractControl클래스"></a>템플릿 기반 폼 유효성 검증 - AbstractControl클래스</h2><ul>
<li>유효성 검증의 상태를 나타내는 프로퍼티를 가지고 있음</li>
<li>errors, invalid, valid, pristine, undouched, dirty 등</li>
<li>untouched: fousin -&gt; focusout되면 false</li>
<li>pristine: 값이 한번이라도 입력된 상태 false</li>
<li>*ngIf를 사용해서 에러메시지를 출력하는게 좋다 -&gt; 조건에 부합하면 DOM에서 사라지기 때문</li>
<li>에러메시지는 값을 입력하고 focusout됐을 때 출력되야 함.</li>
<li>errors =&gt; invalid: true, untouched: false</li>
</ul>
<h2 id="리액티브폼-컴포넌트-기반"><a href="#리액티브폼-컴포넌트-기반" class="headerlink" title="리액티브폼 - 컴포넌트 기반"></a>리액티브폼 - 컴포넌트 기반</h2><ul>
<li>템플릿 기반보다 복잡할 경우 사용. (form이 15개 이상이거나 많은 검증이 필요할때)</li>
<li>컴포넌트 기반</li>
<li>formControlName이 템플릿기반 폼에서 name의 역할을 한다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reactiveform, form </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[angular2 CLI 커맨드 정리]]></title>
      <url>/2017/11/13/TIL-1113/</url>
      <content type="html"><![CDATA[<h1 id="Angular-CLI-커맨드-정리"><a href="#Angular-CLI-커맨드-정리" class="headerlink" title="Angular CLI 커맨드 정리"></a>Angular CLI 커맨드 정리</h1><h2 id="Angular-CLI-설치"><a href="#Angular-CLI-설치" class="headerlink" title="Angular CLI 설치"></a>Angular CLI 설치</h2><ul>
<li>npm install -g angular-cli</li>
</ul>
<h2 id="프로젝트-생성"><a href="#프로젝트-생성" class="headerlink" title="프로젝트 생성"></a>프로젝트 생성</h2><ul>
<li>ng new 프로젝트명</li>
</ul>
<h2 id="포트변경"><a href="#포트변경" class="headerlink" title="포트변경"></a>포트변경</h2><p>ng serve -port 4001</p>
<h2 id="구성요소-추가"><a href="#구성요소-추가" class="headerlink" title="구성요소 추가"></a>구성요소 추가</h2><h3 id="컴포넌트-추가"><a href="#컴포넌트-추가" class="headerlink" title="컴포넌트 추가"></a>컴포넌트 추가</h3><ul>
<li>ng g c 컴포넌트명</li>
</ul>
<h3 id="디렉티브-추가"><a href="#디렉티브-추가" class="headerlink" title="디렉티브 추가"></a>디렉티브 추가</h3><ul>
<li>ng g d 디렉티브명</li>
</ul>
<h3 id="파이프-추가"><a href="#파이프-추가" class="headerlink" title="파이프 추가"></a>파이프 추가</h3><ul>
<li>ng g p 파이프명</li>
</ul>
<h3 id="서비스-추가"><a href="#서비스-추가" class="headerlink" title="서비스 추가"></a>서비스 추가</h3><p>*ng g s 서비스명</p>
<h2 id="빌드-및-실행"><a href="#빌드-및-실행" class="headerlink" title="빌드 및 실행"></a>빌드 및 실행</h2><h3 id="개발-서버-실행"><a href="#개발-서버-실행" class="headerlink" title="개발 서버 실행"></a>개발 서버 실행</h3><ul>
<li>ng serve</li>
</ul>
<h3 id="개발-서버-실행-watch"><a href="#개발-서버-실행-watch" class="headerlink" title="개발 서버 실행(watch)"></a>개발 서버 실행(watch)</h3><ul>
<li>ng serve -o</li>
</ul>
<h3 id="빌드"><a href="#빌드" class="headerlink" title="빌드"></a>빌드</h3><ul>
<li>ng build</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular2, cli, ng </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Angular2 문법과 MVC패턴]]></title>
      <url>/2017/11/09/TIL-1109/</url>
      <content type="html"><![CDATA[<h2 id="Angular-형식"><a href="#Angular-형식" class="headerlink" title="Angular 형식"></a>Angular 형식</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#123;...&#125; from &apos;@angular/core&apos;;</span><br><span class="line">//데코레이터</span><br><span class="line">@Complate(&#123;</span><br><span class="line">    selector:...,</span><br><span class="line">    template:...,</span><br><span class="line">    styles:...</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent&#123;</span><br><span class="line">    name:String; //template과 연동</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Angular에서-뷰-템플릿-변경"><a href="#Angular에서-뷰-템플릿-변경" class="headerlink" title="Angular에서 뷰(템플릿) 변경"></a>Angular에서 뷰(템플릿) 변경</h2><p>앵귤러가없으면 DOM API를 이용해서 데이터를 변경한다.<br>그러나 앵귤러에서는 DOM API를 쓰지 않고 컴포넌트 클래스 내에 데이터를 갖고 있으면 Data Binding로직에 의해서 template syntax에 표시하여 변경한다.(인터폴레이션)<br>** 앞으로 배울것 Data binding</p>
<h2 id="Data-binding"><a href="#Data-binding" class="headerlink" title="Data binding"></a>Data binding</h2><ul>
<li>DOM API 접근 방식: javascript는 DOM에 강하게 의존하고 있다(조작하고 있는 view태그를 변경하면 자바스크립트를 변경해야 한다.)</li>
<li>Angular는 템플릿(html)이 컴포넌트 클래스(javascript)의 데이터를 인터폴레이션이 가져가도록 작동한다.</li>
<li>따라서 템플릿에서 태그를 변경해도 영향을 미치지 않는다 =&gt; 템플릿이 주도권을 가짐</li>
<li>인터폴레이션 :  { { title } }</li>
</ul>
<a id="more"></a>
<h2 id="변화감지"><a href="#변화감지" class="headerlink" title="변화감지"></a>변화감지</h2><ul>
<li>데이터 바인딩 할 때 변경된 것을 감지한다.</li>
<li>기본자료형의 값이 바뀌면 변화를 바로 감지한다.=&gt; 메모리 주소가 변경되기 때문에.</li>
<li>객체형은 재할당 해야 변화를 감지한다.</li>
<li>TodoList에서 render()과 같은 역할을 한다.</li>
</ul>
<h2 id="인터폴레이션"><a href="#인터폴레이션" class="headerlink" title="인터폴레이션"></a>인터폴레이션</h2><ul>
<li>단방향 바인딩에 사용되는 템플릿 문법이다.</li>
<li>문법 : []</li>
<li>표현식의 평가 결과를 문자열로 변환하여 템플릿에 바인딩한다.</li>
</ul>
<h2 id="프로퍼티-바인딩"><a href="#프로퍼티-바인딩" class="headerlink" title="프로퍼티 바인딩*"></a>프로퍼티 바인딩<em>*</em></h2><ul>
<li>DOM 객체의 프로퍼티와 HTML 어트리뷰트</li>
<li>input을 객체화하면 input의 attributes(어트리뷰트의 값들)이 들어온다. =&gt; ex) 0:id, 1:type, 2:value</li>
<li>attribute 내부에 있는 id 값과 id 프로퍼티 값이 같다.(1:1 매핑)<br>DOM객체내의 class 프로퍼티가 없고, classList 프로퍼티로 변환된다.</li>
<li>td 요소의 colspan의 어트리뷰트의 경우 매핑하는 프로퍼티가 존재하지 않는다.</li>
<li>input의 value 어트리뷰트는 value 프로퍼티와 1:1 매핑하지만 서로 다르게 동작한다. =&gt; 초기값이 보존된다.(새로고침하면 시작하는 값은 어트리뷰트 value), .getAttribute(‘value)</li>
<li>사용자가 input한 값은 프로퍼티 value로 사용한다. 입력된 input 값을 가져오려면 .value로 접근해야한다. .value</li>
<li>input type=”text” [value]=”name” // []를 떼면 어트리뷰트.</li>
<li>컴파일되면 name 값을 프로퍼티 바인딩한다.</li>
<li>이외에도 많은 경우가 있으므로 어트리뷰트와 프로퍼티를 구별해서 사용해야 한다.</li>
<li>이벤트 바인딩, 클래스 바인딩, 어트리뷰트 바인딩, 스타일 바인딩, 양방향 데이터 바인딩 등이 있다.</li>
</ul>
<h2 id="프로퍼티-바인딩-예제-DOM-객체로-변환"><a href="#프로퍼티-바인딩-예제-DOM-객체로-변환" class="headerlink" title="프로퍼티 바인딩 예제(DOM 객체로 변환)"></a>프로퍼티 바인딩 예제(DOM 객체로 변환)</h2><p>1) [value] 프로퍼티<br>2) [innerHTML] 프로퍼티</p>
<pre><code>- p [innerHTML]=&quot;contents&quot;  
- 위 코드는 인터폴레이션을 사용한 [ &lt;p&gt;{ {contents} }&lt;/p&gt; ] 와 같다. 
- 인터폴레이션은 syntax sugar이다.
</code></pre><p>3) [src] 프로퍼티<br>4) [disabled] 프로퍼티</p>
<pre><code>- button [disabled]=&quot;isDisabled&quot;&gt;
- isDisabled = true;
- true이면 해당 버튼을 사용할 수 없다.
</code></pre><h2 id="어트리뷰트-바인딩"><a href="#어트리뷰트-바인딩" class="headerlink" title="어트리뷰트 바인딩"></a>어트리뷰트 바인딩</h2><ul>
<li>[attr.attribute-name] = “expression”</li>
<li>프로퍼티 바인딩보다 사용빈도는 적지만 알고 있어야 함</li>
</ul>
<h2 id="어트리뷰트-바인딩-예제-HTML"><a href="#어트리뷰트-바인딩-예제-HTML" class="headerlink" title="어트리뷰트 바인딩 예제(HTML)"></a>어트리뷰트 바인딩 예제(HTML)</h2><p>1) 프로퍼티 바인딩과 어트리뷰트 바인딩</p>
<ul>
<li>input id=”user” type=”text” [value]=”name”</li>
<li>input id=”user” type=”text” [attr.value]=”name”<br>2) 프로퍼티가 존재하지 않을때</li>
<li>td [colspan]=”length”</li>
<li>colpspan은 프로퍼티가 존재하지 않으므로 [attr.colspan] 을 사용한다.</li>
</ul>
<h2 id="이벤트-바인딩"><a href="#이벤트-바인딩" class="headerlink" title="이벤트 바인딩**"></a>이벤트 바인딩**</h2><ul>
<li>뷰 상태 변환을 컴포넌트 클래스로 전달</li>
<li>(event) = “statement(함수,구문)” </li>
</ul>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>1) Model </p>
<pre><code>- 애플리케이션에서 사용되는 데이터의 형식으로 비즈니스 로직, 유효성 검사 기능을 포함한다.
- 비즈니스 로직: 데이터를 컨트롤하는 로직, 프로그램은 비즈니스 로직을 짜는 것이다.
- 유효성 검사: input에 적절한 값이 들어왔는지 검사하는 것.
- 친절한 애플리케이션: 사용자와 상호작용을 한다는 느낌을 주는 섬세한 애플리케이션 =&gt; 유효성 검사 중요
- ex) todos data.
</code></pre><p>2) View</p>
<pre><code>- Model을 표시하는 것을 말한다.(html과 css로 구성)
- DOM은 html만 있으면 브라우저에 의해서 만들어진다.
- 1) DOM의 상태 변화 정보가 View에 전달된다.
- 2) View(template)는 DOM을 업데이트 한다. 
- 3) 두 가지를 반복한다.(양방향으로 상태를 주고 받는다)
</code></pre><p>3) Controller</p>
<pre><code>- 모델과 뷰의 상호작용 감시하고 업데이트 한다.
</code></pre><h2 id="양방향-데이터-바인딩"><a href="#양방향-데이터-바인딩" class="headerlink" title="양방향 데이터 바인딩"></a>양방향 데이터 바인딩</h2><ul>
<li>앵귤러는 “양방향 =&gt; wathcer =&gt; 끊임없이감지” 이유로 양방향을 지원하지 않는다.</li>
<li>단방향 데이터 바인딩을 가지고 양방향처럼 지원한다.</li>
<li>[(ngModel)] = “property”</li>
<li>템플릿과 컴포넌트 클래스 사이에서 양방향 데이터 바인딩을 한다.</li>
<li>input type=”text” [(ngModel)]=”name”</li>
<li>꼭~~ 필요할 때만 쓴다. </li>
<li>() :이벤트 바인딩 []: 프로퍼티 바인딩 =&gt; 양방향 바인딩의 실제 동작은 이벤트 바인딩과 프로퍼티 바인딩의 조합으로 이루어진다.</li>
</ul>
<h1 id="빌트인-디렉티브"><a href="#빌트인-디렉티브" class="headerlink" title="빌트인 디렉티브"></a>빌트인 디렉티브</h1><ul>
<li>디렉티브 : DOM의 모든것을 관리하기 위한 지시</li>
<li>컴포넌트 디렉티브, 어트리뷰트 디렉티브, 구조 디렉티브</li>
</ul>
<h2 id="ngIf"><a href="#ngIf" class="headerlink" title="ngIf"></a>ngIf</h2><ul>
<li>요소를 보이기/숨기기를 쉽게 할 수 있다.</li>
<li>display:none 은 표시만 안했을뿐 DOM에 남아있는다.</li>
<li>ngIf로 감추면 DOM에서도 사라진다. </li>
<li>사용법 : [ &lt; p *ngIf = “isShow” &gt;&lt; p &gt; ]</li>
<li>ngFor, ngIf 를 한번에 사용할 때 ng-container를 사용한다.</li>
</ul>
<h2 id="NgFor"><a href="#NgFor" class="headerlink" title="NgFor"></a>NgFor</h2><ul>
<li>컴포넌트 클래스의 컬렉션을 반복하여 하위요소를 DOM에 추가한다.</li>
<li>forEach와 같다.</li>
<li>사용법 : [ &lt; li *ngFor = ‘let user of users; let i = index”&gt; ]</li>
<li>[ { { i } } : { { user.name } } ]</li>
</ul>
<h2 id="디렉티브"><a href="#디렉티브" class="headerlink" title="디렉티브"></a>디렉티브</h2><ul>
<li>DOM의 모든 것을 관리하기 위한 명령(스타일,모양,동작)</li>
<li>컴포넌트의 복잡도를 낮추고 가독성을 향상시킨다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular2, mvc, 데이터바인딩 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Angular2 기본 개념과 구성]]></title>
      <url>/2017/11/07/TIL-1107/</url>
      <content type="html"><![CDATA[<h2 id="Angular-기본-개념-및-구성-정리"><a href="#Angular-기본-개념-및-구성-정리" class="headerlink" title="Angular 기본 개념 및 구성 정리"></a>Angular 기본 개념 및 구성 정리</h2><h3 id="Angular소개"><a href="#Angular소개" class="headerlink" title="Angular소개"></a>Angular소개</h3><ul>
<li>“Web Component”를 기반으로 프레임워크가 만들어짐</li>
<li>SPA(Single Page Application)개발을 위한 구글의 오픈소스 자바스크립트 프레임워크  </li>
<li>초기 로딩이 길다(SPA의 단점)</li>
<li>초기 로딩 이후의 화면전환이나 인터렉션은 빠르다.</li>
<li>AngularJS(v1,ES5) 2012년 구글의 미스코 헤브리가 공개. 지속적으로 업데이트를 진행하고 있다.</li>
<li>Angular(v2~, typescriprt) 2014년 ng컨퍼런스에서 처음으로 소개.</li>
<li>Angular는 AngularJS의 후속 버전이지만 호환성이 없다.</li>
<li>Angular에서는 자바스크립트 값이 html과 상호 연동된다.</li>
<li>하나 이상의 모듈과 컴포넌트가 존재해야 된다.</li>
<li>대부분의 모던 브라우저를 지원한다.(IE는 9이상)</li>
</ul>
<h3 id="Angular의-장점"><a href="#Angular의-장점" class="headerlink" title="Angular의 장점"></a>Angular의 장점</h3><p>1) 개선된 개발 생산성<br>    1) 컴포넌트 기반 개발<br>    2) Typescript의 도입</p>
<pre><code>- Typescript의 정적 타이핑/ ECMAScript6의 클래스,모듈/ ECMAScript7의 데코레이터를 지원한다.
3) 개발 도구의 통합 및 개발 환경 구축 자동화
- 설정해야 할 도구가 많고 설정 방법은 익숙지 않다. =&gt; Angular는 CLI을 통해 간편한 개발 환경 구축을 지원한다.(개발환경 구축에 소요되는 시간 최소화)
</code></pre><p>2) 성능 향상<br>    1) Digest Loop로 인한 성능저하 문제의 해결</p>
<pre><code>- AngularJS는 Model의 변화를 View에 반영시키는 과정(Digest Loog)로 인한 성능저하가 단점 (양방향 바인딩을 위해서는 watcher가 추가됨, watcher가 늘어날수록 성능 저하)
2) AoT 컴파일
- 사전 컴파일 방식을 의미. 런타임에서 실시하지 않고 사전에 컴파일하여 속도를 향상시키는 기법.
3) Lazy Loading
- 지연 로딩. SPA의 단점을 극복하기 위한 대안.
- 애플리케이션 실행 시점에 모든 모듈을 한꺼번에 로딩하지 않고 필요한 시점에 필요한 모듈만을 로딩하는 방식
4) 코드 최적화
</code></pre><a id="more"></a>
<h3 id="Angular-CLI"><a href="#Angular-CLI" class="headerlink" title="Angular CLI"></a>Angular CLI</h3><ul>
<li><p>간단한 명령어를 사용하여 Angular 프로젝트 스캐폴딩(scaffolding)을 생성, 실행, 빌드할 수 있으며 다양한 구성 요소를 선별적으로 추가할 수 있는 커맨드-라인 인터페이스이다.</p>
</li>
<li><p>Angular 프로젝트 스캐폴딩을 간단한 명령어로 생성해 주어 개발환경 구축에 소요되는 시간을 최소화할 뿐 아니라 표준적인 스타일 가이드를 제공한다.</p>
</li>
</ul>
<h4 id="여기서-스캐폴딩-scaffolding-이란…"><a href="#여기서-스캐폴딩-scaffolding-이란…" class="headerlink" title="여기서, 스캐폴딩(scaffolding)이란…"></a>여기서, 스캐폴딩(scaffolding)이란…</h4><ul>
<li>(건축 공사장의) 비계?</li>
<li>높은 곳에서 공사를 할 수 있도록 임시로 설치한 가설물을 비계라고 한다.</li>
<li>개발에서는 스캐폴딩을 개발을 시작하기 위해 여러 폴더를 만들고, 라이브러리를 다운받고, 기본적인 뼈대를 만들면서 시작을 하며 이러한 작업을 몇줄의 명령어로 끝마치는 것! 이라고 한다.</li>
</ul>
<h3 id="Angular-CLI-사용법"><a href="#Angular-CLI-사용법" class="headerlink" title="Angular CLI 사용법"></a>Angular CLI 사용법</h3><p>1) 설치 </p>
<ul>
<li>npm install -g @angular/cli</li>
<li>node.js 6.9.0 / npm 3.0.0 이상</li>
</ul>
<p>2) Angular 프로젝트 생성</p>
<ul>
<li>ng new <project-name></project-name></li>
<li>새로운 프로젝트 폴더가 생성되고 스캐폴딩(프로젝트 기본 골격)이 작성된다.</li>
</ul>
<p>3) 프로젝트 실행</p>
<ul>
<li>ng serve</li>
<li>ng serve –open(or -o)</li>
<li>ng serve –port(or -p) 4201</li>
<li>serve =&gt; webpack을 사용하여 소스코드와 의존 모듈을 번들링하고 Angular CLI가 내장하고 있는 개발용 서버를 실행한다.</li>
<li>개발용 서버는 코드의 변경을 감지하여 자동으로 브라우저를 리로드하는 LiveReload기능을 제공한다.(–open명령어)</li>
<li>locahost:4200으로 접속한다.</li>
<li>4200번을 이미 사용하고 있다면 예)4201로 변경해준다.</li>
</ul>
<h3 id="프로젝트-구성요소"><a href="#프로젝트-구성요소" class="headerlink" title="프로젝트 구성요소"></a>프로젝트 구성요소</h3><p>1) Component(컴포넌트) </p>
<ul>
<li>화면 전환 단위로 만드는 것이 좋다.</li>
<li>모든 구성요소는 컴퓨넌트를 중심으로 구성된다.</li>
<li><p>애플리케이션의 화면을 구성하는 뷰를 생성하고 관리한다.</p>
<p>  1) 컴포넌트 요소 추가 명령어</p>
<ul>
<li>ng g(enerate) c(omponent) component-name</li>
<li>파일명(구성 요소 명칭)은 하이픈으로 구별된 케밥표기법을 사용한다.</li>
<li>명령어를 실행하면, src/app/<component-name>폴더를 생성</component-name></li>
<li>src/app/<componene-name>폴더에 4개의 파일을 추가한다.</componene-name></li>
<li>4개의 파일 : 컴포넌트 HTML템플릿을 위한 HTML파일, 컴포넌트 HTML템플릿의 스타일링을 위한 CSS파일, 컴포넌트 유닛 테스트를 위한 스펙 파일, 컴포넌트 클래스 파일(ts)</li>
<li><p>루트 모듈 src/app/app.module.ts에 새롭게 추가된 컴포넌트를 등록한다.</p>
<p>2) 컴포넌트 요소 추가(인라인) 명령어</p>
</li>
<li>ng g c about -it -is -spec false</li>
<li>it(inline templete)</li>
<li>is(inline style)</li>
<li><p>spec false(spec 테스트 파일 안만듦)</p>
<p>3) 서비스 요소 추가(sepc 테스트 파일 안만듦) 명령어</p>
</li>
<li><p>ng g c service -it -is -spec false -flat</p>
<p>4) Selector 프로퍼티 값</p>
</li>
<li>컴포넌트를 마크업으로 표현할 때 사용하는 이름.</li>
<li>루트 컴포넌트에서 home 컴포넌트를 사용하려면, app.component.html을 아래처럼 수정한다.</li>
<li>ex) Selector:’app-home’ =&gt; <app-home></app-home></li>
<li>기본 접두사는 angular-cli.json에서 설정할 수 있다. </li>
</ul>
</li>
</ul>
<h4 id="참고-anular-cli-json-설정파일"><a href="#참고-anular-cli-json-설정파일" class="headerlink" title="참고) anular-cli.json 설정파일"></a>참고) anular-cli.json 설정파일</h4><ul>
<li>selector 접두사 설정(prefix)</li>
<li>빌드 후 저장될 경로 설정(outDir)</li>
</ul>
<h3 id="ng-build로-배포하기"><a href="#ng-build로-배포하기" class="headerlink" title="ng build로 배포하기"></a>ng build로 배포하기</h3><ul>
<li>build 후 생성된 dist폴더 안의 파일들이 서버에 배포된다.</li>
</ul>
<h3 id="웹-컴포넌트"><a href="#웹-컴포넌트" class="headerlink" title="웹 컴포넌트"></a>웹 컴포넌트</h3><ul>
<li>변화감지(change detection)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> angular2, typescript, framework </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Typescript 문법]]></title>
      <url>/2017/11/06/TIL-1106/</url>
      <content type="html"><![CDATA[<h2 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h2><ul>
<li>“type”을 가지고 있다.(javascript와의 차이점, java,c와 비슷함)</li>
<li>code assistant 활용으로 생산성 향상(vscode에서 지원이 빵빵함)</li>
<li>AltJS(javascript의 대체언어)중 하나</li>
<li>기본적으로 ES6기반으로 씀</li>
<li>자체적으로 Babel과 유사한 컴파일러를 가지고 있음</li>
</ul>
<h2 id="type-지정의-장점"><a href="#type-지정의-장점" class="headerlink" title="type 지정의 장점"></a>type 지정의 장점</h2><ul>
<li>에러를 사전 점검할수 있음</li>
</ul>
<h2 id="문법"><a href="#문법" class="headerlink" title="문법"></a>문법</h2><ul>
<li>변수 타입 지정을 반드시 해줘야 함</li>
<li>선언과 할당이 함께 되면 타입 지정을 안해줘도 에러가 발생하지않음</li>
</ul>
<h2 id="정적타이핑"><a href="#정적타이핑" class="headerlink" title="정적타이핑"></a>정적타이핑</h2><ul>
<li>변수의 타입 선언, 지정에 맞는 값을 할당하여 사용하는 것</li>
<li>동적타이핑과 반대개념, javascript는 동적 타이핑 언어이다.</li>
<li>타입에 일치하지 않는 값을 넣었을 때는 에러가 발생(아예 컴파일이 실행 안됨)</li>
<li>타입을 써주면 더 확실하다.</li>
<li>코드 가독성, 예측성, 안정성의 향상의 장점이 있다.</li>
</ul>
<a id="more"></a>
<h2 id="타입추론"><a href="#타입추론" class="headerlink" title="타입추론"></a>타입추론</h2><ul>
<li>타입선언이 생략됐을 때, 선언과 동시에 값을 초기화하지 않으면 any타입이 된다.</li>
<li>let foo; // let foo: any와 같음.</li>
<li>javascript var키워드와 같이 재할당이 가능함으로 사용하지 않는 편이 좋다.</li>
</ul>
<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><ul>
<li>class body에서 멤버변수를 꼭 선언해야 한다.(ES6은 constructor내부에서만 가능하고 class body에서 선언하면 안된다.)</li>
</ul>
<h2 id="접근제한자"><a href="#접근제한자" class="headerlink" title="접근제한자"></a>접근제한자</h2><ul>
<li>public, protected, private</li>
<li>public 어디서든 참조가능, 공개</li>
<li>protected 클래스 인스턴스에서 참조불가능, 부분 공개</li>
<li>private 클래스 내부에서만 참조가능, 비공개</li>
</ul>
<h2 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h2><ul>
<li>상수가 된다.</li>
<li>값을 할당 할 수 없고, 오직 읽기만 가능하다</li>
</ul>
<h2 id="생성자-파라미터에-접근-제한자-사용"><a href="#생성자-파라미터에-접근-제한자-사용" class="headerlink" title="생성자 파라미터에 접근 제한자 사용"></a>생성자 파라미터에 접근 제한자 사용</h2><ul>
<li>아래 두 경우는 실행 결과가 같다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(public x: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    public x: string</span><br><span class="line">    <span class="keyword">constructor</span>(x: string) &#123;<span class="comment">//여기서 x는 매개변수(지역변수)로 class body(멤버변수)와 다른 x이다.&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="추상클래스-Abstract-class"><a href="#추상클래스-Abstract-class" class="headerlink" title="추상클래스(Abstract class)"></a>추상클래스(Abstract class)</h2><ul>
<li>추상 메소드를 포함할 수 있는 클래스.</li>
<li>상속만을 위해 사용된다.</li>
<li>추상 클래스를 상속하는 클래스는 추상 클래스의 추상 메소드를 반드시 “구현”해야 한다.</li>
</ul>
<h2 id="인터페이스"><a href="#인터페이스" class="headerlink" title="인터페이스"></a>인터페이스</h2><ul>
<li>기계(소프트웨어)와 사용자 간의 접점</li>
<li>옛날은 CLI 명령어으로 컴퓨터에 명령을 함(그래픽으로 처리 한 것은 GUI)</li>
<li>타입 체크를 위해 일반 변수, 함수, 클래스에 사용함(변수에 타입, 함수의 매개 변수 등)</li>
<li>함수의 매개 변수 : 인터페이스 설계대로 리턴타입을 준수해야함</li>
<li>interface, implements</li>
<li>interface에서 정의된 프로퍼티 전부를 implements한 클래스 내에서 반드시 구현한다.</li>
</ul>
<h2 id="덕-타이핑"><a href="#덕-타이핑" class="headerlink" title="덕 타이핑"></a>덕 타이핑</h2><ul>
<li>반드시 implements를 쓰지 않아도 interface를 구현한 것으로 인정되는 것</li>
<li>implements를 하지않아도 interface에 부합하는 메소드나 프로퍼티를 가지고 있다면 implements된걸로(해당 interface타입을 가지고 있는 것) 인정된다.</li>
</ul>
<h2 id="선택적-프로퍼티"><a href="#선택적-프로퍼티" class="headerlink" title="선택적 프로퍼티"></a>선택적 프로퍼티</h2><ul>
<li>인터페이스의 프로퍼티 구현 중 프로퍼티명 뒤에 ? 가 붙어있으면 생략해도 에러가 발생하지 않는다.</li>
</ul>
<h2 id="제네릭"><a href="#제네릭" class="headerlink" title="제네릭"></a>제네릭</h2><ul>
<li><t> : &lt;안에 type을 지정&gt;</t></li>
<li>클래스를 생성할 때 타입을 지정한다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> typescript, type지정 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[네트워크 구성]]></title>
      <url>/2017/10/27/TIL-1027/</url>
      <content type="html"><![CDATA[<h1 id="네트워크의-구성"><a href="#네트워크의-구성" class="headerlink" title="네트워크의 구성"></a>네트워크의 구성</h1><p>허브(hub?)</p>
<ul>
<li>같은 신호(외부에서 온 신호)를 여러 기기에 보여줌</li>
</ul>
<p>라우터(Router)</p>
<ul>
<li>외부신호를 받아서 내부로(?) 전달하는 것 - 공유기x, 좁은범위</li>
<li>공유기(매핑하여 특정한 컴퓨터에 전달할 수 있는 것)</li>
</ul>
<p>LAN</p>
<ul>
<li>가까운 지역의 좁은 범위</li>
<li>wireless LAN :무선인터넷</li>
<li>802.11 != wifi</li>
<li>802.11 : IEEE에서 개발된 표준무선통신기술</li>
<li>wifi : 와이파이 얼라이언스의 상표, 802.11 기술을 사용하는 무선근거리 통신망 제품으로 사용하려면(?) 허가를 받아야함</li>
</ul>
<p>WAN</p>
<ul>
<li>국가, 대륙의 넓은 범위</li>
</ul>
<p>LAN &lt; MAN &lt; WAN</p>
<ul>
<li>MAN : LAN들끼리 연결(LAN을 묶어준것)</li>
<li>WAN : MAN들끼리 연결</li>
</ul>
<p>Another 네트워크</p>
<ul>
<li>Lifi : 빛이 도달하는 범위에 연결되있고 정보(?)를 전송한다, 곧 상용화될 듯..</li>
<li>power line networking x</li>
</ul>
<p>Network topology(네트워크 연결 형태)</p>
<ul>
<li>Line : 한방향</li>
<li>Bus : Line형태가 발전한 것. 큰 연결선과 작은 연결선이 있음.</li>
<li>ring : 방향이 두개 </li>
<li>fully connected : ring형태 발전한 것, 모두 1:1연결(케이블 설치하는데…비용문제)</li>
<li>해외로 연결하는 망은 해저(?) 케이블로 구성되어 있다. 회사마다 설치할 수 있음(돈많은회사~)</li>
</ul>
<a id="more"></a>
<p>Ethernet</p>
<ul>
<li>통신방법 중 하나</li>
<li>ether == 에테르 == 빛의매질 (틀린개념. 빛은 파동이면서 입자라는데… 아무튼 저렇게 부름)</li>
<li>IEEE 802.3규약</li>
<li>패킷을 계속 확인해서 원하는 지역의 최단 경로를(빠른쪽) 알아서 탐색해줌</li>
</ul>
<p>OSI 7 layer</p>
<ul>
<li>Open Systems Interconnection Reference Model</li>
<li>프로토콜 디자인과 통신 계층</li>
<li>각 계층의 data header에 정보를 담아서 다른 PC로 전달한다.</li>
<li>application layer 사용자에게 넽워크 자원에 대한 접근을 제공, 연결정보 인터페이스를 제공</li>
<li>presentation layer 암호화/복호화,패킷이 다른곳에 전달될때 암호화.(개인정보유출 방지)</li>
<li>session layer 두 컴퓨터 사이의 세션이나 대화를 관리. 연결하고 관리. 연결유지 연결이 불안정할때 종료시킬떄의 과정을 담당</li>
<li>transport layer 신뢰성있는 데이터를 전송할수 있게함, 패킷 검사, 방화벽과 프록시 서버가 동작하는 계층</li>
<li>*방화벽 : 의심스러운 접근을 막는다. 신뢰된 정보는 미리 열어놓은 구멍(?)을 통해 들어온다.</li>
<li>network layer 복잡한계층. 넽워크 사이의 라우팅을 담당. 넽워크 호스트의 논리적인 주소관리(ip 주소 할당-&gt;라우터,공유기 역할). Ethernet</li>
<li>datalink layer 기지국에 데이터를 보내줌. 물리적인 데이터 사이의 전송. ex) 전화국끼리 주고받을때 각 기지국의 역할</li>
<li>physical layer 실제로 전달되는 데이터 매개체, 하드웨어 케이블, 아날로그를 디지털로(1과0으로 구성된 데이터,간단,모듈레이션), 디지털을 아날로그로 변환</li>
<li>transport 계층에서 방화벽을 열어서 전송시작.</li>
<li>network(경로지정) data link physical을 반복하여 패킷 헤더를 확인해서(까보고 포장하여) 목적지로 이동</li>
</ul>
<p>packet</p>
<ul>
<li>데이터를 한번에 전송할 단위로 자른 데이터의 묶음</li>
<li>컴퓨터는 바이트byte, 네트워크는 옥텟(octet) : 1byte -&gt; 8bit이므로…</li>
</ul>
<p>HTTP<br>: HyperText Transfer Protocol</p>
<ul>
<li>www상에서 정보를 주고 받는 프로토콜</li>
<li>**HyperText : 문자의 상위개념, 하이퍼텍스트 상에서 글자에 대한 의미를 부여하기 위한 text가 HyperText</li>
<li>HTTP method를 가짐. </li>
<li>TCP UDP 전송 방식 활용</li>
</ul>
<p>FTP<br>: File Transfer Protocol</p>
<ul>
<li>서버와 클라이언트 사이에 파일 전송을 위한 프로토콜</li>
<li>보안에 취약(무차별대입으로 비번을알아냄, 패킷 가로채기), FTPS,SFTP,SSH 사용</li>
</ul>
<p>SMTP</p>
<ul>
<li>네트워크에서 메일을 보내기 위한 프로토콜</li>
</ul>
<p>TCP/ UDP</p>
<ul>
<li>헤더가 있다</li>
<li>tcp sequence number가 있어서 순서를 적어서 조립</li>
<li>udp 그냥 도착한 순서대로…전송</li>
</ul>
<p>TCP<br>Transmission COntrol protocol</p>
<ul>
<li>전송제어프로토콜,패킷을 주고받을때 안정적 순서대로 에러없이 교환할 수 있게함</li>
<li>STREAM(TCP) 스트림소켓은 두개의 시스템이 1:1로 연결된 상태에서 데이터를 주고받고 연결됨.</li>
<li>안정적</li>
<li>게임을 제외한것…</li>
</ul>
<p>UDP<br>User datagram protocol</p>
<ul>
<li>DATAGRAM(UDP) 연결과해제가없음. 비연결형 데이터그램 소켓(빠른 전송이 가능하나 받은것을 모를 수도 있음)</li>
<li>데이터그램을 전송하기 위한 프로토콜<br>-수신확인x, 도착순서 예측x</li>
<li>빠르나 안정적이지않음</li>
<li>주로 게임에사용</li>
</ul>
<p>IP</p>
<ul>
<li>인터넷 프로토콜</li>
<li>IPv4 사용중 -&gt; IPv6 사용하게 될것</li>
<li>IPv4(32bit,2^32), IPv6(128bit,2^128)</li>
<li>32bit로 구성 0.0.0.0 ~ 255.255.255.255</li>
<li>ip라우터가 주소 재할당 한것(=192.168.x.x) -&gt; local ip 192.168.0.1<br>(라우터 즉 현재 내컴퓨터에서는 와이파이, 이거로 접속하면 아이피를 바꿀수 있다!)</li>
<li>통신사가 하나의 주소를 할당받아서 나눠서 분배하여 사용하고 있다.</li>
</ul>
<p>127.0.0.1</p>
<ul>
<li>Loopback 컴퓨터가 가지고 있는 무조건 반대신호를 반환하는 대역</li>
<li>localhost</li>
</ul>
<p>public ip adress</p>
<ul>
<li>전세계적으로 하나만</li>
</ul>
<p>private ip adress</p>
<ul>
<li>private(지역) network에서만 유효</li>
</ul>
<p>DNS<br>domain name system</p>
<p>ipconfig/ifconfig</p>
<ul>
<li>이더넷정보, 맥주소</li>
</ul>
<p>MAC<br>Media Access Control adress<br>고유번호</p>
<p>디폴트 서브넷마스크</p>
<ul>
<li>네트워크를 서브넷으로 나누지않아도 할당</li>
<li>class c 255.255.255.0 / class b / class a</li>
<li>class로 나눠짐.</li>
</ul>
<p>옥텟은 패킷의 단위<br>wrieshark</p>
<p>data</p>
<ul>
<li>컴퓨터가 처리할 수 있는 문자,숫자,그림 따위의 형태의 정보</li>
</ul>
<p>NoSQL</p>
<ul>
<li>MongoDB , Docs는 자바스크립트로 구성(JSON타입,key:value)</li>
<li>다중타입(몽고디비), 단일타입, 구조가간단(Documnet)</li>
<li>MongoDB 응용 프로그램</li>
<li><p>robo 해석가능한 상태를 GUI로 보여주는 클라이언트 프로그램</p>
</li>
<li><p>www.mongodb.org 맥은 homebrew 설치 &gt; brew update</p>
</li>
<li>robodb 설치, 다음주에 함.</li>
<li>자바스크립트 크롤링</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> network, tcp/ip </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[es6 디스트럭처링과 클래스 상속]]></title>
      <url>/2017/10/26/TIL-1026/</url>
      <content type="html"><![CDATA[<h2 id="디스트럭처링"><a href="#디스트럭처링" class="headerlink" title="디스트럭처링"></a>디스트럭처링</h2><p>배열의 요소나 객체의 속성을 배열 리터럴이나 객체 리터럴과 비슷한 문법을 이용해서 변수에 할당할 수 있다.</p>
<h2 id="객체-복사"><a href="#객체-복사" class="headerlink" title="객체 복사"></a>객체 복사</h2><ul>
<li>Object.assign을 주로 쓴다</li>
<li>JSON.stringify(?) 꼼수.</li>
</ul>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><ul>
<li>static 메서드</li>
<li>가변인자함수(매개변수가 여러개 올 수 있음)</li>
<li>({}, 매개변수1, 매개변수2…)<br>{}로 복사본을 만들 수 있음,<br>매개변수1에 매개변수2…가 merge됨</li>
</ul>
<h2 id="배열-디스트럭처링"><a href="#배열-디스트럭처링" class="headerlink" title="배열 디스트럭처링"></a>배열 디스트럭처링</h2><ul>
<li>배열의 요소를 추출해서 변수리스트에 할당한다.</li>
<li>추출/할당의 기준은 index</li>
<li>[x, …y] = [1,2,3,4]; spread 연산자는 매개변수의 마지막에 올 수 있고, 그런 경우에sms 할당된 요소의 남은 갯수만큼의 배열이 생성된다. result =&gt; y = [2 ,3 ,4];</li>
</ul>
<h2 id="객체-디스트럭처링"><a href="#객체-디스트럭처링" class="headerlink" title="객체 디스트럭처링"></a>객체 디스트럭처링</h2><ul>
<li>프로퍼티 이름(키)이 같은 것을 가져온다.</li>
<li>todo.filter(({completed})) =&gt; {…})</li>
<li>forEach(({id, content, completed}) =&gt; {…})</li>
<li>위처럼 객체 디스트럭처링을 하며 ${todo.id} -&gt; ${id}로 사용할 수 있다.</li>
<li>const { … } 형태</li>
<li>참고) _변수명 : 내부에서만 쓰는 변수(private), 외부에서 참조할 수 없음, 문법x</li>
</ul>
<a id="more"></a>
<h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><ul>
<li>ES6 class는 접근 제한자를 지원하지 않는다.</li>
<li>constructor와 메서드만 올 수 있다.</li>
<li>프로퍼티는 constructor 내부에 선언할 수 있다.</li>
<li>메소드 내부에서 프로퍼티를 접근할 때는 this를 사용한다.</li>
<li>내부에서는 클래스가 Function(생성자)이다.</li>
</ul>
<h2 id="멤버변수"><a href="#멤버변수" class="headerlink" title="멤버변수"></a>멤버변수</h2><ul>
<li>값을 함수로 가지고 있는 변수 -&gt; 메소드 -&gt; “멤버변수”</li>
<li>constructor 내부에서만 선언할 수 있다.( this.name = name, 반드시 this 사용)</li>
<li>즉, constructor의 지역 변수</li>
<li>pubilic, 외부에서 접근할 수 있다.</li>
</ul>
<h2 id="클래스의-호이스팅"><a href="#클래스의-호이스팅" class="headerlink" title="클래스의 호이스팅"></a>클래스의 호이스팅</h2><ul>
<li>let, const와 같다.</li>
<li>선언문 이전에 호출하면 에러<br>예) const foo = new Foo(); //Reference Error</li>
</ul>
<h2 id="getter-setter"><a href="#getter-setter" class="headerlink" title="getter, setter"></a>getter, setter</h2><ul>
<li>get(set) 메서드(){…}</li>
<li>getter는 프로퍼티처럼 쓴다. </li>
<li>get firstElem(){return…}</li>
<li>console.log(foo.firstElem);</li>
<li>setter는 return이 없고 값을 할당한다.</li>
</ul>
<h2 id="클래스-상속"><a href="#클래스-상속" class="headerlink" title="클래스 상속"></a>클래스 상속</h2><ul>
<li>super :부모클래스의 contsructor 호출 (상속받을 constructor)</li>
<li>인자가 있다. 현재 클래스에 없는 변수(아마 부모 클래스의 멤버변수일 듯)를 상속받을 때 해당변수를 인자로 써준다.</li>
<li>super 호출이 없으면 this가 없다.</li>
</ul>
<h2 id="모듈"><a href="#모듈" class="headerlink" title="모듈"></a>모듈</h2><ul>
<li>관련성이 있는 것들을 모아둔 파일이 분리된 형태</li>
<li>html에서 <code>&lt;script src=&#39;&#39;&gt;</code>로 js파일을 불러들이는 경우, 파일마다 독립적인 scope가 없고, 전역(window)이 하나이다.</li>
<li>npm</li>
<li>파일이 분리된 모듈 형태로 쓰려면 webpack을 사용해야 한다.</li>
<li>ES6 모듈은 export,import 키워드를 지원하지만, 모든 브라우저에서 지원하지 않는다. </li>
<li>export,import 키워드만 지정, 표준x, 스펙이 없어서 쓸 수 없다.</li>
</ul>
<h2 id="에러-처리의-한계-비동기-gt-Promise"><a href="#에러-처리의-한계-비동기-gt-Promise" class="headerlink" title="에러 처리의 한계 (비동기) -&gt; Promise"></a>에러 처리의 한계 (비동기) -&gt; Promise</h2><ul>
<li>비동기 함수에선 error가 catch 되지 않는다.</li>
<li>Promise를 사용하여 에러 처리의 한계 극복</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> es6, class, 디스트럭처링 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript ES6 let,const]]></title>
      <url>/2017/10/24/TIL-1024/</url>
      <content type="html"><![CDATA[<h1 id="ES6-공부"><a href="#ES6-공부" class="headerlink" title="ES6 공부"></a>ES6 공부</h1><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><ul>
<li>javascript ES5에서는 function-level scope를 갖기 때문에 함수 내에서 선언된 변수만 외부에서 참조할 수 없고, 블록 내에서 선언된 변수는 제한이 없기 때문에 전역에 선언된 변수와 이름이 중복되면 그 값을 재할당 해버려서 의도치 않은 변수 값 변경이 발생할 문제가 있다.</li>
<li>let으로 변수를 선언하면 block-level scope를 갖기 때문에 전역 변수와 이름이 같더라도 전역 변수를 참조할 수 없다.</li>
<li>let은 중복 선언시 SyntaxError가 발생한다.</li>
</ul>
<h2 id="var-let-의-호이스팅-비교"><a href="#var-let-의-호이스팅-비교" class="headerlink" title="var, let 의 호이스팅 비교"></a>var, let 의 호이스팅 비교</h2><ul>
<li>호이스팅이란 var 선언문이나 function 선언문을 해당 스코프의 선두로 옮기는 것을 말한다.(암묵적으로)</li>
<li>var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 함께 이뤄지기 때문에 할당 단계를 거치지 않고 선두에서 호출을 하더라도 에러가 발생하지 않는다. =&gt; undefined로 초기화 </li>
<li>let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다.</li>
<li>스코프에 변수가 등록되고, 일시적 사각지대(Temporal Dead Zone)를 지나서 변수 선언문에 도달했을 때 초기화가 이뤄진다. =&gt; 초기화 이전에 선두에서 변수를 호출한다면 ReferenceError가 발생한다.</li>
</ul>
<a id="more"></a>
<h2 id="Arrow-function"><a href="#Arrow-function" class="headerlink" title="Arrow function"></a>Arrow function</h2><ul>
<li>함수표현식에서 사용한다.</li>
<li>일반함수, 생성자함수에서는 사용하지 않는다.</li>
</ul>
<h2 id="Arrow-function-사용하면-안되는-경우"><a href="#Arrow-function-사용하면-안되는-경우" class="headerlink" title="Arrow function 사용하면 안되는 경우"></a>Arrow function 사용하면 안되는 경우</h2><ul>
<li>메소드 정의</li>
<li>프로토타입 메소드</li>
<li>생성자 함수</li>
<li>addEventListener 함수의 콜백 함수(this는 window가 된다. =&gt; click 이벤트일 경우, e.currentarget으로 함수를 호출한 자신을 호출할 수 있지만 this로 자기 자신을 호출해야 한다면.. Arrow function을 쓰지 않도록 한다. )</li>
</ul>
<h2 id="arguments-gt-rest-파라미터"><a href="#arguments-gt-rest-파라미터" class="headerlink" title="arguments -&gt; rest 파라미터"></a>arguments -&gt; rest 파라미터</h2><ul>
<li>가변 인자 함수를 구현함.</li>
<li>arguments은 가변인자 개수 지정을 가능하게 하는 순회가능한 유사 배열 객체이다.</li>
<li>ES6에는 argumnets가 없고 rest 파라미터를 사용한다.</li>
</ul>
<h2 id="rest-파라미터"><a href="#rest-파라미터" class="headerlink" title="rest 파라미터"></a>rest 파라미터</h2><ul>
<li>Spread(…)연산자를 사용하여 파라미터를 작성한 형태</li>
<li>분리된 요소들을 함수 내부에서 배열로 전달 받을 수 있음(순차적으로)</li>
<li>반드시 마지막 파라미터(인수).(안그럼 syntaxError)`</li>
</ul>
<h2 id="Spread-…-연산자"><a href="#Spread-…-연산자" class="headerlink" title="Spread(…) 연산자"></a>Spread(…) 연산자</h2><ul>
<li>개별 요소로 분리한다.</li>
<li>이터러블(순서를 가지고 순회할 수 있는 객체)에 Spread 연산자를 붙이면 개별 요소로 펴진다(?)</li>
<li>배열을 함수의 인자로 전달하려고 할때 사용한다.</li>
<li>인수는 자유롭게 (마지막이 아니여도) 사용할 수 있다.</li>
</ul>
<h2 id="일반함수의-this"><a href="#일반함수의-this" class="headerlink" title="일반함수의 this"></a>일반함수의 this</h2><ul>
<li>function 키워드를 이용하여 생성한 일반 함수</li>
<li>생성자함수의 this는 생성된 객체.</li>
<li>콜백함수, 내부함수의 this는 window.</li>
</ul>
<h2 id="Arrow-function의-this"><a href="#Arrow-function의-this" class="headerlink" title="Arrow function의 this"></a>Arrow function의 this</h2><ul>
<li>자신을 포함하는 외부 scope에서 this를 계승받는다.</li>
<li>그것을 Lexical this라고 함.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> let, const, es6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[실행 컨텍스트, 빌트인객체, Ajax REST API 정리]]></title>
      <url>/2017/10/22/TIL-1022/</url>
      <content type="html"><![CDATA[<h1 id="Excution-Context-REST-API-총정리"><a href="#Excution-Context-REST-API-총정리" class="headerlink" title="Excution Context ~ REST API 총정리"></a>Excution Context ~ REST API 총정리</h1><ul>
<li>Object - Built-in Object , Host Object</li>
<li>Built-in Object - 표준 빌트인 객체, Native Object(BOM,DOM)</li>
</ul>
<h2 id="Standard-Built-in-Object"><a href="#Standard-Built-in-Object" class="headerlink" title="Standard Built-in Object"></a>Standard Built-in Object</h2><ul>
<li>표준빌트인도 전역객체의 자식객체이다.</li>
<li>alert(‘hello’); = window.alert(‘hello’);</li>
<li>대문자로 시작하며 String,Number,Array 등이 있다.</li>
</ul>
<h2 id="Standard-Built-in-Object-표준-빌트인-객체-의-종류"><a href="#Standard-Built-in-Object-표준-빌트인-객체-의-종류" class="headerlink" title="Standard Built-in Object(표준 빌트인 객체)의 종류"></a>Standard Built-in Object(표준 빌트인 객체)의 종류</h2><ul>
<li>Object, Function, Boolean, Number, Math, Date, String, RegExp, Array, Error,Symbol<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3></li>
</ul>
<ul>
<li>Object 생성자 함수는 객체를 생성한다. 생성자 함수의 인수값에 따라 강제 형변환된 객체가 반환된다.</li>
<li>반환된 객체의 [[prototype]] 프로퍼티에 바인딩된 객체는 Object.prototype이 아니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strObj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">'String'</span>);</span><br><span class="line"><span class="comment">// var strObj = new String('String'); 와 같다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numObj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// var numObj = new Number(123); 과 같다.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><ul>
<li>모든 함수는 Function 객체이며, Function 객체는 new 연산자로 생성할 수 있다.</li>
<li>var sum = new function(‘a’,’b’,’return a + b’);</li>
</ul>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><ul>
<li>기본자료형 boolean을 위한 레퍼(Wrapper) 객체이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Boolean 객체</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//여기서 Boolean은 기본자료형이 아닌 객체이다.</span></span><br><span class="line"><span class="comment">//true,false를 포함하고 있는 객체이다.</span></span><br><span class="line"><span class="comment">//따라서 x는 객체로서 존재함으로 참으로 간주된다.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123; </span><br><span class="line">  <span class="comment">// . . . 이 코드는 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><ol>
<li>Number Constructor: Number() 생성자 함수를 통해 객체를 생성한다. </li>
</ol>
<ul>
<li>Number() 생성자 함수의 인자값이 숫자로 변환될 수 없으면 NaN을 반환한다.</li>
<li>new 연산자를 붙여 생성자 함수로 사용하지 않으면 기본자료형 숫자를 반환한다.</li>
</ul>
<ol>
<li>Number Property : 정적메소드. Number객체를 생성할 필요 없이 Number.prototypeName의 형태로 사용한다.</li>
</ol>
<ul>
<li>Number.MAX_VALUE(큰 숫자: Infinity), Number.MIN_VALUE(작은 숫자 : 0) 자바스크립트에서 사용가능한 가장 큰 숫자/작은 숫자</li>
<li>Number.POSITIVE_INFINITY(=Infinity), number.NEGATIVE_INFINITY(-Infinity)</li>
<li>Number.NaN : Not a Number, window.NaN과 같다.</li>
</ul>
<ol>
<li>Number Method<br>!! Number 메소드는 대부분 인수가 숫자가 아닐 때 숫자로 변환하지 않는다.</li>
</ol>
<ul>
<li>Number.isFinite() : 인수가 숫자가 아닐 때는 false를 반환한다.(전역의 isFinite()는 인수를 숫자로 변환하여 값을 반환한다)</li>
<li>Number.isInteger() : 정수인지 검사하여 Boolean값 반환.(인수를 숫자로 변환하지 않는다.)</li>
<li><p>Number.isNaN() : 숫자인지 아닌지를 판별하여 아니면(NaN) true를 반환. 단, 인수가 숫자(형)가 아닐 때 false이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN()과 isNaN()비교</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//숫자형이 아님, 변환하지 않고 false를 반환한다.</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'Hello'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//전역의 isNaN은 다른 타입일때, 형변환한다. </span></span><br><span class="line"><span class="comment">// undefined, &#123;&#125;, 'Hello' 는 Not a Number 이다. 따라서 true</span></span><br><span class="line">(<span class="built_in">window</span>).isNaN(<span class="literal">undefined</span>); <span class="comment">// undefined -&gt; NaN -&gt; true</span></span><br><span class="line"><span class="built_in">isNaN</span>(&#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'Hello'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Number.isSafeInteger(): 안전한 정수값인지 검사하여 결과값을 Boolean으로 반환한다.</p>
</li>
<li>Number.prototype.toExponential(): 대상을 지수표기법으로 변환하여 문자열로 반환한다.</li>
<li>Number.prototype.toFixed() : 0~20 사이의 정수값으로 소숫점 이하 자릿수를 나타낸다. (나머지 반올림)</li>
<li>Number.prototype.toPrecision() : 매개변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다. 지정된 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다.</li>
<li>Number.prototype.toString() : 숫자를 문자열로 변환하여 반환한다.</li>
<li>Number.prototype.valueOf() : Number 객체의 기본자료형 값을 반환한다,</li>
</ul>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ol>
<li>Math Method</li>
</ol>
<ul>
<li><p>Math.round() : 가장 인접한 정수로 올림/내림한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">Math</span>.round(<span class="number">20.5</span>); <span class="comment">// 21</span></span><br><span class="line">y = <span class="built_in">Math</span>.round(<span class="number">-20.5</span>); <span class="comment">// -20</span></span><br><span class="line">z = <span class="built_in">Math</span>.round(<span class="number">-20.51</span>); <span class="comment">// -21</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Math.ceil() : 자신보다 큰 가장 가까운 정수로 올림한다.</p>
</li>
<li>Math.floor() : 자신보다 작은 가장 가까운 정수로 내림한다.</li>
<li><p>Math.random() : 0~1사이의 숫자로 1은 포함되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> randomNum = <span class="built_in">Math</span>.floor((<span class="built_in">Math</span>.random() * <span class="number">10</span>) + <span class="number">1</span>); <span class="comment">// 1 ~ 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Math.pow() : 거듭제곱을 반환한다. pow(밑,지수);</p>
</li>
<li>Math.max() : 가장 큰수를 반환한다. 배열을 인수로 받을때는 apply를 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) ;  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(...arr); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol>
<li>String Method</li>
</ol>
<ul>
<li>String.prototype.lastIndexOf() : 매개변수로 전달된 문자를 대상 문자열에서 검사하여 마지막으로 발견된 곳에 index를 반환한다. 2번째 인수가 전달되면 검색 시작 위치가 되어 역방향으로 검색을 하고 반환값은 정방향 기준의 index이다.</li>
<li>String.prototype.replace(), split(), substring():원본 문자열은 변경되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//첫번째 인수가 클 경우 순서를 바꾼다.</span></span><br><span class="line"><span class="keyword">var</span> res = str.substring(<span class="number">5</span>,<span class="number">1</span>); <span class="comment">// substring(1,5) -&gt; 'ello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//두번째 인수가 생략된 경우 해당 문자열 끝까지 반환한다. </span></span><br><span class="line"><span class="keyword">var</span> res = str.substring(<span class="number">6</span>); <span class="comment">// 'World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//인수가 문자열보다 길 경우 인수는 문자열의 길이로 취급한다.(인수가 두개일 경우)</span></span><br><span class="line"><span class="keyword">var</span> res = str.substring(<span class="number">2</span>,<span class="number">12</span>); <span class="comment">// substring(2, str.lengh) -&gt; 'llo World'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//인수가 문자열보다 길 경우 (인수가 한개일 경우) 공백출력</span></span><br><span class="line"><span class="keyword">var</span> res = str.substring(<span class="number">11</span>); <span class="comment">// ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//인수가 0보다 작거나 NaN일 경우 0으로 취급된다.</span></span><br><span class="line"><span class="keyword">var</span> res = str.substring(<span class="number">-5</span>); <span class="comment">// 'Hello World'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="RegExp-정규표현식-Regular-Expression"><a href="#RegExp-정규표현식-Regular-Expression" class="headerlink" title="RegExp (정규표현식, Regular Expression)"></a>RegExp (정규표현식, Regular Expression)</h3><ol>
<li>플래그</li>
</ol>
<ul>
<li>i(Ignore Case) : 대소문자를 구별하지 않고 검색한다.</li>
<li>g(Global) : 문자열 내에 모든 패턴을 검색한다.</li>
<li>m(Multi Line) : 문자열의 행이 바뀌더라도 계속 검색한다.</li>
</ul>
<ol>
<li>패턴</li>
</ol>
<ul>
<li>/…/ 에서 .은 문자 한개를 의미한다.</li>
<li>한번 검색되면 끝나는 것이 아니라 반복하여 검색하려면 /…/g 플래그g를 사용한다.</li>
<li>/A/ig : ‘A’를 대소문자 구분없이 반복 검색</li>
<li>/A+/g : ‘A’가 한번이상 반복되는 문자열을 반복 검색 -&gt; ‘AA’ ‘AAA’ 출력</li>
<li>/A+|B+/g 는 /[AB]+/g 와 같다. |,[]는 “OR”을 의미한다.</li>
<li>/[A-Z]+/g : ‘A’~’Z’가 한번 이상 반복되는 문자열 반복 검색</li>
<li>/[A-Za-z]+/g : ‘A’~’Z’ 대소문자 구분없이 한번 이상 반복되는 문자열 반복 검색</li>
<li>/[0-9,]+/g : 0~9 또는 , 가 한번 이상 반복되는 문자열 반복 검색</li>
<li>\d는 숫자 \D는 숫자가 아닌 문자</li>
<li>var str=’Aa3 Bb2C c10,d’; var regexr=/[\D,]+/g; -&gt; [‘Aa’, ‘ Bb’ ,’C c’, ‘,d’]</li>
<li>\w는 알파벳과 숫자 \W는 알파벳가 숫자가 아닌 문자</li>
</ul>
<ol>
<li>자주 사용하는 정규표현식</li>
</ol>
<ul>
<li>/^abc/ : 특정 단어로 시작하는지</li>
<li>/abc$/ : 특정 단어로 끝나는지</li>
<li>/^\d$/ : 모두 숫자인지</li>
<li>/^[\s]+/(=/^\s+/) : 한개 이상의 공백으로 시작하는지</li>
<li>/^[A-Za-z0-9]{4,10}$/ : 알파벳 대소문자 또는 숫자로 시작하고 끝나며, 4~10자리 인지</li>
<li>/^\d{3}-\d{3,4}-\d{4}$/ : 핸드폰 형식에 맞는지 검사</li>
</ul>
<ol>
<li>RegExp Constructor<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//정규식 리터럴</span></span><br><span class="line"><span class="keyword">var</span> regExp = <span class="regexp">/ab+c/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RegExp 생성자 함수 - 패턴, 플래그</span></span><br><span class="line"><span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>,<span class="string">'i'</span>);</span><br><span class="line"><span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/</span>,<span class="string">'i'</span>);</span><br><span class="line"><span class="comment">//ECMAScript 6</span></span><br><span class="line"><span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/i</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ol>
<li>배열의 생성 [배열 리터럴]</li>
</ol>
<ul>
<li>배열리터럴 arr의 프로토타입은 Array.prototype</li>
<li>객체리터럴 arr의 프로토타입은 Object.prototype<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//배열 리터럴</span></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="string">'zero'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>,</span><br><span class="line">  <span class="string">'five'</span>, <span class="string">'six'</span>, <span class="string">'seven'</span>, <span class="string">'eight'</span>, <span class="string">'nine'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 리터럴</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'zero'</span>,  <span class="string">'1'</span>: <span class="string">'one'</span>,   <span class="string">'2'</span>: <span class="string">'two'</span>,</span><br><span class="line">  <span class="string">'3'</span>: <span class="string">'three'</span>, <span class="string">'4'</span>: <span class="string">'four'</span>,  <span class="string">'5'</span>: <span class="string">'five'</span>,</span><br><span class="line">  <span class="string">'6'</span>: <span class="string">'six'</span>,   <span class="string">'7'</span>: <span class="string">'seven'</span>, <span class="string">'8'</span>: <span class="string">'eight'</span>,</span><br><span class="line">  <span class="string">'9'</span>: <span class="string">'nine'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Array 생성자 함수</li>
</ol>
<ul>
<li>var arr = new Array(2); length가 2인 빈 배열 생성 -&gt; [undfined,undefined]</li>
<li>var arr = new Array(1,2,3); 매개변수로 전달된 값을 요소로 가지는 배열 -&gt; [1,2,3]</li>
</ul>
<ol>
<li>배열 요소의 삭제</li>
</ol>
<ul>
<li>delete로 삭제할 경우 해당 요소 값만 삭제되어, 해당 인덱스는 undefined가 된다.</li>
<li>Array.prototype.splice() 메소드를 사용하면 요소를 완전히 지울 수 있다.</li>
<li>splice()는 제거한 요소를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>];</span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['one','two','three', undefined];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'zero'</span>,<span class="string">'one'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>];</span><br><span class="line">arr2.splice(<span class="number">2</span>,<span class="number">1</span>) <span class="comment">//시작인덱스, 삭제할 요소 수</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// ['three'];</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Array Method</li>
</ol>
<ul>
<li>concat(), slice() : 원본이 변경되지 않고 복사본을 반환한다.</li>
<li>Array.prototype.concat() : 자신(배열)의 복사본에 인수로 넘어온 값들을 요소로 추가하고 반환한다. 원본 배열은 변경되지 않는다.</li>
<li>Array.prototype.join() : 배열요소 전체를 연결하여 생성한 문자열을 반환. 기본구분자는 ‘,’이며 + 연산자보다 빠르다.</li>
<li>Array.prototype.pop(), push(), shift(), unshift(), reverse() : 원본 배열이 수정된다.</li>
<li>push()는 원본 배열을 직접 변경하여 변경된 배열의 length를 반환하고, concat()은 원본 배열을 직접 변경하지 않고 복사본을 반환한다.</li>
<li>unshift() : push()와 반대로 배열의 선두에 추가된다.</li>
<li>shift() : pop()과 반대로 배열에서 첫요소를 제거하고 제거한 요소를 반환한다.</li>
<li>Array.prototype.reverse() : 배열 요소의 순서를 반대로 변경하고 원본 배열이 변경된다. 반환값은 변경된 배열이다.</li>
<li>Array.prototype.slice(start, end) : 원본이 변경되지 않는다. 인수가 음수일 경우 끝에서 갯수만큼 반환한다. 모든 요소를 반환할때(인수가 비었을 때) 복사본이 생성된다.</li>
<li>Array.prototype.splice(start, deleteCount, item…) : 매개변수는 시작위치 삭제할 요소 수, 삭제할 위치에 추가될 요소들(item…)이다. 제거한 요소가 배열로 반환되고 원본 배열이 변경된다. *삭제/배열 중간에 새로운 요소를 추가</li>
</ul>
<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul>
<li>Error 생성자는 error 객체를 생성한다. error 객체의 인스턴스는 런타임 에러가 발생하였을 때 throw된다.</li>
<li>Error에 관련된 객체 :</li>
<li>EvalError</li>
<li>InternalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h2 id="레퍼-Wrapper-객체-기본형이-레퍼객체를-사용할-수-있는-이유"><a href="#레퍼-Wrapper-객체-기본형이-레퍼객체를-사용할-수-있는-이유" class="headerlink" title="레퍼(Wrapper)객체 - 기본형이 레퍼객체를 사용할 수 있는 이유"></a>레퍼(Wrapper)객체 - 기본형이 레퍼객체를 사용할 수 있는 이유</h2><ul>
<li>기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 Wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하기 때문이다.</li>
<li>메소드 호출이 종료되면 객체로 변환된 기본자료형의 값은 다시 기본자료형의 값으로 복귀한다.</li>
</ul>
<h2 id="정적-Static-메소드-프로퍼티"><a href="#정적-Static-메소드-프로퍼티" class="headerlink" title="정적(Static)메소드,프로퍼티"></a>정적(Static)메소드,프로퍼티</h2><ul>
<li>prototype에 속해있는 메소드는 해당 prototype을 상속받은 인스턴스가 있어야 사용할 수 있지만 정적 프로퍼티, 메소드는 해당 인스턴스를 생성하지 않아도 사용할 수 있다.</li>
</ul>
<h2 id="전역-프로퍼티"><a href="#전역-프로퍼티" class="headerlink" title="전역 프로퍼티"></a>전역 프로퍼티</h2><ul>
<li>Infinity, NaN, undefined(type도 undefined)</li>
</ul>
<h2 id="전역-함수"><a href="#전역-함수" class="headerlink" title="전역 함수"></a>전역 함수</h2><p>(isFinity,isNaN은 문자열을 받을 경우 숫자로 변환한 후, 결과값을 나타낸다)</p>
<ul>
<li>eval(String)</li>
<li>isFinity()</li>
<li>isNaN()</li>
<li>parseFloat()</li>
<li>parseInt()</li>
<li>encodeURI(), decodeURI()</li>
<li>encodeURIComponent(), decodeURIComponent()</li>
</ul>
<h3 id="encodeURI-encodeURIComponent-비교"><a href="#encodeURI-encodeURIComponent-비교" class="headerlink" title="encodeURI(), encodeURIComponent() 비교"></a>encodeURI(), encodeURIComponent() 비교</h3><ul>
<li>encodeURI(): 매개변수로 전달된 URI를 인코딩한다. 인수를 URI 전체라고 간주하고 파라미터 구분자인 =,?,&amp;을 인코딩하지 않는다.</li>
<li>encodeURIComponent(): 매개변수로 전달된 URI Component(구성요소)를 인코딩한다. 인수를 쿼리스트링의 일부라고 간주하여 =,?,&amp;을 인코딩한다.</li>
<li>URI의 문자들을 이스케이프 처리한다. URI(Protocol, Host, Port, Path, Query, Fragment)</li>
<li>이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 코드(ASCII Character-set)로 변환하는 것이다.</li>
<li>URI 문법 형식 표준에 따르면 URI는 ASCII Character-set으로만 구성되어야 하며 ASCII에 정의되지 않은 특수문자나 한글을 포함한 외국어의 경우는 URL에 포함될 수 없기 때문에 이스케이프 처리를 하는 것이다.</li>
<li>URL내에서 의미를 갖는 문자(%, ?, #), URL에 올수 없는 문자(한글,공백 등) 또는 시스템에 의해 해석될 수 있는 문자(&lt;,&gt;)를 이스케이프 처리하여 야기될 수 있는 문제를 예방하기 위해 이스케이프 처리를 한다.</li>
<li>알파벳, 0~9의 숫자, -_.!~*’()는 이스케이프 처리에서 제외된다.</li>
<li>decodeURI(), decodeURIComponent() 인코딩된 완전한 URI, 인코딩된 URI Component를 원래의 URI로 돌려놓는다.</li>
</ul>
<hr>
<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><h2 id="DOM-tree의-구성"><a href="#DOM-tree의-구성" class="headerlink" title="DOM tree의 구성"></a>DOM tree의 구성</h2><ul>
<li>문서노드(Document Node) - DOM tree에 접근하기 위한 시작점</li>
<li>요소노드(Element Node)</li>
<li>어트리뷰트노드(Attribute Node)</li>
<li>텍스트노드(Text Node) - DOM tree의 최종점</li>
</ul>
<h2 id="요소에의-접근"><a href="#요소에의-접근" class="headerlink" title="요소에의 접근"></a>요소에의 접근</h2><h3 id="document-getElementsByClassName-class"><a href="#document-getElementsByClassName-class" class="headerlink" title="document.getElementsByClassName(class)"></a>document.getElementsByClassName(class)</h3><ul>
<li>메소드 반환값은 HTMLCollection이다.</li>
<li>HTMLElement의 리스트를 담아 반환하기 위한 객체로 유사배열이다.</li>
<li>실시간으로 Node의 상태 변경을 반영한다.(live HTMLCollection)</li>
<li>querySelectorAll 메소드를 사용하여 NodeList(none-live)를 반환하게 한다.</li>
<li>반복문을 역방향으로 돌린다.</li>
<li>HTMLCollection을 배열로 변경한다.</li>
<li>var arr = [].slice.call(elems); elems(getElementsByClassName)은 배열이 아니기 때문에 배열로 변환해준다.</li>
</ul>
<h2 id="DOM-탐색"><a href="#DOM-탐색" class="headerlink" title="DOM 탐색"></a>DOM 탐색</h2><ul>
<li>hasChildNodes() : 자식노드가 있는지 확인하고 Boolean값 반환</li>
<li>childNodes : 자식노드의 컬렉션을 반환한다. NodeList(non-live)</li>
<li>firstChild, lastChild, previousSibling, nextSibling</li>
</ul>
<h2 id="조작"><a href="#조작" class="headerlink" title="조작"></a>조작</h2><h3 id="텍스트-노드에-접근-수정"><a href="#텍스트-노드에-접근-수정" class="headerlink" title="텍스트 노드에 접근/수정"></a>텍스트 노드에 접근/수정</h3><ul>
<li>nodeValue 텍스트 노드의 프로퍼티</li>
<li>텍스트 노드일 경우 문자열 반환, 요소 노드일 경우 null 반환</li>
<li>nodeName, nodeType (노드의 정보 취득)</li>
</ul>
<h3 id="어트리뷰트-노드에-접근-수정"><a href="#어트리뷰트-노드에-접근-수정" class="headerlink" title="어트리뷰트 노드에 접근/수정"></a>어트리뷰트 노드에 접근/수정</h3><ul>
<li>className, id</li>
<li>hasAttribute(attribute) : 지정한 어트리뷰트를 가지고 있는지(Boolean)</li>
<li>getAttribute(attribute) : 어트리뷰트의 값을 취득한다. 문자열을 반환한다.</li>
<li>setAttribute(attribute, value) : 어트리뷰트와 어트리뷰트 값을 설정한다.</li>
<li>removeAttribute(attribute) : 지정한 어트리뷰트를 제거한다.</li>
</ul>
<h3 id="HTML-콘텐츠-조작"><a href="#HTML-콘텐츠-조작" class="headerlink" title="HTML 콘텐츠 조작"></a>HTML 콘텐츠 조작</h3><ul>
<li>textContent : 요소의 텍스트 콘텐츠 취득 또는 변경. 마크업을 포함시키면 문자열로 인식하여 그대로 출력한다.</li>
<li>innerText: 비표준. visibility:hidden(영역을 유지) 지정되어있으면 텍스트가 반환되지 않는다. css를 고려하기 때문에 textContent 프로퍼티보다 느리다.</li>
<li>innerHTML : 해당 요소의 모든 자식요소를 포함하는 모든 콘텐츠를 하나의 문자열로 취득할 수 있다. 이 문자열은 마크업을 포함한다.</li>
<li>그러나 마크업이 포함된 콘텐츠를 추가하는 것은 크로스 스크립팅 공격(XSS)에 취약하다.</li>
</ul>
<h3 id="DOM-조작-방식"><a href="#DOM-조작-방식" class="headerlink" title="DOM 조작 방식"></a>DOM 조작 방식</h3><ul>
<li>innerHTML을 사용하지 않고 새로운 컨텐츠를 추가할 수 있는 방법은 DOM을 직접 조작하는 것이다.</li>
<li>createElement(tagName)</li>
<li>createTextNode(text)</li>
<li>appendChild(Node) : 생성된 노드를 DOM tree에 저장한다.</li>
<li>removeChild(Node)</li>
<li>insertAdjacentHTML(position, string) : 삽입위치, 삽입할요소<br>beforebegin, afterbegin, beforeend, afterend</li>
<li>innerHTML과 inssertAdjacentHTML()은 크로스 스크립팅 공격(XSS)에 취약하다.</li>
<li>텍스트를 추가 또는 변경시에는 textContent, 새로운 요소 추가/삭제는 DOM 조작 방식을 사용한다.</li>
<li>DOM조작 방식의 단점은 innerHTML 보다 느리고 특정노드 한개를 추가할 때 사용하므로 여러 노드를 추가하려면 많은 코드가 필요하다.</li>
</ul>
<h3 id="Event-Flow-이벤트-흐름"><a href="#Event-Flow-이벤트-흐름" class="headerlink" title="Event Flow(이벤트 흐름)"></a>Event Flow(이벤트 흐름)</h3><ul>
<li>이벤트 핸들러 : 요소에 어떤 이벤트가 일어날때(이벤트발생) 실행되는 함수.</li>
<li>버블링 : 자식 요소에서 발생한 이벤트가 부모 요소로 전파되는 것</li>
<li>캡처링 : 자식 요소에서 발생한 이벤트가 부모 요소부터 시작하여 이벤트를 발생시킨 자식 요소까지 도달하는 것</li>
<li>이벤트가 발생했을 때 캡처링과 버블링은 순차적으로 발생한다.</li>
<li>3번째 매개변수가 true면 capturing, false면 bubbling, 미설정하면 bubbling</li>
</ul>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><ul>
<li>내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것.</li>
<li>자유변수에 엮여있는 함수.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'Hello'</span>; <span class="comment">//자유 변수</span></span><br><span class="line">  <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(x);&#125;;</span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = outer();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure>
<ul>
<li>실행컨텍스트 관점에서, 내부함수가 유효한 상태에서 외부함수가 종료되어 외부함수의 실행 컨텍스트가 반환되어도 외부함수의 실행 컨텍스트 내의 AO(Activation object)는 유효하여 내부함수가 스코프 체인을 통해 참조할 수 있는 것을 의미한다.</li>
<li>전역 변수 사용 억제를 위해 사용한다.</li>
</ul>
<h2 id="클로저-활용-for문-전역변수i"><a href="#클로저-활용-for문-전역변수i" class="headerlink" title="클로저 활용 - for문 전역변수i"></a>클로저 활용 - for문 전역변수i</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">  arr[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[j]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>즉시실행함수는 한번만 실행된다.</li>
<li>즉시실행함수는 i를 인자로 받고 매개변수 id를 할당한 후, 내부함수를 반환하고 life-cycle이 종료된다.</li>
<li>매개변수 id는 자유변수이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;()); </span><br><span class="line"><span class="comment">// 즉시실행함수는 한번만 실행된다. </span></span><br><span class="line"><span class="comment">// counter는 한번만 초기화된다.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'demo'</span>).innerHTML = add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>counter는 자유변수이고, 외부에서 직접 접근할 수 없는 private 변수이다. </li>
<li>counter는 자신을 참조하는 함수가 소멸될때까지 유지된다.</li>
</ul>
<h1 id="비동기식-처리-모델"><a href="#비동기식-처리-모델" class="headerlink" title="비동기식 처리 모델"></a>비동기식 처리 모델</h1><ul>
<li>비동기식 처리 모델은 병렬적으로 작업을 수행한다.</li>
<li>서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될때까지 대기하지 않고(Non-blocking) 즉시 다음 작업을 수행한다.</li>
<li>호출되는 함수는 Call Stack에 쌓이고, setTimeout이 호출되면 즉시 실행되지 않고 지정 대기 시간만큼 기다리다가 ‘tick’ 이벤트가 발생하면 이벤트 큐로 이동한 후 Call Stack이 비어졌을 때 Call Stack으로 이동되어 실행된다.</li>
</ul>
<h1 id="Ajax-Asynchronous-JavaScript-and-XML"><a href="#Ajax-Asynchronous-JavaScript-and-XML" class="headerlink" title="Ajax(Asynchronous JavaScript and XML)"></a>Ajax(Asynchronous JavaScript and XML)</h1><ul>
<li>자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통식 방식</li>
<li>서버로부터 웹페지가 반환되면 화면 전체를 갱신해야 하는데 페이지 전체를 로드하여 렌더링하지 않고 갱신이 필요한 일부만 로드 후 갱신하여 동일한 효과를 볼 수 있도록 하는 것이다.</li>
</ul>
<h2 id="객체를-JSON형식의-문자열로-변환"><a href="#객체를-JSON형식의-문자열로-변환" class="headerlink" title="객체를 JSON형식의 문자열로 변환"></a>객체를 JSON형식의 문자열로 변환</h2><ul>
<li>큰따옴표 사용</li>
<li>JSON.stringify(o) : o는 JSON으로 변환할 객체</li>
<li>JSON.stringify(o, 필터함수, 공백의수)</li>
</ul>
<h2 id="JSON형식의-문자열을-객체로-변환-역직렬화"><a href="#JSON형식의-문자열을-객체로-변환-역직렬화" class="headerlink" title="JSON형식의 문자열을 객체로 변환(=역직렬화)"></a>JSON형식의 문자열을 객체로 변환(=역직렬화)</h2><ul>
<li>JSON.parse(str) : str은 JSON 형식의 문자열, 문자열</li>
</ul>
<h1 id="Ajax-request"><a href="#Ajax-request" class="headerlink" title="Ajax request"></a>Ajax request</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GEN'</span>,<span class="string">'/users'</span>); <span class="comment">//세번째인수 default:True(비동기)</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<ol>
<li>XMLHttpRequest객체 생성(Ajax 요청을 생성하고 전송한다)</li>
<li>비동기 방식으로 Request를 오픈한다.</li>
<li>Request를 전송한다.</li>
</ol>
<h3 id="xhr-open-method-url-async"><a href="#xhr-open-method-url-async" class="headerlink" title="xhr.open(method, url, async)"></a>xhr.open(method, url, async)</h3><ul>
<li>method : HTTP method(GET,POST,PUT,DELETE)</li>
<li>url 요청을 보낼 url</li>
<li>async 비동기조작여부, default:true</li>
</ul>
<h3 id="xhr-send"><a href="#xhr-send" class="headerlink" title="xhr.send()"></a>xhr.send()</h3><ul>
<li>메소드로 준비된 요청을 서버에 전달한다.</li>
</ul>
<ol>
<li><p>GET 메소드 : URL의 일부분인 쿼리문자열로 데이터를 서버로 전송한다. send 메소드의 인수는 무시되고 request body는 null로 설정된다.</p>
</li>
<li><p>POST 메소드 : 데이터(페이로드)를 Request Body에 담아 전송한다.</p>
</li>
</ol>
<h3 id="xhr-setRequestHeader"><a href="#xhr-setRequestHeader" class="headerlink" title="xhr.setRequestHeader"></a>xhr.setRequestHeader</h3><ul>
<li>HTTP Request Header의 값을 설정한다.</li>
<li>반드시 open 메소드 뒤에서 호출한다</li>
<li>Accept 헤더를 설정하지 않으면 send가 호출될 때 Accept 헤더가 <em>/</em>로 전송된다.</li>
</ul>
<ol>
<li>content-type </li>
</ol>
<ul>
<li>request body에 담아 전송할 데이터의 MIME-type의 정보를 표현한다.</li>
<li>ex) xhr.setRequestHeader(‘Content-type’,’application/json’); // 서버가 전송할 데이터의 MIME-type 지정-json</li>
<li>ex) xhr.setRequestHeader(‘Content-type’,’application/x-www-form-urlencoded’); //key=value&amp;key=value..의 형태로 전송한다.</li>
</ul>
<ol>
<li>Accept</li>
</ol>
<ul>
<li>HTTP 클라이언트가 서버에 요청할 때 서버가 센드백할 데이터의 MIME-type을 지정한다.</li>
</ul>
<h1 id="Ajax-response"><a href="#Ajax-response" class="headerlink" title="Ajax response"></a>Ajax response</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'GET'</span>,<span class="string">'data/test.json'</span>);</span><br><span class="line">req.send();</span><br><span class="line"></span><br><span class="line">req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//readyState:4 -&gt; DONE</span></span><br><span class="line">  <span class="keyword">if</span>(req.readyState === XMLHttpRequest.DONE)&#123;</span><br><span class="line">    <span class="comment">// status는 response 상태 코드를 반환.</span></span><br><span class="line">    <span class="comment">// 200이 정상응답(GET)</span></span><br><span class="line">    <span class="keyword">if</span>(req.status === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//데이터 출력</span></span><br><span class="line">      <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">      <span class="comment">//3가지 구체적인 출력 방식</span></span><br><span class="line">      <span class="comment">//1.Load HTML(HTML형식 추가) -&gt; 전송받은 데이터를 DOM에 추가한다.</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).innerHTML = req.responseText;</span><br><span class="line">      <span class="comment">//또는</span></span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>).insertAdjacentHTML(<span class="string">'beforeend'</span>,req.responseText);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.Load JSON(JSON 형식 -&gt; 객체화) : JSON.parse()</span></span><br><span class="line">      <span class="comment">//역직렬화</span></span><br><span class="line">      responseObject = <span class="built_in">JSON</span>.parse(req.responseText);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> newContent = <span class="string">''</span>;</span><br><span class="line">      newContent += <span class="string">'&lt;div id="tours"&gt;'</span>;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; responseObject.tours.length; i++)&#123;</span><br><span class="line">        ... responseObject.tours[i].region...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//생략</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readyState : response가 클라이언트에 도달했는지를 추적한다.</li>
<li>0(UNSET) XMLHttpRequest.open() 메소드 호출 이전</li>
<li>1(OPENED) XMLHttpReqeust.open() 메소드 호출 완료</li>
<li>2(HEADERS_RECEIVED) XMLHttpRequst.send() 메소드 호출 완료</li>
<li>3(LOADING) 서버응답중(XMLHttpRequest.responseText 미완성 상태)</li>
<li>4(DONE) 서버응답완료(정상적으로 response가 돌아온 상태)</li>
</ul>
<h1 id="Load-JSONP-와-동일출처원칙"><a href="#Load-JSONP-와-동일출처원칙" class="headerlink" title="Load JSONP 와 동일출처원칙"></a>Load JSONP 와 동일출처원칙</h1><ul>
<li>요청에 의해 웹페이지가 전달된 서버와 동일한 도메인의 서버로 부터 전달된 데이터는 문제없이 처리할 수 있다. 그러나 보안상의 이유로 다른 도메인으로의 요청은 제한된다.</li>
<li>동일출처원칙을 우회하는 방법</li>
</ul>
<ol>
<li><p>웹서버의 프록시 파일 서버에 원격 서버로부터 데이터를 수집하는 별도의 기능을 추가하는 것이다. 이를 프록시(Proxy)라 한다.</p>
</li>
<li><p>JSONP script 태그의 원본 주소에 대한 제약이 존재하지 않는데 이것을 이용하여 다른 도메인의 서버에서 데이터를 수집하는 방법이다. 자신의 서버에 함수를 정의하고 다른 도메인의 서버에 얻고자 하는 데이터를 인수로 하는 함수 호출문을 로드하는 것이다.</p>
</li>
<li><p>Cross-Origin Resource Sharing HTTP 헤더에 추가적으로 정보를 추가하여 브라우저와 서버가 서로 통신해야 한다는 사실을 알게하는 방법이다.</p>
</li>
</ol>
<h1 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h1><ul>
<li>REST는 HTTP 1.0/1.1의 스펙 작성에 참여했다.</li>
<li>로이필딩의 논문에서 웹이 HTTP의 설계상 우수성을 제대로 사용하지 못하는 상황을 보고 웹의 장점을 최대한 활용할 수 있는 아키텍쳐로 REST를 소개했다.</li>
<li>*HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하고 있다.</li>
</ul>
<h2 id="RESTful이란"><a href="#RESTful이란" class="headerlink" title="RESTful이란?"></a>RESTful이란?</h2><ul>
<li>REST의 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful이라 한다.</li>
</ul>
<h2 id="REST-API의-중심규칙"><a href="#REST-API의-중심규칙" class="headerlink" title="REST API의 중심규칙"></a>REST API의 중심규칙</h2><ol>
<li>URI는 정보의 자원을 표현해야 한다.</li>
<li>자원에 대한 행위는 HTTP Method로 표현한다.</li>
</ol>
<h3 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h3><ul>
<li>4가지의 Method를 사용하여 CRUD를 구현한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Action</th>
<th>Method</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create</td>
<td>POST</td>
<td>리소스를 생성</td>
</tr>
<tr>
<td>Read - index/retrieve</td>
<td>GET</td>
<td>모든/특정 리소스를 조회</td>
</tr>
<tr>
<td>Update</td>
<td>PUT</td>
<td>리소스를 갱신</td>
</tr>
<tr>
<td>delete</td>
<td>DELETE</td>
<td>리소스를 삭제</td>
</tr>
</tbody>
</table>
<h3 id="REST-API의-구성"><a href="#REST-API의-구성" class="headerlink" title="REST API의 구성"></a>REST API의 구성</h3><ul>
<li>REST API는 자원(Resource),행위(Verb),표현(Representations)의 3가지 요소로 구성된다.</li>
<li>REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있다</li>
</ul>
<table>
<thead>
<tr>
<th>구성요소</th>
<th>내용</th>
<th>표현 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resource</td>
<td>자원</td>
<td>HTTP URI</td>
</tr>
<tr>
<td>Verb</td>
<td>자원에 대한 행위</td>
<td>HTTP Method</td>
</tr>
<tr>
<td>Representations</td>
<td>자원에 대한 행위의 내용</td>
<td>HTTP Message Pay Load</td>
</tr>
</tbody>
</table>
<p>*pay Load(페이로드) - body에 담기는 데이터</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:5000/books'</span>);</span><br><span class="line">req.send();</span><br><span class="line">*정상 : req.status === <span class="number">200</span></span><br></pre></td></tr></table></figure>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'POST'</span>, <span class="string">'http://localhost:5000/books'</span>);</span><br><span class="line">req.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"></span><br><span class="line">req.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  title : <span class="string">"ES6"</span>,</span><br><span class="line">  author : <span class="string">"Choi"</span></span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">*정상 : req.status === <span class="number">201</span></span><br></pre></td></tr></table></figure>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:5000/books/4'</span>);</span><br><span class="line">req.setRequestHeader(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line"></span><br><span class="line">req.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  title : <span class="string">"javascript"</span>,</span><br><span class="line">  author : <span class="string">"Kim"</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.open(<span class="string">'DELETE'</span>, <span class="string">'http://localhost:5000/books/4'</span>);</span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure>
<ul>
<li>POST, PUT은 setRequetHeader를 지정해준다.</li>
</ul>
<h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><ul>
<li>실행 컨텍스트는 실행 가능한 코드(전역코드와 함수 내 코드)가 실행되는 환경이다.</li>
<li>자바스크립트 엔진은 코드를 실행하기 위해 변수, 함수선언, 변수의 유효범위, this의 정보를 알고 있어야 한다.</li>
</ul>
<h1 id="실행-컨텍스트의-3가지-객체"><a href="#실행-컨텍스트의-3가지-객체" class="headerlink" title="실행 컨텍스트의 3가지 객체"></a>실행 컨텍스트의 3가지 객체</h1><ul>
<li>VO(Variable Object)</li>
<li>SC(Scope Chain)</li>
<li>this(thisValue)</li>
</ul>
<h2 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h2><ul>
<li>스코프 체인은 일종의 리스트로서 중첩된 함수의 스코프의 레퍼런스를 차례대로 저장하고 있는 개념이다.</li>
<li>함수 실행 컨텍스트일 경우 Activation Object를 선두로하여 순차적으로 상위 컨텍스트(가 있다면)의 Activation Object를 가리키며 마지막 리스트는 전역 객체를 가리킨다.</li>
<li>함수 실행중에 변수를 만나면 그 변수를 우선 현재 Scope인 Activation Object에서 검색해보고, 만약 검색에 실패하면 스코프 체인에 담겨진 순서대로 그 검색을 이어가게 된다.</li>
<li>스코프 체인의 순차적인 검색에 실패하면 정의되지 않은 변수에 접근하는 것으로 판단하여 Reference 에러를 발생시킨다.</li>
<li>스코프 체인은 [[scope]] 프로퍼티로 참조할 수 있다. </li>
</ul>
<h1 id="전역-코드에의-진입-순서"><a href="#전역-코드에의-진입-순서" class="headerlink" title="전역 코드에의 진입(순서)"></a>전역 코드에의 진입(순서)</h1><ol>
<li>전역 컨텍스트에 접근하기 이전에 전역 객체(GO)가 생성된다.</li>
<li>전역 코드로 컨트롤이 진입하면 전역 실행 컨텍스트(Global EC)가 생성되고 실행 컨텍스트에 스택이 쌓인다.</li>
<li>스코프체인이 초기화된다.(스코프 체인의 생성과 초기화)</li>
<li>Variable Instantiation(변수객체화)가 실행된다. -&gt; Variable Object에 프로퍼티 값을 추가하는 것이다.</li>
<li>this value가 결정된다.</li>
</ol>
<h2 id="변수-객체화-전역"><a href="#변수-객체화-전역" class="headerlink" title="변수 객체화(전역)"></a>변수 객체화(전역)</h2><ol>
<li>(Function Code인 경우) 매개변수가 Variable Object의 프로퍼티로, 인수가 값으로 설정된다.</li>
<li>함수선언을 대상으로 함수명이 Variable Object의 프로퍼티로, 생성된 객체가 값으로 설정된다.(함수 호이스팅)</li>
<li>변수 선언을 대상으로 변수명이 Variable Object의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)</li>
</ol>
<h2 id="함수-호이스팅"><a href="#함수-호이스팅" class="headerlink" title="함수 호이스팅"></a>함수 호이스팅</h2><ul>
<li>코드가 실행되기 이전에 전역에서 선언된 함수의 함수명은 Variable Object의 프로퍼티가 되고 생성된 함수 객체(Function Object)가 값으로 설정된다. 따라서 스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 이후 코드를 실행할 때 함수선언식 이전에 함수를 호출할 수 있게 된다.</li>
</ul>
<h2 id="변수-호이스팅"><a href="#변수-호이스팅" class="headerlink" title="변수 호이스팅"></a>변수 호이스팅</h2><p>전역에서 var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다. 즉, 스코프 체인이 가리키는 변수 객체에 변수가 등록되고 변수는 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않고 undefined를 반환한다.</p>
<h2 id="this-value-결정"><a href="#this-value-결정" class="headerlink" title="this value 결정"></a>this value 결정</h2><ul>
<li>this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다.</li>
</ul>
<h1 id="전역코드의-실행"><a href="#전역코드의-실행" class="headerlink" title="전역코드의 실행"></a>전역코드의 실행</h1><h2 id="함수의-실행"><a href="#함수의-실행" class="headerlink" title="함수의 실행"></a>함수의 실행</h2><ol>
<li>스코프 체인의 선두에 Activation Object를 참조하도록 설정한다.</li>
<li>Activation Object는 우선 arguments 프로퍼티의 초기화를 실행하고, 그 후 Variable Instantiation가 실행된다.<br>(VO객체는 Activation Object에 바인딩하여 Variable Instantiation를 실행한다.)</li>
<li>this value가 결정된다.</li>
</ol>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rest, built-in </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[REST API]]></title>
      <url>/2017/10/17/TIL-1017-2/</url>
      <content type="html"><![CDATA[<h1 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h1><ul>
<li><p>REST(Representational State Transfer)는 HTTP/1.0과 1.1의 스펙 작성에 참여하였고, 아파치 HTTP 서버 프로젝트의 공동설립자인 로이 필딩(Roy Fielding)의 2000년 논문에서 처음 소개되었다.</p>
</li>
<li><p>발표 당시의 웹이 HTTP의 설계 상 우수성을 제대로 사용하지 못하고 있는 상황을 보고 웹의 장점을 최대한 활용할 수 있는 아키텍쳐로 REST를 소개했다고 한다.</p>
</li>
<li><p>HTTP 프로토콜을 의도에 맞게 디자인하도록 유도하고 있다.</p>
</li>
<li><p>REST의 기본 원칙을 성실히 지킨 서비스 디자인을 “RESTful”이라고 표현한다.</p>
</li>
</ul>
<a id="more"></a>
<h1 id="REST-API-중심-규칙"><a href="#REST-API-중심-규칙" class="headerlink" title="REST API 중심 규칙"></a>REST API 중심 규칙</h1><h2 id="1-URI는-정보의-자원을-표현해야-한다"><a href="#1-URI는-정보의-자원을-표현해야-한다" class="headerlink" title="1. URI는 정보의 자원을 표현해야 한다."></a>1. URI는 정보의 자원을 표현해야 한다.</h2><ul>
<li>자원을 표현하는데 중점을 두어야 한다.</li>
<li>리소스명은 동사(get)보다는 명사를 사용한다.</li>
<li>GET /books/1 (o)</li>
<li>GET /members/delete/1 (x) - delete와 같은 행위에 대한 표현이 들어가선 안된다.</li>
<li>DELETE /members/1 (o) - 위의 잘못된 표현 수정</li>
</ul>
<h2 id="2-자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-으로-표현한다"><a href="#2-자원에-대한-행위는-HTTP-Method-GET-POST-PUT-DELETE-등-으로-표현한다" class="headerlink" title="2. 자원에 대한 행위는 HTTP Method(GET,POST,PUT,DELETE 등)으로 표현한다."></a>2. 자원에 대한 행위는 HTTP Method(GET,POST,PUT,DELETE 등)으로 표현한다.</h2><ul>
<li>DELETE /books/1</li>
</ul>
<h1 id="HTTP-Method"><a href="#HTTP-Method" class="headerlink" title="HTTP Method"></a>HTTP Method</h1><ul>
<li>4가지의 Method를 사용하여 CRUD를 구현한다.</li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Action</th>
<th>역할</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create</td>
<td>POST</td>
<td>리소스를 생성</td>
</tr>
<tr>
<td>Read - index/retrieve</td>
<td>GET</td>
<td>모든/특정 리소스를 조회</td>
</tr>
<tr>
<td>Update</td>
<td>PUT</td>
<td>리소스를 갱신</td>
</tr>
<tr>
<td>delete</td>
<td>DELETE</td>
<td>리소스를 삭제</td>
</tr>
</tbody>
</table>
<h1 id="REST-API의-구성"><a href="#REST-API의-구성" class="headerlink" title="REST API의 구성"></a>REST API의 구성</h1><ul>
<li>REST API는 자원(Resource),행위(Verb),표현(Representations)의 3가지 요소로 구성된다.</li>
<li>REST는 자체 표현 구조(Self-descriptiveness)로 구성되어 REST API만으로 요청을 이해할 수 있다</li>
</ul>
<table>
<thead>
<tr>
<th>구성요소</th>
<th>내용</th>
<th>표현 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resource</td>
<td>자원</td>
<td>HTTP URI</td>
</tr>
<tr>
<td>Verb</td>
<td>자원에 대한 행위</td>
<td>HTTP Method</td>
</tr>
<tr>
<td>Representations</td>
<td>자원에 대한 행위의 내용</td>
<td>HTTP Message Pay Load</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rest, crud </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax와 JSON]]></title>
      <url>/2017/10/17/TIL-1017/</url>
      <content type="html"><![CDATA[<h1 id="Ajax-Asynchronous-JavaScript-and-XML"><a href="#Ajax-Asynchronous-JavaScript-and-XML" class="headerlink" title="Ajax(Asynchronous JavaScript and XML)"></a>Ajax(Asynchronous JavaScript and XML)</h1><ul>
<li>자바스크립트를 이용해서  비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식이다.</li>
<li>서버로부터 웹페이지가 반환되면 화면 전체를 갱신해야 하는데 페이지 일부만 갱신하고도 동일한 효과를 볼 수 있도록 하는 것이다.</li>
<li>Client에서 HTTP Request 객체를 이용해 데이터를 요청한다. </li>
<li>Server에서 HTTP Response 객체를 이용해 server의 응답에 요청한다.</li>
<li>데이터를 반환할 때 데이터 형식은 문자열로 받은 객체를 JSON으로 변경하거나, JSON을 객체화 시키는 두가지가 있다.</li>
</ul>
<h1 id="JSON-JavaScript-Object-Notation"><a href="#JSON-JavaScript-Object-Notation" class="headerlink" title="JSON (JavaScript Object Notation)"></a>JSON (JavaScript Object Notation)</h1><ul>
<li>HTML, Text, JSON 등을 반환하는데 Ajax을 위한 데이터 형식이다.</li>
<li>쌍 따옴표를 사용한다.(프로퍼티 이름도)</li>
<li>객체리터럴과 흡사하나, 순순한 텍스트로 구성되었다.</li>
<li>코멘트, 주석을 쓰면 에러가 발생한다.</li>
</ul>
<h1 id="데이터-형식"><a href="#데이터-형식" class="headerlink" title="데이터 형식"></a>데이터 형식</h1><h2 id="객체-gt-JSON-형식의-문자열"><a href="#객체-gt-JSON-형식의-문자열" class="headerlink" title="객체 -&gt; JSON 형식의 문자열"></a>객체 -&gt; JSON 형식의 문자열</h2><ul>
<li>JSON.stringify(객체)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'Choi'</span>,</span><br><span class="line">    gender : <span class="string">'female'</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObj = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj, strObj);</span><br><span class="line"><span class="comment">// string &#123;"name":"Choi","gender":"female","age":"20"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>개발자가 데이터 확인할 때,(편의성, 가독성)</li>
<li>JSON.stringify(obj, 필터함수, 공백갯수) 의 인자값을 준다.</li>
<li>필터 함수는 직접 함수를 정의한다. (원하는 데이터만 출력하기 위해 작성)</li>
<li>공백갯수는 프로퍼티 앞의 공백의 갯수를 말한다. 개발자의 가독성을 위해 준다. </li>
</ul>
<h2 id="JSON-형식의-문자열-gt-객체"><a href="#JSON-형식의-문자열-gt-객체" class="headerlink" title="JSON 형식의 문자열 -&gt; 객체"></a>JSON 형식의 문자열 -&gt; 객체</h2><ul>
<li>JSON.parse(문자열)</li>
<li>역직렬화<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(stObj);</span><br><span class="line"><span class="comment">//strObj =  &#123;"name":"Choi","gender":"female","age":"20"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o, o);</span><br><span class="line"><span class="comment">//o &#123;name:'Choi',gender:'female',age:'20'&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><ul>
<li>브라우저는 XMLHttpRequest 객체를 이용하여 Ajax 요청을 생성하고 전송한다.</li>
</ul>
<h2 id="Ajax-request"><a href="#Ajax-request" class="headerlink" title="Ajax request"></a>Ajax request</h2><ul>
<li>Ajax 요청 처리</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XMLHttpRequest 객체 생성</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">//비동기 방식으로 Request를 오픈한다.</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/users'</span>);</span><br><span class="line"><span class="comment">//Request를 전송한다.</span></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<ol>
<li>XMLHttpRequest.open</li>
</ol>
<ul>
<li>XMLHttpRequest 객체의 인스턴스를 생성하고 open메소드를 사용하여 서버로의 요청을 준비한다.</li>
<li>XMLHttpRequest.open(method, url, async)</li>
<li>method : HTTP method(GET, POST, PUT, DELETE 등)</li>
<li>url : 요청을 보낼 URL, 한서버에서만 요청을 주고 받기 때문에(파일을 전달받은 서버와 같은 서버) 주로 같은 경로를 사용한다.</li>
<li>async : 비동기 조작 여부, default는 true(비동기)</li>
</ul>
<ol>
<li>XMLHttpRequest.send</li>
</ol>
<ul>
<li>준비된 요청을 서버에 전달한다.</li>
<li>GET, POST 메소드에 따라 전송방식에 차이가 있다.</li>
<li>GET 메소드는 URL의 일부분인 쿼리문자열(쿼리 파라미터)로 데이터를 서버로 전송한다.</li>
<li>POST 메소드는 데이터(payload)를 Request body에 담아 전송한다.(payload:body에 담기는 data)</li>
<li>XMLHttpRequest.send 메소드는 request body에 담아 전송할 인수를 전달 할 수 있다.</li>
<li>HTTP Request/Response Message Pair 에는 Header와 Body가 있는데, Header에는 전달하려는 요청 정보를 담는다.</li>
<li>**요청 메소드가 GET인 경우 send메소드의 인수는 무시되고 request body는 null로 설정된다.</li>
</ul>
<ol>
<li>XMLHttpRequest.setRequestHeader</li>
</ol>
<ul>
<li>HTTP Request Header 값을 설정한다.</li>
<li>Request Header의 Content-type은 request body에 담아 서버로 전송할 데이터의 MIME-type을 지정한다.</li>
<li>Request header의 Accept는 클라이언트가 서버에 요청할 때 서버가 센드백할 데이터의 MIME-type을 지정한다.</li>
<li>Accept 헤더를 설정하지 않으면 <em>/</em>으로 전송된다.</li>
<li>setReuqestHeader 메소드는 반드시 open메소드 뒤에 호출한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.open(<span class="string">'POST'</span>,<span class="string">'/users'</span>);</span><br><span class="line"><span class="comment">//application/x-www-form-urlencoded는 key=value&amp;key=value...형태로 전송</span></span><br><span class="line">req.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line"><span class="comment">//서버가 센드백할 데이터의 MIME-type : json</span></span><br><span class="line">req.setRequestHeader(<span class="string">'Accept'</span>,<span class="string">'application/json'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Ajax-response"><a href="#Ajax-response" class="headerlink" title="Ajax response"></a>Ajax response</h2><ul>
<li>Ajax 응답 처리</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request(요청방식)와 동일</span></span><br><span class="line"><span class="comment">// 비동기방식으로 (XMLHttp)Request를 오픈한 후, 전송</span></span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">req.opne(<span class="string">'GET'</span>, <span class="string">'data/test.json'</span>);</span><br><span class="line">req.send();</span><br><span class="line"></span><br><span class="line"><span class="comment">//readyState 프로퍼티가 변경될 때마다 콜백함수를 호출한다.</span></span><br><span class="line">req.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="comment">//readyState: XMLHttpRequest 상태(state)를 반환</span></span><br><span class="line"><span class="comment">// 4(DONE) : 서버 응답 완료</span></span><br><span class="line">    <span class="keyword">if</span>(req.readyState === XMLHttpRequest.Done)&#123;</span><br><span class="line">        <span class="comment">// response 상태 코드를 반환, 200(정상 응답)</span></span><br><span class="line">        <span class="keyword">if</span>(req.status === <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//텍스트(데이터) 출력</span></span><br><span class="line">            <span class="built_in">console</span>.log(req.responseText);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Error!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h1><ul>
<li>내 PC에 깔려있는 웹서버(가상 서버)</li>
<li>localhost:port</li>
<li>웹서버마다 port를 설정해준다.</li>
<li>가상 서버(localhost)에서 실제 서버로 보내는 것을 배포라고 한다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ajax, json, Asynchronous, http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM Tree와 HTML 문서 구조]]></title>
      <url>/2017/10/16/TIL-1016/</url>
      <content type="html"><![CDATA[<h1 id="문서-객체-모델-DOM"><a href="#문서-객체-모델-DOM" class="headerlink" title="문서 객체 모델(DOM)"></a>문서 객체 모델(DOM)</h1><ul>
<li>브라우저는 파일을 불러들인 후(loading) 컴퓨터가 이해할수 있는 방식으로 한줄씩 해석하여(parsing) 문서객체모델(DOM)을 생성한다.</li>
<li>자바스크립트 엔진을 구동시킨다.</li>
<li>HTML 문서는 DOM tree 형태로 구조화 되어 있다.</li>
<li>DOM tree + CSSOM tree = Render tree</li>
<li>DOM은 html 문서에 대한 구성(DOM tree), 문서 내의 각 요소에 접근/수정(프로퍼티와 메소드 제공)을 할 수 있다.</li>
</ul>
<h1 id="DOM-tree"><a href="#DOM-tree" class="headerlink" title="DOM tree"></a>DOM tree</h1><ul>
<li>브라우저가 HTML문서를 로드한 후 생성하는 모델을 의미한다.</li>
<li>객체의 트리로 구조화되어 있기 때문에 DOM tree라고 부른다.</li>
<li>DOM에서 모든 요소, 어트리뷰트, 텍스트는 하나의 객체이며 Document 객체의 자식이다. </li>
<li>DOM tree는 문서노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드로 구성된다.</li>
<li>Javascript는 DOM에서 웹 페이지를 조작하기 위한 수단(API)을 제공한다.</li>
</ul>
<a id="more"></a>
<h1 id="한-개의-요소-노드-선택"><a href="#한-개의-요소-노드-선택" class="headerlink" title="한 개의 요소 노드 선택"></a>한 개의 요소 노드 선택</h1><h2 id="document-getElementById-id"><a href="#document-getElementById-id" class="headerlink" title="document.getElementById(id)"></a>document.getElementById(id)</h2><ul>
<li>id 어트리뷰트 값으로 요소 노드를 한개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다.</li>
<li>모든 브라우저에서 동작한다.</li>
<li>Return : HTMLElement를 상속받은 객체</li>
</ul>
<h2 id="document-querySelector-cssSelector"><a href="#document-querySelector-cssSelector" class="headerlink" title="document.querySelector(cssSelector)"></a>document.querySelector(cssSelector)</h2><ul>
<li>CSS 셀렉터를 사용하여 요소 노드를 한개 선택한다. 복수개가 선택된 경우, 첫번째 요소만 반환한다.</li>
<li>IE8이상의 브라우저에서 동작한다.</li>
<li>Return : HTMLElement를 상속받은 객체</li>
</ul>
<h1 id="여러개의-요소-노드-선택"><a href="#여러개의-요소-노드-선택" class="headerlink" title="여러개의 요소 노드 선택"></a>여러개의 요소 노드 선택</h1><h2 id="document-getElementsByClassName-class"><a href="#document-getElementsByClassName-class" class="headerlink" title="document.getElementsByClassName(class)"></a>document.getElementsByClassName(class)</h2><ul>
<li>class 어트리뷰트 값으로 요소 노드를 모두 선택한다. 공백으로 구분하여 여러개의 class를 지정할 수 있다.</li>
<li>Return: HTMLCollection (live) : 실시간으로 값이 변경된다.(실시간으로 노드의 상태를 반영한다)</li>
<li>HTMLCollection : HTMLElement의 리스트를 담아 반환하기 위한 객체로 유사배열(array-like object)이다.</li>
<li>IE9이상에서 동작한다.</li>
</ul>
<h2 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h2><ul>
<li>크로스 스크립팅 공격에 취약하다</li>
</ul>
<h1 id="javascript-event"><a href="#javascript-event" class="headerlink" title="javascript event"></a>javascript event</h1><ul>
<li><p>이벤트가 실행, 콜스택이 비었을때 queue에있는 콜백함수가 스택으로 이동한다.</p>
</li>
<li><p>대부분의 Event, Timer 함수, Ajax는 비동기로 동작한다.</p>
</li>
<li>이벤트가 발생되었을 때 클릭이벤트에 콜백함수가 바인딩되었다라고한다.</li>
</ul>
<p>이벤트바인딩</p>
<ul>
<li>자바스크립트가 HTML 코드 안에 혼용되서는 안된다. 두 언어가 관심사가 다르기 때문이다.</li>
<li>onclick 이벤트는 한 이벤트 당 하나의 함수만 호출할 수 있다. =&gt; addEventListener</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM, document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wrapper 객체]]></title>
      <url>/2017/10/13/TIL-1013/</url>
      <content type="html"><![CDATA[<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><ul>
<li>기본자료형 number를 위한 wrapper 객체</li>
<li>기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문에 기본자료형이 wrapper 객체 메소드를 사용할 수 있다.</li>
</ul>
<h1 id="Number-Constructor"><a href="#Number-Constructor" class="headerlink" title="Number Constructor"></a>Number Constructor</h1><ul>
<li>new Number(value)</li>
<li>숫자로 변환할 수 없다면 NaN을 반환한다.</li>
<li>기본자료형 숫자 반환 방식은 Number(Value)</li>
<li>new Number와 Number 형 비교<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x == y);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// false (타입이 다르다)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h1 id="Number-Property"><a href="#Number-Property" class="headerlink" title="Number Property"></a>Number Property</h1><h2 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h2><ul>
<li>자바스크립트에서 사용 가능한 가장 큰 숫자이다.</li>
<li>MAX_VAULE보다 큰 숫자는 Infinity 이다.</li>
</ul>
<h2 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h2><ul>
<li>0에 가장 가까운 양수값이다.</li>
<li>MIN_VALUE보다 작은 숫자는 0 이다.</li>
</ul>
<h2 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h2><ul>
<li>양의 무한대 Infinity를 반환한다.</li>
</ul>
<h2 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h2><ul>
<li>음의 무한대 -Infinity를 반환한다.</li>
</ul>
<h2 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h2><ul>
<li>숫자가 아님을 나타낸다.</li>
<li>window.NaN과 같다.</li>
</ul>
<h1 id="Number-Method"><a href="#Number-Method" class="headerlink" title="Number Method"></a>Number Method</h1><ul>
<li>숫자가 아닐 경우, 인수를 숫자로 변환하지 않고 false를 반환한다.</li>
</ul>
<h2 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h2><ul>
<li>매개변수 값이 정상적인 유한수인지를 검사하여 Boolean값을 반환한다.</li>
<li>전역 함수 isFinite(value)는 인수를 숫자로 변환하여 결과값을 반환한다.</li>
</ul>
<h2 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h2><ul>
<li>매개변수 값이 정수인지 검사하여 Boolean값으로 반환한다.</li>
</ul>
<h2 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h2><ul>
<li>매개변수 값이 NaN인지를 검사하여 Boolean값을 반환한다.</li>
<li>Not a Number 숫자가 아니면 true 반환한다.</li>
</ul>
<h2 id="Number-isSafeInteger"><a href="#Number-isSafeInteger" class="headerlink" title="Number.isSafeInteger()"></a>Number.isSafeInteger()</h2><ul>
<li>매개변수 값이 안전한 정수 값인지를 검사하여 Boolean값을 반환한다.</li>
<li>안전한 정수 값은 (253 - 1)와 -(253 - 1) 사이의 정수이다.</li>
</ul>
<h2 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h2><ul>
<li>지수 표기법으로 변환하여 문자열로 반환한다.</li>
<li>예를들어, 1.234e+3는 e(xponential)의 앞에 있는 숫자의 10의 3승을 나타낸다.</li>
<li>변수.toExponential(n); 반올림하여 소수 n번째 짜리까지 지수 표기법으로 반환한다.</li>
<li>인수는 0~20까지 입력할 수 있다.</li>
</ul>
<h2 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h2><ul>
<li>매개변수로 지정된 소수점 자리를 반올림하여 문자열로 반환한다.</li>
</ul>
<h2 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h2><ul>
<li>지정된 전체 자릿수까지 유효하도록 반올림하여 문자열로 반환한다. </li>
<li>지정된 전체 자릿수로 표현할 수 없을 경우 지수표기법으로 쓴다.</li>
</ul>
<h2 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h2><ul>
<li>숫자를 문자열로 변환하여 반환한다.</li>
<li>toString(n) n은 2~36값으로 진수를 나타낸다.</li>
</ul>
<hr>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><ul>
<li>수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다.</li>
</ul>
<h1 id="Math-Property"><a href="#Math-Property" class="headerlink" title="Math Property"></a>Math Property</h1><h2 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h2><ul>
<li>PI값을 반환한다.</li>
</ul>
<h1 id="Math-Method"><a href="#Math-Method" class="headerlink" title="Math Method"></a>Math Method</h1><h2 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h2><ul>
<li>0 또는 양수인 절대값을 반환한다.</li>
<li>숫자가 아닐 경우 NaN을 반환한다.</li>
</ul>
<h2 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h2><ul>
<li>가장 인접한 정수로 올림/내림한다.</li>
<li>x = Math.round(-20.5); // -20</li>
<li>x = Math.round(-20.51); // -21</li>
</ul>
<h2 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h2><ul>
<li>양의 제곱근을 반환한다.</li>
</ul>
<h2 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h2><ul>
<li>지정된 숫자를 자신보다 크고, 가까운 정수로 올림한다.</li>
</ul>
<h2 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h2><ul>
<li>지정된 숫자를 자기보다 작고, 가까운 정수로 내림한다.</li>
</ul>
<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><ul>
<li>0과 1 사이의 임의의 숫자를 반환한다.</li>
<li>(Math.random() * 10) + 1 : 1에서 10까지의 임의의 숫자를 반환한다.</li>
</ul>
<h2 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h2><ul>
<li>첫번째 인수를 밑, 두번째 인수를 지수로 하여 거듭제곱을 반환한다.</li>
<li>Math.pow(7,2); // 49</li>
</ul>
<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h2><ul>
<li>인수중에 가장 큰 수를 반환한다.</li>
<li>배열을 인자값으로 받을때는 apply를 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6에서 사용법</span></span><br><span class="line"><span class="keyword">var</span> max <span class="built_in">Math</span>.max(...arr);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Math-min"><a href="#Math-min" class="headerlink" title="Math.min()"></a>Math.min()</h2><ul>
<li>인수중에 가장 작은 수를 반환한다.</li>
</ul>
<hr>
<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><ul>
<li>날짜와 시간(년,월,일,시,분,초)을 위한 빌트인 객체이다.</li>
<li>UTC(협정 세계시)는 GMT(그리니치 평균시)라고도 한다.</li>
<li>KST(Korea Standard Time)은 UTC보다 9시간이 빠르다.</li>
<li>현재의 날짜와 시간은 자바스크립트 코드가 동작한 시스템의 시계에 의해 결정된다.</li>
</ul>
<h1 id="Date의-Constructor"><a href="#Date의-Constructor" class="headerlink" title="Date의 Constructor"></a>Date의 Constructor</h1><ul>
<li>Date 생성자를 이용하여 날짜와 시간을 가지는 인스턴스를 생성한다. </li>
<li>기본적으로 현재 날짜와 시간을 나타내는 값을 가진다.</li>
<li>new Date()</li>
<li>new 연산자 없이 Date()를 사용하면 결과값을 객체가 아닌 문자열로 반환한다.</li>
</ul>
<h2 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date()"></a>new Date()</h2><ul>
<li>매개변수가 없는 경우, 현재 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
</ul>
<h2 id="new-Date-milliseconds"><a href="#new-Date-milliseconds" class="headerlink" title="new Date(milliseconds)"></a>new Date(milliseconds)</h2><ul>
<li>1970년 1월 1일 00:00(UTC)을 기점으로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
</ul>
<h2 id="new-Date-dateString"><a href="#new-Date-dateString" class="headerlink" title="new Date(dateString)"></a>new Date(dateString)</h2><ul>
<li>지정된 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
<li>var d = new Date(‘May 12, 2016 12:13:00’);</li>
<li>var d = new Date(‘2017/08/08/20:00:00’);</li>
</ul>
<h2 id="new-Date-year-month-day-hour-minute-second-millisecond"><a href="#new-Date-year-month-day-hour-minute-second-millisecond" class="headerlink" title="new Date(year, month[, day, hour, minute, second, millisecond])"></a>new Date(year, month[, day, hour, minute, second, millisecond])</h2><ul>
<li>매개변수에 년,월,일,시,분,초,밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
<li>year 1990년 이후의 년</li>
<li>month 월을 나타내는 0~11까지의 정수(1월은 0)</li>
</ul>
<h1 id="Date-Method"><a href="#Date-Method" class="headerlink" title="Date Method"></a>Date Method</h1><h2 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.</li>
</ul>
<h2 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.</li>
<li>var d = Date.parse(‘Jan 2, 1970 00:00:00 UTC’); // UTC</li>
<li>var d = Date.parse(‘Jan 2, 1970 09:00:00’); // KST</li>
<li>var d = Date.parse(‘1970/01/02/09:00:00’); // KST</li>
</ul>
<h2 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.</li>
<li>var d = Date.UTC(1970, 0, 2);</li>
<li>var d = Date.UTC(‘1970/1/2’); //NaN 이 형식으로는 인식되지 않는다.</li>
</ul>
<h2 id="Date-prototype-getFullYear-getMonth-getDate-getDay-getHours-getMinutes-getSeconds-getMilliseconds-getTime"><a href="#Date-prototype-getFullYear-getMonth-getDate-getDay-getHours-getMinutes-getSeconds-getMilliseconds-getTime" class="headerlink" title="Date.prototype.getFullYear() / getMonth() / getDate() / getDay() / getHours() / getMinutes() / getSeconds() / getMilliseconds() / getTime()"></a>Date.prototype.getFullYear() / getMonth() / getDate() / getDay() / getHours() / getMinutes() / getSeconds() / getMilliseconds() / getTime()</h2><ul>
<li>해당 연도/월/일/요일을 나타내는 4자리 숫자를 반환한다.</li>
<li>getTime()은 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다.</li>
</ul>
<h2 id="Date-prototype-setFullYear-setMonth-setDate-setDay-setHours-setMinutes-setSeconds-setMilliseconds-setTime"><a href="#Date-prototype-setFullYear-setMonth-setDate-setDay-setHours-setMinutes-setSeconds-setMilliseconds-setTime" class="headerlink" title="Date.prototype.setFullYear() / setMonth() / setDate() / setDay() / setHours() / setMinutes() / setSeconds() / setMilliseconds() / setTime()"></a>Date.prototype.setFullYear() / setMonth() / setDate() / setDay() / setHours() / setMinutes() / setSeconds() / setMilliseconds() / setTime()</h2><ul>
<li>해당 연도/월/일/요일을 나타내는 4자리 숫자를 설정한다.</li>
<li>setFullYear() 연도 이외의 월,일을 설정할 수 있다.</li>
</ul>
<h2 id="Date-prototype-getTimezoneOffset"><a href="#Date-prototype-getTimezoneOffset" class="headerlink" title="Date.prototype.getTimezoneOffset()"></a>Date.prototype.getTimezoneOffset()</h2><ul>
<li>UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다.</li>
</ul>
<h2 id="Date-prototype-toDateString-Date-prototype-toTimeString"><a href="#Date-prototype-toDateString-Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toDateString() / Date.prototype.toTimeString()"></a>Date.prototype.toDateString() / Date.prototype.toTimeString()</h2><ul>
<li>사람이 읽을 수 있는 형식의 문자열로 날짜 / 시간을 반환한다.</li>
<li>var d = new Date(‘1988/8/17/13:30’);</li>
<li>console.log(d.toDateString()); // Sat Sep 17 1988</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> wrapper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[실행 컨텍스트와 클로저]]></title>
      <url>/2017/10/12/TIL-1012/</url>
      <content type="html"><![CDATA[<h1 id="실행-컨텍스트-Execution-Context"><a href="#실행-컨텍스트-Execution-Context" class="headerlink" title="실행 컨텍스트(Execution Context)"></a>실행 컨텍스트(Execution Context)</h1><ul>
<li>실행 가능한 코드가 실행되는 환경이다.</li>
<li>실행 가능한 코드 : 전역코드, Eval코드(안씀), 함수코드(호출)</li>
<li>변수와 함수가 호출되기 위한 환경이 만들어진다.</li>
<li>자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 정보를 알고 있으며, 실행 컨텍스트를 물리적 객체의 형태로 관리한다.</li>
<li>실행에 필요한 정보 : 변수(객체의 프로퍼티, 전역변수, 지역변수, 매개변수), 함수선언(함수명, 함수), 변수의 유효범위(전역이냐 지역이냐), this(가리키고 있는 객체)</li>
</ul>
<h1 id="실행-컨텍스트-스택-콜-스택"><a href="#실행-컨텍스트-스택-콜-스택" class="headerlink" title="실행 컨텍스트 스택(=콜 스택)"></a>실행 컨텍스트 스택(=콜 스택)</h1><ul>
<li>실행 컨텍스트가 생성되서 쌓이는 영역</li>
<li>전역 실행 컨텍스트, 함수 실행 컨텍스트가 생성되면 실행 컨텍스트 스택에 쌓인다.</li>
<li>함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며, 함수가 끝나면 해당 함수의 실행 컨텍스트가 사라진다.</li>
</ul>
<a id="more"></a>
<h1 id="실행-컨텍스트-3가지-객체"><a href="#실행-컨텍스트-3가지-객체" class="headerlink" title="실행 컨텍스트 3가지 객체"></a>실행 컨텍스트 3가지 객체</h1><ul>
<li>Variable Object(VO), Scope Chain(SC), this value</li>
</ul>
<ol>
<li>Variable Object</li>
</ol>
<ul>
<li>변수(함수표현식 포함), 매개변수와 인수, 함수선언의 정보를 담는 객체로 유일하며 최상위에 위치한 객체이다.</li>
<li>전역 컨텍스트의 VO는 전역객체(GO)를 가리키고, 함수 컨텍스트의 VO는 활성객체(AO)를 가리킨다.</li>
<li>전역 객체(GO)는 전역에 선언된 전역 변수, 전역 함수를 프로퍼티로 소유한다.</li>
<li>활성 객체(AO)는 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 arguments객체가 추가된다.</li>
<li>전역 객체(Global Object)는 1개 생성, 활성객체(Activation Object)는 여러개 생성이 가능하다.</li>
</ul>
<ol>
<li>Scope Chain</li>
</ol>
<ul>
<li>스코프 체인은 일종의 리스트로서 중첩된 함수의 레퍼런스를 저장하고 있다.</li>
<li>마지막 리스트는 항상 전역 객체(GO)를 가리킨다.</li>
<li>함수 실행 컨텍스트의 스코프 체인의 경우, 레퍼런스로 자기 자신의 AO와 GO를 가리킨다.</li>
<li>스코프 체인(리스트)을 검색하면 함수가 중첩 상태일 때, 하위함수 내에서 상위함수의 유효 범위까지 참조할 수 있게 된다.</li>
</ul>
<ol>
<li>this value</li>
</ol>
<ul>
<li>this의 값이 할당된다.</li>
<li>함수 호출 패턴에 의해 결정된다.</li>
</ul>
<h2 id="전역-코드에의-진입"><a href="#전역-코드에의-진입" class="headerlink" title="전역 코드에의 진입"></a>전역 코드에의 진입</h2><ol>
<li>전역 객체 생성</li>
</ol>
<ul>
<li>컨트롤이 실행 컨텍스트에 접근하기 이전에 유일한 전역 객체(Global Object)가 생성된다.</li>
<li>전역 객체에는 빌트인 객체와 BOM, DOM이 설정되어 있다.</li>
</ul>
<ol>
<li>실행 컨텍스트 생성 후 스택</li>
</ol>
<ul>
<li>전역 코드로 컨트롤이 진입하면 실행 컨텍스트가 생성된 후, 실행 컨텍스트 스택에 쌓인다.</li>
</ul>
<ol>
<li>스코프 체인(SC)의 생성과 초기화</li>
</ol>
<ul>
<li>전역 객체의 레퍼런스를 포함하는 리스트가 된다.</li>
</ul>
<ol>
<li>Variable Instantiation(변수 객체화) 실행</li>
</ol>
<ul>
<li>Variable Instantiation은 VO에 프로퍼티와 값을 추가하는 것이다.</li>
<li>변수, 매개변수, 인수정보(arguments), 함수선언을 VO에 추가하여 객체화한다.</li>
<li>함수부터 변수 순으로 저장된다.</li>
</ul>
<p>4-1. “변수 객체화의 순서”</p>
<ul>
<li><ol>
<li>Function일 경우 매개변수(parameter)가 VO의 프로퍼티로, 인수(arguments)가 값으로 설정된다.</li>
</ol>
</li>
<li><ol>
<li>함수선언(함수표현식 제외)을 대상으로 함수명이 VO(VO가 가리키고 있는 객체)프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)</li>
</ol>
</li>
<li><ol>
<li>변수 선언을 대상으로 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)</li>
</ol>
</li>
</ul>
<ol>
<li>함수의 선언 처리(함수가 있다면)</li>
</ol>
<ul>
<li>변수 객체화의 순서 2번처럼 함수명이 프로퍼티로, 생성된 함숫 객체(몸체)가 값으로 설정된다.(전역 함수일 경우 GO에 설정)</li>
<li>생성된 함수 객체는 [[Scope]] 프로퍼티를 가지게 된다.</li>
<li>(함수 호출 실행 이전)[[Scope]]는 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정하고, (함수 실행 후)스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 함수선언식 이전에 함수를 호출할 수 있다. (함수 호이스팅)</li>
</ul>
<ol>
<li>변수의 선언 처리(변수가 있을때)</li>
</ol>
<ul>
<li>변수 객체화의 순서 3번처럼 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.</li>
<li>var 키워드로 선언된 변수는 선언과 초기화 단계가 한번에 이루어진다.</li>
<li>변수 선언문 이전에 접근해도 VO에 변수가 undefined로 초기화된 상태로 존재하기 때문에 에러가 나지 않는다.(변수 호이스팅)</li>
</ul>
<ol>
<li>this value의 결정</li>
</ol>
<ul>
<li>this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다.</li>
</ul>
<h2 id="전역-코드의-실행"><a href="#전역-코드의-실행" class="headerlink" title="전역 코드의 실행"></a>전역 코드의 실행</h2><ol>
<li>변수값 할당</li>
</ol>
<ul>
<li>변수값을 할당할 때는 VO(VO가 가리키고 있는 객체, 전역의 경우 GO)를 선두(0)부터 검색하여 해당 변수의 프로퍼티를 발견하면 값을 할당 한다.</li>
</ul>
<ol>
<li>함수 실행</li>
</ol>
<ul>
<li>함수가 실행되면 새로운 함수 실행 컨텍스트가 생성된다.</li>
<li>해당 함수로 실행 컨텍스트의 컨트롤이 이동하면 전역 코드와 마찬가지로  1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 실행된다.</li>
</ul>
<h2 id="함수-코드에의-진입"><a href="#함수-코드에의-진입" class="headerlink" title="함수 코드에의 진입"></a>함수 코드에의 진입</h2><ul>
<li>전역 코드에의 진입과 순서는 같지만 다른 룰이 적용된다.</li>
</ul>
<ol>
<li>스코프 체인의 생성과 초기화</li>
</ol>
<ul>
<li>Activation Object생성**</li>
<li>AO에 대한 레퍼런스를 스코프 체인의 선두에 설정한다.</li>
<li>Activation Object는 arguments 프로퍼티를 초기화한다.</li>
<li>스코프 체인의 마지막 레퍼런스 객체는 전역 객체를 참조한다.</li>
</ul>
<ol>
<li>Variable Instantiation 실행</li>
</ol>
<ul>
<li>함수 객체와 변수를 VO에 바인딩한다.(선언, 초기화)</li>
<li>변수의 프로퍼티는 변수명, 값은 undefined로 VO에 저장한다.</li>
<li>함수의 프로퍼티는 함수명, 값은 Function Object로 VO에 저장한다.</li>
<li>Function Object의 [[scope]] 프로퍼티가 생성된다. </li>
<li>[[scope]] 프로퍼티는 AO와 전역을 참조하는 리스트의 값을 갖는다.</li>
</ul>
<ol>
<li>this value 결정</li>
</ol>
<ul>
<li>this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</li>
</ul>
<h2 id="함수-코드의-실행-함수에-변수가-존재할때"><a href="#함수-코드의-실행-함수에-변수가-존재할때" class="headerlink" title="함수 코드의 실행(함수에 변수가 존재할때)"></a>함수 코드의 실행(함수에 변수가 존재할때)</h2><ol>
<li>변수 값의 할당</li>
</ol>
<ul>
<li>지역변수를 할당할 때(현재는 내부함수일 경우), 스코프 체인이 참조하고 있는 VO를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값을 할당한다. (해당 영역에도 없으면 스코프 체인 리스트를 참조하여 GO를 검색하도록 한다.)</li>
</ul>
<h2 id="내부-함수-코드의-실행"><a href="#내부-함수-코드의-실행" class="headerlink" title="내부 함수 코드의 실행"></a>내부 함수 코드의 실행</h2><ul>
<li>내부 함수가 실행되기 시작하면 새로운 실행 컨텍스트가 생성된다.</li>
<li>여기서도  1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 진행된다.</li>
</ul>
<h1 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h1><ul>
<li>내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다.</li>
<li>외부함수가 내부함수보다 더 오래 유지되는 경우에 내부함수가 외부함수의 지역변수에 접근할 수 있고 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해 소멸하게 되는 특성을 말한다.</li>
<li>클로저에 의해 참조되는 외부함수의 변수를 자유변수(Free variable)이라고 부른다.</li>
<li>(실행 컨텍스트 관점에서)내부함수가 유효한 경우에 외부함수가 종료 되면 함수의 실행 컨텍스트도 소멸하지만, 함수 실행 컨텍스트의 AO는 유효하기 때문에 내부함수가 스코프 체인을 통해 참조할 수 있다. </li>
</ul>
<h1 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h1><ul>
<li>성능적인 면과 자원적인 면에서 손해를 볼 수 있다.</li>
<li>(실행 컨텍스트에서) 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당되어 있기 때문에 성능 상 좋다고 할 수 없다.(최소화하며 오남용하지 않아야 한다.)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Count!&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;demo&quot;&gt;0&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var add = (function () &#123;</span><br><span class="line">    var counter = 0;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      return ++counter;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  function myFunction() &#123;</span><br><span class="line">    document.getElementById(&apos;demo&apos;).innerHTML = add();</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>전역 변수의 사용 억제를 위한 방식</li>
<li>즉시 실행함수는 한번만 실행되므로 counter가 다시 초기화되지 않는다.</li>
<li>외부함수의 변수 counter는 참조하는 함수(내부함수)가 소멸될때까지 유지된다.</li>
<li>counter는 외부에서 접근할 수 없는 private 변수이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> closure </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[빌트인객체-2]]></title>
      <url>/2017/10/11/TIL-1011/</url>
      <content type="html"><![CDATA[<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><ul>
<li>생성자 함수가 없는 객체는 Static 함수.</li>
<li>new Number(value)</li>
<li>value에 문자열이 들어갔을때, 최대한 형변환된다.(숫자가 아니면 NaN 반환)</li>
<li>래퍼 객체를 통해 형변환하는 것은 좋은 것이 아니다.</li>
</ul>
<a id="more"></a>
<h1 id="Number-Property"><a href="#Number-Property" class="headerlink" title="Number Property"></a>Number Property</h1><h2 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX-VALUE"></a>Number.MAX-VALUE</h2><h2 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN-VALUE"></a>Number.MIN-VALUE</h2><ul>
<li>0에 가장 가까운 양수값</li>
</ul>
<h2 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h2><ul>
<li>INFINITY 양의무한대를 가지는 상수</li>
</ul>
<h2 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h2><h2 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h2><h1 id="Number-method"><a href="#Number-method" class="headerlink" title="Number method"></a>Number method</h1><ul>
<li>기본적으로 형변환을 안한다.(엄격함)</li>
<li>prototype.메서드를 쓰지 않음. static 함수이다.</li>
</ul>
<h2 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h2><ul>
<li>숫자이고 유한한 값</li>
<li>전역함수의 isNaN()과의 차이 : 형변환을 안함(엄격함)</li>
</ul>
<h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><ul>
<li>Number.isInteger(0 / 0) // NaN(Not a Number) -&gt; false</li>
</ul>
<h2 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h2><ul>
<li>이것도 전역함수의 isNaN()과 다르게 형변환을 안함(엄격함)</li>
</ul>
<h2 id="Number-isSafeInteger"><a href="#Number-isSafeInteger" class="headerlink" title="Number.isSafeInteger()"></a>Number.isSafeInteger()</h2><ul>
<li>자바스크립트에서 사용할 수 있는 정수인지를 검사하여 boolean을 반환</li>
<li>Number.isSafeInteger(10000000000000001) // false</li>
</ul>
<h2 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h2><h2 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h2><ul>
<li>매개변수(인자)로 받은 소수점자리수만큼 반올림하고 문자열로 반환.</li>
<li>소수점자리수가 넘칠때는 0을 넣어준다.</li>
</ul>
<h2 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h2><h2 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h2><ul>
<li>toString(‘정수로 진법을 나타낼수있음’)</li>
</ul>
<h2 id="Number-prototype-valueOf"><a href="#Number-prototype-valueOf" class="headerlink" title="Number.prototype.valueOf()"></a>Number.prototype.valueOf()</h2><ul>
<li>Number 객체의 값(기본자료형)을 반환한다.</li>
</ul>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><ul>
<li>정적 메소드</li>
</ul>
<h1 id="Math-Property"><a href="#Math-Property" class="headerlink" title="Math Property"></a>Math Property</h1><h2 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h2><h1 id="Math-Method"><a href="#Math-Method" class="headerlink" title="Math Method"></a>Math Method</h1><ul>
<li>Math.max()]0var max = Math.max.apply(null, arr); // 3</li>
<li>Math.in()]0var max = Math.max.apply(null, arr); // 3</li>
</ul>
<h1 id="정규-표현식"><a href="#정규-표현식" class="headerlink" title="정규 표현식"></a>정규 표현식</h1><p>RegExp 생성자 함수를 이용해서 정규표현식 객체가 생성된다. (var regex=~)</p>
<h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><ul>
<li>1개의 변수에 여러 개의 값을 <strong>순차적</strong>으로 저장할 때 사용한다.</li>
<li>배열은 프로퍼티 이름이 필요없고 값만 나열하면 된다.(객체와 비교)</li>
<li>배열 생성방식 두가지. 배열리터럴, 배열 생성자함수</li>
<li>배열 리터럴을 사용- var arr = []; (내부적으로는 array생성자 함수를 사용해서 객체가 생성된다.)</li>
</ul>
<p>array에서 length : 요소의갯수(index+1개)<br>순차적인 요소로 구성할 수 있는데<br>요소는 undefined 이외 모든 값이 들어올 수 있다.</p>
<h2 id="Array생성자-함수"><a href="#Array생성자-함수" class="headerlink" title="Array생성자 함수"></a>Array생성자 함수</h2><p>인자값을 매개변수 갯수 또는 요소로 받는다.<br>Array생성자함수는 코딩할때 사용하지 않을것.</p>
<p>for-in문<br>-for문을 사용하도록 한다.(속도차이)</p>
<h2 id="Array-프로퍼티"><a href="#Array-프로퍼티" class="headerlink" title="Array 프로퍼티"></a>Array 프로퍼티</h2><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><ul>
<li>배열의 길이</li>
</ul>
<h2 id="Array-Method"><a href="#Array-Method" class="headerlink" title="Array Method"></a>Array Method</h2><h3 id="Array-prototype-concat-item…"><a href="#Array-prototype-concat-item…" class="headerlink" title="Array.prototype.concat(item…)"></a>Array.prototype.concat(item…)</h3><ul>
<li>concat 할때 배열이 아니라 요소로 추가한다.</li>
</ul>
<h3 id="Array-prototype-pop"><a href="#Array-prototype-pop" class="headerlink" title="Array.prototype.pop()"></a>Array.prototype.pop()</h3><ul>
<li>pop : 대상 요소를 꺼낸다.</li>
<li>push: 새로운 요소를 뒤에 추가.</li>
<li>unshift : 새로운 요소를 앞에 추가.</li>
<li>pop과 push는 원본 배열을 변경한다.</li>
<li>빼낸 요소가 return 된다.</li>
<li>한두번 추가할땐 arr.push(6);(가독성높음, 퍼포먼스가 떨어짐) </li>
<li>여러번 추가할땐 arr[arr.length]=6; 사용. 속도면에서 차이가 있음.</li>
<li>arr.unshift(0); [0].concat(arr); 도 마찬가지로 속도차이가 있음.</li>
<li>*웹어플리케이션에서는 사용자가 화면 전환 시간을 오래 기다리지 않는다.</li>
</ul>
<h3 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse()"></a>Array.prototype.reverse()</h3><ul>
<li>원본 배열이 변경</li>
</ul>
<h3 id="Array-prototype-slice-start-end"><a href="#Array-prototype-slice-start-end" class="headerlink" title="Array.prototype.slice(start, end)"></a>Array.prototype.slice(start, end)</h3><ul>
<li>var res5 = items.slice(); slice() 복사본생성<em>*</em></li>
</ul>
<h3 id="Array-prototype-splice"><a href="#Array-prototype-splice" class="headerlink" title="Array.prototype.splice"></a>Array.prototype.splice</h3><ul>
<li>delete 비교</li>
<li>요소를 제거한 후, 새로운 요소를 추가</li>
<li>Array.prototype.splice.apply</li>
<li>ES6 Spread연산자?<br>[참고] this window -&gt; 메소드 내부,생성자함수 제외</li>
</ul>
<h3 id="중요한-메소드들"><a href="#중요한-메소드들" class="headerlink" title="중요한 메소드들"></a>중요한 메소드들</h3><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h3><ul>
<li>대상 배열을 알아서 순회한다. 내부에서 for문을 돌린다.</li>
<li>각각의 배열안의 요소에 대해서 콜백 함수를 실행시켜 준다.</li>
<li>매개변수는 필요하면 적어준다.</li>
<li>(item, index, array) -&gt; 원본배열의 요소(인자값이 알아서 순서대로 들어온다), index, 원본배열(자신)</li>
<li>for문을 간편화하기 위해 만들어짐</li>
<li>break문을 사용할 수 없다.</li>
<li>콜백함수의 this는 window, var that = this; 를 이용해서 this 참조 변경 / 또는 두번째 인자값에 this 전달</li>
</ul>
<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h3><ul>
<li>원본 배열과 매핑되는 새로운 배열을 만들어서 반환한다.</li>
<li>return 하지 않으면 새로운 배열에 반영되지 않는다. return 필수.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Built-in Object, Number, Math, Array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[빌트인객체-1]]></title>
      <url>/2017/10/10/TIL-1010/</url>
      <content type="html"><![CDATA[<h1 id="Built-in-Object"><a href="#Built-in-Object" class="headerlink" title="Built-in Object"></a>Built-in Object</h1><h2 id="Host-Object"><a href="#Host-Object" class="headerlink" title="Host Object"></a>Host Object</h2><ul>
<li>개발자가 직접 만든 객체</li>
</ul>
<h2 id="표준-빌트인-객체-Global-Objects"><a href="#표준-빌트인-객체-Global-Objects" class="headerlink" title="표준 빌트인 객체 (= Global Objects)"></a>표준 빌트인 객체 (= Global Objects)</h2><ul>
<li>공통적으로 필요한 기능을 제공한다.</li>
<li>Stinrg,Array,Object,Function,Boolean,Number,Math,Date,RegExp, 등등 대문자로 시작.</li>
<li>표준 빌트인 객체들은 생성자 함수이다.</li>
</ul>
<h2 id="표준-빌트인-객체의-프로퍼티-예"><a href="#표준-빌트인-객체의-프로퍼티-예" class="headerlink" title="표준 빌트인 객체의 프로퍼티(예)"></a>표준 빌트인 객체의 프로퍼티(예)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.length; <span class="comment">//(문자-&gt;객체) length는 String의 프로퍼티.</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="전역-객체"><a href="#전역-객체" class="headerlink" title="전역 객체"></a>전역 객체</h2><ul>
<li>전역 객체의 자식 객체를 사용할 때, window 생략이 가능하다. 예) window.alert(); -&gt; alert();</li>
<li>전역변수를 프로퍼티로 가진다.</li>
<li>참고 : 프로퍼티, 메서드를 계속 전역으로 선언하면 window 객체 영역이 커진다. (전역 변수를 사용할 때는 즉시 호출 함수(IIFE)를 사용하도록 한다.)</li>
</ul>
<h2 id="전역-프로퍼티-window-프로퍼티"><a href="#전역-프로퍼티-window-프로퍼티" class="headerlink" title="전역 프로퍼티(window.프로퍼티)"></a>전역 프로퍼티(window.프로퍼티)</h2><ul>
<li>Infinity (Number.Infinity) : 양/음의 무한대를 나타내는 숫자값</li>
<li>NaN (Number.NaN) : 숫자가 아님을 나타내는 숫자값 </li>
<li>undefined : 기본자료형 undefined를 값으로 갖는다.</li>
</ul>
<h2 id="전역-함수"><a href="#전역-함수" class="headerlink" title="전역 함수"></a>전역 함수</h2><ul>
<li>eval()</li>
<li>isFinite() : 숫자로 변환하여 유한수인지를 판단한 후, 결과값을 Boolean으로 나타낸다.</li>
<li>isNaN() : NaN인지를 검사하여 Boolean으로 반환한다.(숫자면 false)</li>
<li>parseFloat() : 부동소수점 숫자로 변환하여 반환한다.</li>
<li>parseInt() : 정수형 숫자로 변환하여 반환한다.</li>
</ul>
<h2 id="URI-형식"><a href="#URI-형식" class="headerlink" title="URI 형식"></a>URI 형식</h2><ul>
<li>http, host(도메인), port 넘버, Path, Query(256개 가능), Pragment로 구성된다.</li>
</ul>
<h2 id="encodeURI-decodeURI"><a href="#encodeURI-decodeURI" class="headerlink" title="encodeURI() / decodeURI()"></a>encodeURI() / decodeURI()</h2><ul>
<li>encodeURI() : URI의 문자들을 이스케이프 처리한다.</li>
<li>decodeURI() : 이스케이프 처리된 문자를 다시 반환한다.</li>
</ul>
<h3 id="이스케이프"><a href="#이스케이프" class="headerlink" title="이스케이프"></a>이스케이프</h3><ul>
<li>어떤 시스템에서도 읽을 수 있는 ASCII Character-set로 변환하는 것.</li>
<li>특수문자/공백/한글일 경우, 정규표현식으로 이스케이프 처리된다.</li>
</ul>
<h2 id="encodeURIComponent-decodeURIComponent"><a href="#encodeURIComponent-decodeURIComponent" class="headerlink" title="encodeURIComponent() / decodeURIComponent()"></a>encodeURIComponent() / decodeURIComponent()</h2><ul>
<li>Query 부분의 =, ?, &amp;를 인코딩한다.</li>
<li>encodeURI()와 차이점은 encodeURI()는 =, ?, &amp;을 인코딩하지 않는다.</li>
<li>알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( )는 이스케이프에서 제외된다.</li>
</ul>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>자바스크립트는 비동기 처리하므로 try-catch문으로 에러 처리를 하지 않는다.</p>
<h2 id="기본자료형과-래퍼객체"><a href="#기본자료형과-래퍼객체" class="headerlink" title="기본자료형과 래퍼객체"></a>기본자료형과 래퍼객체</h2><ul>
<li>모든 기본자료형은 래퍼객체를 가지고 있다.</li>
<li>예) ‘str’ -&gt; new String(‘str’)</li>
<li>기본자료형을 객체처럼 사용할 수 있게 한다. (객체화되면 메소드 또는 프로퍼티를 호출할 수 있다.-&gt; str.length/ str.toUpperCase();)</li>
<li>메소드를 호출하는 시점에만 객체화.</li>
<li>호출이 종료되면 기본자료형으로 돌아온다.</li>
</ul>
<h2 id="string를-위한-레퍼객체-String"><a href="#string를-위한-레퍼객체-String" class="headerlink" title="string를 위한 레퍼객체(String)"></a>string를 위한 레퍼객체(String)</h2><ul>
<li>기본자료형이 String(레퍼객체)의 메소드를 사용할수 있는 이유는 메소드나 프로퍼티를 호출할때 순간적으로 레퍼객체로 변환되어 프로토타입 객체를 상속받기 때문이다.</li>
</ul>
<h2 id="String-Constructor"><a href="#String-Constructor" class="headerlink" title="String Constructor"></a>String Constructor</h2><ul>
<li>String 객체는 String()생성자 함수로 생성됨.</li>
<li>전달되는 모든 인자는 문자열로 변환.</li>
<li>length 프로퍼티를 가지고 있으며, 유사객체배열로 사용할 수 있다.</li>
</ul>
<h2 id="String-Property"><a href="#String-Property" class="headerlink" title="String Property"></a>String Property</h2><ul>
<li>String은 원본(기본자료형)을 변경하지 않는다.</li>
</ul>
<h3 id="String-length"><a href="#String-length" class="headerlink" title="String.length"></a>String.length</h3><ul>
<li>문자열의 문자 갯수를 반환<h2 id="String-Method"><a href="#String-Method" class="headerlink" title="String Method"></a>String Method</h2><h3 id="String-prototype-charAt-프로토타입-붙어있는것-확인"><a href="#String-prototype-charAt-프로토타입-붙어있는것-확인" class="headerlink" title="String.prototype.charAt() [프로토타입 붙어있는것 확인]"></a>String.prototype.charAt() [프로토타입 붙어있는것 확인]</h3></li>
<li>index번호에 해당되는 위치의 문자 반환.</li>
<li>0부터 시작한다.<h3 id="String-prototype-indexOf"><a href="#String-prototype-indexOf" class="headerlink" title="String.prototype.indexOf()"></a>String.prototype.indexOf()</h3></li>
<li>문자또는 문자열을 검색해서 처음 찾은 곳의 index 반환.</li>
<li>못찾으면 -1 반환.<h3 id="String-prototype-lastIndexOf"><a href="#String-prototype-lastIndexOf" class="headerlink" title="String.prototype.lastIndexOf()"></a>String.prototype.lastIndexOf()</h3></li>
<li>자또는 문자열을 검색해서 마지막에 찾은 곳의 index 반환.</li>
<li>못찾으면 -1 반환.</li>
<li>참고로 인덱스의 값은 변하지 않음.<h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3></li>
<li>첫번째 인자의 문자열을 찾고 두번째 인자의 문자로 대처함.</li>
<li>원본 문자열은 변하지 않음.</li>
<li>첫번째 인자의 문자열이 검색된 문자열에 여러개 존재하면 첫번째만 바꿔줌.</li>
<li>/hello/gi &lt;-첫번째 인자를 이렇게 넣으면 전체검색하여 다바꿔줌.</li>
<li>정규표현식은 어려우니까 나중에 공부하자.<h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3></li>
<li>인자값에 넣은 문자열을 검색하여 그것을 토대로 문자를 분리후 배열로 반환[배열은 문자열로 들어감]</li>
<li>마찬가지로 원본은 변하지 않는다.<h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3></li>
<li>첫번째 인자에 전달된 인덱스값의 문자부터 두번째 인자의 인덱스 값-1까지의 문자를 반환.</li>
<li>두번째인수가 커야된다.<h3 id="String-prototype-toLowerCase"><a href="#String-prototype-toLowerCase" class="headerlink" title="String.prototype.toLowerCase()"></a>String.prototype.toLowerCase()</h3></li>
<li>모두 소문자로 바꿈.<h3 id="String-prototype-toUpperCase"><a href="#String-prototype-toUpperCase" class="headerlink" title="String.prototype.toUpperCase()"></a>String.prototype.toUpperCase()</h3></li>
<li>모두 대문자로 바꿈.<h3 id="3-9-String-prototype-trim"><a href="#3-9-String-prototype-trim" class="headerlink" title="3.9 String.prototype.trim()"></a>3.9 String.prototype.trim()</h3></li>
<li>문자열의 양끝 공백을 제거한 후 문자반환.</li>
<li>가운데 껴있는 공백은 제거안됨.</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date객체는 날짜와 시간을 위한 빌트인객체</p>
<ul>
<li>그러나 라이브러리로 대부분 사용.[알아만두자]</li>
<li>1000&lt;–밀리초단위로 1초이다.</li>
<li>1970년 1월 1일 00:00(UTC) 기점.</li>
<li>UTC / GMT 같다고 보면되지만 UTC라 부르고 사용하자.</li>
</ul>
<h3 id="Date-Constructor"><a href="#Date-Constructor" class="headerlink" title="Date Constructor"></a>Date Constructor</h3><ul>
<li>var d = new Date(‘2017/08/08/20:00:00’); 이 방법을 쓰자.</li>
<li>월은 0~11까지의 정수로 표현되므로 주의하자.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Built-in Object, String, Date </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[한 주간 배운 내용 Summary2]]></title>
      <url>/2017/10/02/TIL-1002/</url>
      <content type="html"><![CDATA[<h3 id="map-filter-reduce"><a href="#map-filter-reduce" class="headerlink" title="map, filter, reduce*"></a>map, filter, reduce<strong>*</strong></h3><ul>
<li>원본 배열이 변경되지 않는다.</li>
</ul>
<h3 id="Array-prototype-some"><a href="#Array-prototype-some" class="headerlink" title="Array.prototype.some()"></a>Array.prototype.some()</h3><p>= 조건에 부합하는게 하나라도 있으면 참</p>
<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><ul>
<li>기본자료형 number를 위한 wrapper 객체</li>
<li>기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문에 기본자료형이 wrapper 객체 메소드를 사용할 수 있다.</li>
</ul>
<a id="more"></a>
<h1 id="Number-Constructor"><a href="#Number-Constructor" class="headerlink" title="Number Constructor"></a>Number Constructor</h1><ul>
<li>new Number(value)</li>
<li>숫자로 변환할 수 없다면 NaN을 반환한다.</li>
<li>기본자료형 숫자 반환 방식은 Number(Value)</li>
<li>new Number와 Number 형 비교<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x == y);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// false (타입이 다르다)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Number-Property"><a href="#Number-Property" class="headerlink" title="Number Property"></a>Number Property</h1><h2 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h2><ul>
<li>자바스크립트에서 사용 가능한 가장 큰 숫자이다.</li>
<li>MAX_VAULE보다 큰 숫자는 Infinity 이다.</li>
</ul>
<h2 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h2><ul>
<li>0에 가장 가까운 양수값이다.</li>
<li>MIN_VALUE보다 작은 숫자는 0 이다.</li>
</ul>
<h2 id="Number-POSITIVE-INFINITY"><a href="#Number-POSITIVE-INFINITY" class="headerlink" title="Number.POSITIVE_INFINITY"></a>Number.POSITIVE_INFINITY</h2><ul>
<li>양의 무한대 Infinity를 반환한다.</li>
</ul>
<h2 id="Number-NEGATIVE-INFINITY"><a href="#Number-NEGATIVE-INFINITY" class="headerlink" title="Number.NEGATIVE_INFINITY"></a>Number.NEGATIVE_INFINITY</h2><ul>
<li>음의 무한대 -Infinity를 반환한다.</li>
</ul>
<h2 id="Number-NaN"><a href="#Number-NaN" class="headerlink" title="Number.NaN"></a>Number.NaN</h2><ul>
<li>숫자가 아님을 나타낸다.</li>
<li>window.NaN과 같다.</li>
</ul>
<h1 id="Number-Method"><a href="#Number-Method" class="headerlink" title="Number Method"></a>Number Method</h1><ul>
<li>숫자가 아닐 경우, 인수를 숫자로 변환하지 않고 false를 반환한다.</li>
</ul>
<h2 id="Number-isFinite-value"><a href="#Number-isFinite-value" class="headerlink" title="Number.isFinite(value)"></a>Number.isFinite(value)</h2><ul>
<li>매개변수 값이 정상적인 유한수인지를 검사하여 Boolean값을 반환한다.</li>
<li>전역 함수 isFinite(value)는 인수를 숫자로 변환하여 결과값을 반환한다.</li>
</ul>
<h2 id="Number-isInteger-value"><a href="#Number-isInteger-value" class="headerlink" title="Number.isInteger(value)"></a>Number.isInteger(value)</h2><ul>
<li>매개변수 값이 정수인지 검사하여 Boolean값으로 반환한다.</li>
</ul>
<h2 id="Number-isNaN-value"><a href="#Number-isNaN-value" class="headerlink" title="Number.isNaN(value)"></a>Number.isNaN(value)</h2><ul>
<li>매개변수 값이 NaN인지를 검사하여 Boolean값을 반환한다.</li>
<li>Not a Number 숫자가 아니면 true 반환한다.</li>
</ul>
<h2 id="Number-isSafeInteger"><a href="#Number-isSafeInteger" class="headerlink" title="Number.isSafeInteger()"></a>Number.isSafeInteger()</h2><ul>
<li>매개변수 값이 안전한 정수 값인지를 검사하여 Boolean값을 반환한다.</li>
<li>안전한 정수 값은 (253 - 1)와 -(253 - 1) 사이의 정수이다.</li>
</ul>
<h2 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h2><ul>
<li>지수 표기법으로 변환하여 문자열로 반환한다.</li>
<li>예를들어, 1.234e+3는 e(xponential)의 앞에 있는 숫자의 10의 3승을 나타낸다.</li>
<li>변수.toExponential(n); 반올림하여 소수 n번째 짜리까지 지수 표기법으로 반환한다.</li>
<li>인수는 0~20까지 입력할 수 있다.</li>
</ul>
<h2 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h2><ul>
<li>매개변수로 지정된 소수점 자리를 반올림하여 문자열로 반환한다.</li>
</ul>
<h2 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h2><ul>
<li>지정된 전체 자릿수까지 유효하도록 반올림하여 문자열로 반환한다. </li>
<li>지정된 전체 자릿수로 표현할 수 없을 경우 지수표기법으로 쓴다.</li>
</ul>
<h2 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h2><ul>
<li>숫자를 문자열로 변환하여 반환한다.</li>
<li>toString(n) n은 2~36값으로 진수를 나타낸다.</li>
</ul>
<hr>
<h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><ul>
<li>수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다.</li>
</ul>
<h1 id="Math-Property"><a href="#Math-Property" class="headerlink" title="Math Property"></a>Math Property</h1><h2 id="Math-PI"><a href="#Math-PI" class="headerlink" title="Math.PI"></a>Math.PI</h2><ul>
<li>PI값을 반환한다.</li>
</ul>
<h1 id="Math-Method"><a href="#Math-Method" class="headerlink" title="Math Method"></a>Math Method</h1><h2 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h2><ul>
<li>0 또는 양수인 절대값을 반환한다.</li>
<li>숫자가 아닐 경우 NaN을 반환한다.</li>
</ul>
<h2 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h2><ul>
<li>가장 인접한 정수로 올림/내림한다.</li>
<li>x = Math.round(-20.5); // -20</li>
<li>x = Math.round(-20.51); // -21</li>
</ul>
<h2 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h2><ul>
<li>양의 제곱근을 반환한다.</li>
</ul>
<h2 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h2><ul>
<li>지정된 숫자를 자신보다 크고, 가까운 정수로 올림한다.</li>
</ul>
<h2 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor()"></a>Math.floor()</h2><ul>
<li>지정된 숫자를 자기보다 작고, 가까운 정수로 내림한다.</li>
</ul>
<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><ul>
<li>0과 1 사이의 임의의 숫자를 반환한다.</li>
<li>(Math.random() * 10) + 1 : 1에서 10까지의 임의의 숫자를 반환한다.</li>
</ul>
<h2 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h2><ul>
<li>첫번째 인수를 밑, 두번째 인수를 지수로 하여 거듭제곱을 반환한다.</li>
<li>Math.pow(7,2); // 49</li>
</ul>
<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max()"></a>Math.max()</h2><ul>
<li>인수중에 가장 큰 수를 반환한다.</li>
<li>배열을 인자값으로 받을때는 apply를 사용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6에서 사용법</span></span><br><span class="line"><span class="keyword">var</span> max <span class="built_in">Math</span>.max(...arr);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Math-min"><a href="#Math-min" class="headerlink" title="Math.min()"></a>Math.min()</h2><ul>
<li>인수중에 가장 작은 수를 반환한다.</li>
</ul>
<hr>
<h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><ul>
<li>날짜와 시간(년,월,일,시,분,초)을 위한 빌트인 객체이다.</li>
<li>UTC(협정 세계시)는 GMT(그리니치 평균시)라고도 한다.</li>
<li>KST(Korea Standard Time)은 UTC보다 9시간이 빠르다.</li>
<li>현재의 날짜와 시간은 자바스크립트 코드가 동작한 시스템의 시계에 의해 결정된다.</li>
</ul>
<h1 id="Date의-Constructor"><a href="#Date의-Constructor" class="headerlink" title="Date의 Constructor"></a>Date의 Constructor</h1><ul>
<li>Date 생성자를 이용하여 날짜와 시간을 가지는 인스턴스를 생성한다. </li>
<li>기본적으로 현재 날짜와 시간을 나타내는 값을 가진다.</li>
<li>new Date()</li>
<li>new 연산자 없이 Date()를 사용하면 결과값을 객체가 아닌 문자열로 반환한다.</li>
</ul>
<h2 id="new-Date"><a href="#new-Date" class="headerlink" title="new Date()"></a>new Date()</h2><ul>
<li>매개변수가 없는 경우, 현재 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
</ul>
<h2 id="new-Date-milliseconds"><a href="#new-Date-milliseconds" class="headerlink" title="new Date(milliseconds)"></a>new Date(milliseconds)</h2><ul>
<li>1970년 1월 1일 00:00(UTC)을 기점으로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
</ul>
<h2 id="new-Date-dateString"><a href="#new-Date-dateString" class="headerlink" title="new Date(dateString)"></a>new Date(dateString)</h2><ul>
<li>지정된 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
<li>var d = new Date(‘May 12, 2016 12:13:00’);</li>
<li>var d = new Date(‘2017/08/08/20:00:00’);</li>
</ul>
<h2 id="new-Date-year-month-day-hour-minute-second-millisecond"><a href="#new-Date-year-month-day-hour-minute-second-millisecond" class="headerlink" title="new Date(year, month[, day, hour, minute, second, millisecond])"></a>new Date(year, month[, day, hour, minute, second, millisecond])</h2><ul>
<li>매개변수에 년,월,일,시,분,초,밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다.</li>
<li>year 1990년 이후의 년</li>
<li>month 월을 나타내는 0~11까지의 정수(1월은 0)</li>
</ul>
<h1 id="Date-Method"><a href="#Date-Method" class="headerlink" title="Date Method"></a>Date Method</h1><h2 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.</li>
</ul>
<h2 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.</li>
<li>var d = Date.parse(‘Jan 2, 1970 00:00:00 UTC’); // UTC</li>
<li>var d = Date.parse(‘Jan 2, 1970 09:00:00’); // KST</li>
<li>var d = Date.parse(‘1970/01/02/09:00:00’); // KST</li>
</ul>
<h2 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h2><ul>
<li>1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다.</li>
<li>var d = Date.UTC(1970, 0, 2);</li>
<li>var d = Date.UTC(‘1970/1/2’); //NaN 이 형식으로는 인식되지 않는다.</li>
</ul>
<h2 id="Date-prototype-getFullYear-getMonth-getDate-getDay-getHours-getMinutes-getSeconds-getMilliseconds-getTime"><a href="#Date-prototype-getFullYear-getMonth-getDate-getDay-getHours-getMinutes-getSeconds-getMilliseconds-getTime" class="headerlink" title="Date.prototype.getFullYear() / getMonth() / getDate() / getDay() / getHours() / getMinutes() / getSeconds() / getMilliseconds() / getTime()"></a>Date.prototype.getFullYear() / getMonth() / getDate() / getDay() / getHours() / getMinutes() / getSeconds() / getMilliseconds() / getTime()</h2><ul>
<li>해당 연도/월/일/요일을 나타내는 4자리 숫자를 반환한다.</li>
<li>getTime()은 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다.</li>
</ul>
<h2 id="Date-prototype-setFullYear-setMonth-setDate-setDay-setHours-setMinutes-setSeconds-setMilliseconds-setTime"><a href="#Date-prototype-setFullYear-setMonth-setDate-setDay-setHours-setMinutes-setSeconds-setMilliseconds-setTime" class="headerlink" title="Date.prototype.setFullYear() / setMonth() / setDate() / setDay() / setHours() / setMinutes() / setSeconds() / setMilliseconds() / setTime()"></a>Date.prototype.setFullYear() / setMonth() / setDate() / setDay() / setHours() / setMinutes() / setSeconds() / setMilliseconds() / setTime()</h2><ul>
<li>해당 연도/월/일/요일을 나타내는 4자리 숫자를 설정한다.</li>
<li>setFullYear() 연도 이외의 월,일을 설정할 수 있다.</li>
</ul>
<h2 id="Date-prototype-getTimezoneOffset"><a href="#Date-prototype-getTimezoneOffset" class="headerlink" title="Date.prototype.getTimezoneOffset()"></a>Date.prototype.getTimezoneOffset()</h2><ul>
<li>UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다.</li>
</ul>
<h2 id="Date-prototype-toDateString-Date-prototype-toTimeString"><a href="#Date-prototype-toDateString-Date-prototype-toTimeString" class="headerlink" title="Date.prototype.toDateString() / Date.prototype.toTimeString()"></a>Date.prototype.toDateString() / Date.prototype.toTimeString()</h2><ul>
<li>사람이 읽을 수 있는 형식의 문자열로 날짜 / 시간을 반환한다.</li>
<li>var d = new Date(‘1988/8/17/13:30’);</li>
<li>console.log(d.toDateString()); // Sat Sep 17 1988</li>
</ul>
<hr>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul>
<li>기본자료형 String을 위한 wrapper 객체이다.</li>
<li>기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하기 때문에 기본자료형이 wrppaer 객체 메소드를 사용할 수 있다.</li>
</ul>
<h1 id="String-Constructor"><a href="#String-Constructor" class="headerlink" title="String Constructor"></a>String Constructor</h1><ul>
<li>new String(value)</li>
<li>new 연산자를 사용하지 않고 String() 생성자 함수를 호출하면 String 객체가 아닌 문자열 리터럴을 반환한다.</li>
<li>new없이 String() 생성자 함수를 호출했을 때는 string 이 된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'Lee'</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Lee'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x == y);  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(x === y); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="String-Property"><a href="#String-Property" class="headerlink" title="String Property"></a>String Property</h1><h2 id="String-length"><a href="#String-length" class="headerlink" title="String.length"></a>String.length</h2><ul>
<li>문자열 내의 문자 갯수를 반환한다.</li>
</ul>
<h1 id="String-Method"><a href="#String-Method" class="headerlink" title="String Method"></a>String Method</h1><h2 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h2><ul>
<li>매개변수로 전달한 index 위치의 문자를 반환한다.</li>
</ul>
<h2 id="String-prototype-indexOf"><a href="#String-prototype-indexOf" class="headerlink" title="String.prototype.indexOf()"></a>String.prototype.indexOf()</h2><ul>
<li>매개변수로 전달된 문자나 문자열을 처음 발견한 곳의 index를 반환한다. </li>
<li>발견하지 못한 경우 -1을 반환한다.</li>
</ul>
<h2 id="String-prototype-lastIndexOf"><a href="#String-prototype-lastIndexOf" class="headerlink" title="String.prototype.lastIndexOf()"></a>String.prototype.lastIndexOf()</h2><ul>
<li>매개변수로 전달된 문자나 문자열을 마지막으로 발견된 곳의 index를 반환한다.</li>
<li><p>2번째 매개변수가 전달되면 해당 위치로 이동한 후, 역방향으로 검색을 시작하고 indexOf() 메소드 처럼 문자열을 처음 발견한 곳의 index를 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">'l'</span>, <span class="number">10</span>)); <span class="comment">// 9</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.replace()</span></span><br><span class="line"><span class="string">- 첫번째 인자의 값을 두번째 인자에 전달된 문자열로 대체한다.</span></span><br><span class="line"><span class="string">- 검색된 문자열이 복수로 존재할 경우, 첫번째 문자열만 대체된다.</span></span><br><span class="line"><span class="string">- 원본 문자열은 변경되지 않고 새로운 문자열을 반환한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.split()</span></span><br><span class="line"><span class="string">- 첫번째 인자의 문자열로 구분하여 분리된 각 문자열로 이루어진 배열을 반환한다.</span></span><br><span class="line"><span class="string">- 전달된 인수가 없는 경우, 문자열 전체를 단일 요소로 하는 배열을 반환한다.</span></span><br><span class="line"><span class="string">- 원본 문자열은 변경되지 않는다.</span></span><br><span class="line"><span class="string">- splitStr = str.split(' ', 3); // 공백으로 구분하여 배열로 반환, 3개까지만 허용</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.substring()</span></span><br><span class="line"><span class="string">- substring(시작index, 종료index-1)</span></span><br><span class="line"><span class="string">- 첫번째 인자의 index에 있는 문자부터 두번째 인자의 index에 있는 문자의 바로 이전 문자까지를 반환한다.</span></span><br><span class="line"><span class="string">- 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다.</span></span><br><span class="line"><span class="string">- 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.</span></span><br><span class="line"><span class="string">- 인수 &lt; 0 또는 NaN인 경우 : 0으로 취급된다.</span></span><br><span class="line"><span class="string">- 인수 &gt; 문자열의 길이(str.length) : 인수는 문자열의 길이(str.length)으로 취급된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.substr()</span></span><br><span class="line"><span class="string">- substr(시작index, 길이)</span></span><br><span class="line"><span class="string">- var str = 'Hello'; var res = str.substr(3,2); // lo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.toLowerCase()</span></span><br><span class="line"><span class="string">- 문자열의 문자를 모두 소문자로 변경한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.toUpperCase()</span></span><br><span class="line"><span class="string">- 문자열의 문자를 모두 대문자로 변경한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## String.prototype.trim()</span></span><br><span class="line"><span class="string">- 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다.</span></span><br><span class="line"><span class="string">- 문자 사이의 공백은 제거하지 못한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 실행 컨텍스트(Execution Context)</span></span><br><span class="line"><span class="string">- 실행 가능한 코드가 실행되는 환경이다.</span></span><br><span class="line"><span class="string">- 실행 가능한 코드 : 전역코드, Eval코드(안씀), 함수코드(호출)</span></span><br><span class="line"><span class="string">- 변수와 함수가 호출되기 위한 환경이 만들어진다.</span></span><br><span class="line"><span class="string">- 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 정보를 알고 있으며, 실행 컨텍스트를 물리적 객체의 형태로 관리한다.</span></span><br><span class="line"><span class="string">- 실행에 필요한 정보 : 변수(객체의 프로퍼티, 전역변수, 지역변수, 매개변수), 함수선언(함수명, 함수), 변수의 유효범위(전역이냐 지역이냐), this(가리키고 있는 객체)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 실행 컨텍스트 스택(=콜 스택)</span></span><br><span class="line"><span class="string">- 실행 컨텍스트가 생성되서 쌓이는 영역</span></span><br><span class="line"><span class="string">- 전역 실행 컨텍스트, 함수 실행 컨텍스트가 생성되면 실행 컨텍스트 스택에 쌓인다.</span></span><br><span class="line"><span class="string">- 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며, 함수가 끝나면 해당 함수의 실행 컨텍스트가 사라진다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 실행 컨텍스트 3가지 객체</span></span><br><span class="line"><span class="string">- Variable Object(VO), Scope Chain(SC), this value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. Variable Object</span></span><br><span class="line"><span class="string">- 변수(함수표현식 포함), 매개변수와 인수, 함수선언의 정보를 담는 객체로 유일하며 최상위에 위치한 객체이다.</span></span><br><span class="line"><span class="string">- 전역 컨텍스트의 VO는 전역객체(GO)를 가리키고, 함수 컨텍스트의 VO는 활성객체(AO)를 가리킨다.</span></span><br><span class="line"><span class="string">- 전역 객체(GO)는 전역에 선언된 전역 변수, 전역 함수를 프로퍼티로 소유한다.</span></span><br><span class="line"><span class="string">- 활성 객체(AO)는 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 arguments객체가 추가된다.</span></span><br><span class="line"><span class="string">- 전역 객체(Global Object)는 1개 생성, 활성객체(Activation Object)는 여러개 생성이 가능하다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. Scope Chain</span></span><br><span class="line"><span class="string">- 스코프 체인은 일종의 리스트로서 중첩된 함수의 레퍼런스를 저장하고 있다.</span></span><br><span class="line"><span class="string">- 마지막 리스트는 항상 전역 객체(GO)를 가리킨다.</span></span><br><span class="line"><span class="string">- 함수 실행 컨텍스트의 스코프 체인의 경우, 레퍼런스로 자기 자신의 AO와 GO를 가리킨다.</span></span><br><span class="line"><span class="string">- 스코프 체인(리스트)을 검색하면 함수가 중첩 상태일 때, 하위함수 내에서 상위함수의 유효 범위까지 참조할 수 있게 된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. this value</span></span><br><span class="line"><span class="string">- this의 값이 할당된다.</span></span><br><span class="line"><span class="string">- 함수 호출 패턴에 의해 결정된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 전역 코드에의 진입</span></span><br><span class="line"><span class="string">1. 전역 객체 생성</span></span><br><span class="line"><span class="string">- 컨트롤이 실행 컨텍스트에 접근하기 이전에 유일한 전역 객체(Global Object)가 생성된다.</span></span><br><span class="line"><span class="string">- 전역 객체에는 빌트인 객체와 BOM, DOM이 설정되어 있다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 실행 컨텍스트 생성 후 스택</span></span><br><span class="line"><span class="string">- 전역 코드로 컨트롤이 진입하면 실행 컨텍스트가 생성된 후, 실행 컨텍스트 스택에 쌓인다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 스코프 체인(SC)의 생성과 초기화</span></span><br><span class="line"><span class="string">- 전역 객체의 레퍼런스를 포함하는 리스트가 된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. Variable Instantiation(변수 객체화) 실행</span></span><br><span class="line"><span class="string">- Variable Instantiation은 VO에 프로퍼티와 값을 추가하는 것이다.</span></span><br><span class="line"><span class="string">- 변수, 매개변수, 인수정보(arguments), 함수선언을 VO에 추가하여 객체화한다.</span></span><br><span class="line"><span class="string">- 함수부터 변수 순으로 저장된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4-1. "변수 객체화의 순서"</span></span><br><span class="line"><span class="string">- 1. Function일 경우 매개변수(parameter)가 VO의 프로퍼티로, 인수(arguments)가 값으로 설정된다.</span></span><br><span class="line"><span class="string">- 2. 함수선언(함수표현식 제외)을 대상으로 함수명이 VO(VO가 가리키고 있는 객체)프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)</span></span><br><span class="line"><span class="string">- 3. 변수 선언을 대상으로 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5. 함수의 선언 처리(함수가 있다면)</span></span><br><span class="line"><span class="string">- 변수 객체화의 순서 2번처럼 함수명이 프로퍼티로, 생성된 함숫 객체(몸체)가 값으로 설정된다.(전역 함수일 경우 GO에 설정)</span></span><br><span class="line"><span class="string">- 생성된 함수 객체는 [[Scope]] 프로퍼티를 가지게 된다.</span></span><br><span class="line"><span class="string">- (함수 호출 실행 이전)[[Scope]]는 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정하고, (함수 실행 후)스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 함수선언식 이전에 함수를 호출할 수 있다. (함수 호이스팅)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6. 변수의 선언 처리(변수가 있을때)</span></span><br><span class="line"><span class="string">- 변수 객체화의 순서 3번처럼 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.</span></span><br><span class="line"><span class="string">- var 키워드로 선언된 변수는 선언과 초기화 단계가 한번에 이루어진다.</span></span><br><span class="line"><span class="string">- 변수 선언문 이전에 접근해도 VO에 변수가 undefined로 초기화된 상태로 존재하기 때문에 에러가 나지 않는다.(변수 호이스팅)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7. this value의 결정</span></span><br><span class="line"><span class="string">- this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 전역 코드의 실행</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 변수값 할당</span></span><br><span class="line"><span class="string">- 변수값을 할당할 때는 VO(VO가 가리키고 있는 객체, 전역의 경우 GO)를 선두(0)부터 검색하여 해당 변수의 프로퍼티를 발견하면 값을 할당 한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 함수 실행</span></span><br><span class="line"><span class="string">- 함수가 실행되면 새로운 함수 실행 컨텍스트가 생성된다.</span></span><br><span class="line"><span class="string">- 해당 함수로 실행 컨텍스트의 컨트롤이 이동하면 전역 코드와 마찬가지로  1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 실행된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 함수 코드에의 진입</span></span><br><span class="line"><span class="string">- 전역 코드에의 진입과 순서는 같지만 다른 룰이 적용된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 스코프 체인의 생성과 초기화</span></span><br><span class="line"><span class="string">- Activation Object생성**</span></span><br><span class="line"><span class="string">- AO에 대한 레퍼런스를 스코프 체인의 선두에 설정한다.</span></span><br><span class="line"><span class="string">- Activation Object는 arguments 프로퍼티를 초기화한다.</span></span><br><span class="line"><span class="string">- 스코프 체인의 마지막 레퍼런스 객체는 전역 객체를 참조한다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. Variable Instantiation 실행</span></span><br><span class="line"><span class="string">- 함수 객체와 변수를 VO에 바인딩한다.(선언, 초기화)</span></span><br><span class="line"><span class="string">- 변수의 프로퍼티는 변수명, 값은 undefined로 VO에 저장한다.</span></span><br><span class="line"><span class="string">- 함수의 프로퍼티는 함수명, 값은 Function Object로 VO에 저장한다.</span></span><br><span class="line"><span class="string">- Function Object의 [[scope]] 프로퍼티가 생성된다. </span></span><br><span class="line"><span class="string">- [[scope]] 프로퍼티는 AO와 전역을 참조하는 리스트의 값을 갖는다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. this value 결정</span></span><br><span class="line"><span class="string">- this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 함수 코드의 실행(함수에 변수가 존재할때)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. 변수 값의 할당</span></span><br><span class="line"><span class="string">- 지역변수를 할당할 때(현재는 내부함수일 경우), 스코프 체인이 참조하고 있는 VO를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값을 할당한다. (해당 영역에도 없으면 스코프 체인 리스트를 참조하여 GO를 검색하도록 한다.)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 내부 함수 코드의 실행</span></span><br><span class="line"><span class="string">- 내부 함수가 실행되기 시작하면 새로운 실행 컨텍스트가 생성된다.</span></span><br><span class="line"><span class="string">- 여기서도  1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 진행된다.</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string"># 클로저(closure)</span></span><br><span class="line"><span class="string">- 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다.</span></span><br><span class="line"><span class="string">- 외부함수가 내부함수보다 더 오래 유지되는 경우에 내부함수가 외부함수의 지역변수에 접근할 수 있고 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해 소멸하게 되는 특성을 말한다.</span></span><br><span class="line"><span class="string">- 클로저에 의해 참조되는 외부함수의 변수를 자유변수(Free variable)이라고 부른다.</span></span><br><span class="line"><span class="string">- (실행 컨텍스트 관점에서)내부함수가 유효한 경우에 외부함수가 종료 되면 함수의 실행 컨텍스트도 소멸하지만, 함수 실행 컨텍스트의 AO는 유효하기 때문에 내부함수가 스코프 체인을 통해 참조할 수 있다. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 클로저의 활용</span></span><br><span class="line"><span class="string">- 성능적인 면과 자원적인 면에서 손해를 볼 수 있다.</span></span><br><span class="line"><span class="string">- (실행 컨텍스트에서) 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당되어 있기 때문에 성능 상 좋다고 할 수 없다.(최소화하며 오남용하지 않아야 한다.)</span></span><br></pre></td></tr></table></figure>
<button type="button" onclick="myFunction()">Count!</button>

<p id="demo">0</p>

<p><script><br>  var add = (function () {</p>
<pre><code>var counter = 0;
return function () {
  return ++counter;
};
</code></pre><p>  }());</p>
<p>  function myFunction() {</p>
<pre><code>document.getElementById(&apos;demo&apos;).innerHTML = add();
</code></pre><p>  }<br></script><br>```</p>
</li>
<li>전역 변수의 사용 억제를 위한 방식</li>
<li>즉시 실행함수는 한번만 실행되므로 counter가 다시 초기화되지 않는다.</li>
<li>외부함수의 변수 counter는 참조하는 함수(내부함수)가 소멸될때까지 유지된다.</li>
<li>counter는 외부에서 접근할 수 없는 private 변수이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[한 주간 배운 내용 Summary]]></title>
      <url>/2017/10/01/TIL-1001/</url>
      <content type="html"><![CDATA[<h2 id="한-주간-배운-내용-정리"><a href="#한-주간-배운-내용-정리" class="headerlink" title="한 주간 배운 내용 정리"></a>한 주간 배운 내용 정리</h2><h1 id="자료형-Data-Type"><a href="#자료형-Data-Type" class="headerlink" title="자료형(Data Type)"></a>자료형(Data Type)</h1><h2 id="기본자료형"><a href="#기본자료형" class="headerlink" title="기본자료형"></a>기본자료형</h2><ul>
<li>boolean</li>
<li>null</li>
<li>undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
<h3 id="기본자료형-null-설계상의-문제"><a href="#기본자료형-null-설계상의-문제" class="headerlink" title="기본자료형 null 설계상의 문제"></a>기본자료형 null 설계상의 문제</h3><ul>
<li>var name = null; console.log(typeof.name); -&gt; object</li>
<li>typeof 연사자로 null값을 가진 변수를 연산해보면 object가 나온다.</li>
<li>따라서 null타입 변수인지 확인할 때는 일치연산자(===)를 사용해야 한다.</li>
</ul>
<a id="more"></a>
<h2 id="기본자료형-특징"><a href="#기본자료형-특징" class="headerlink" title="기본자료형 특징"></a>기본자료형 특징</h2><ul>
<li>변경 불가능한 값(immutable value)</li>
<li>pass-by-value</li>
</ul>
<h2 id="객체형"><a href="#객체형" class="headerlink" title="객체형"></a>객체형</h2><ul>
<li>object</li>
</ul>
<h2 id="객체형-특징"><a href="#객체형-특징" class="headerlink" title="객체형 특징"></a>객체형 특징</h2><ul>
<li>기본자료형을 제외한 모든 것</li>
<li>이름과 값을 가지는 데이터를 의미하는 프로퍼티</li>
<li>동작을 의미하는 메소드</li>
<li>pass-by-reference</li>
</ul>
<h1 id="변수-Variable"><a href="#변수-Variable" class="headerlink" title="변수(Variable)"></a>변수(Variable)</h1><ul>
<li>변수는 위치(메모리 상의 주소)를 기억하는 저장소이다.</li>
<li>값을 할당하고 참조하기 위해 사용된다.</li>
</ul>
<h2 id="변수명"><a href="#변수명" class="headerlink" title="변수명"></a>변수명</h2><ul>
<li>식별자(identifier)로도 불린다.</li>
<li>영문자, underscore(_), 달러기호($)로 시작해야 한다.</li>
<li>숫자는 이어지는 문자에 사용할 수 있다.</li>
<li>대소문자를 구별한다.</li>
</ul>
<h2 id="변수의-특징"><a href="#변수의-특징" class="headerlink" title="변수의 특징"></a>변수의 특징</h2><ul>
<li>선언만 된 변수는 undefined로 초기 값을 갖게 된다.</li>
<li>미선언 변수에 접근하면 ReferenceError 예외가 발생한다.</li>
<li>중복 선언이 가능하다.</li>
<li>변수 선언 시 var 키워드 생략이 가능하다.(=전역변수)</li>
<li>동적 타이핑 (Dynamic Typing) : 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자료형이 결정된다는 것</li>
<li>변수 호이스팅</li>
</ul>
<h2 id="var-키워드로-선언된-변수의-문제점-설계상의-오류"><a href="#var-키워드로-선언된-변수의-문제점-설계상의-오류" class="headerlink" title="var 키워드로 선언된 변수의 문제점(설계상의 오류)"></a>var 키워드로 선언된 변수의 문제점(설계상의 오류)</h2><ul>
<li><ol>
<li>function-level scope :<br>for loop 초기화 식에서 선언한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.</li>
</ol>
</li>
<li><ol>
<li>var 키워드 생략 허용 :<br>의도하지 않은 변수 전역화</li>
</ol>
</li>
<li><ol>
<li>중복 선언 허용 : 의도하지 않은 변수값 변경</li>
</ol>
</li>
<li><ol>
<li>변수 호이스팅 : 변수를 선언하기 전에 참조가 가능하다.</li>
</ol>
</li>
</ul>
<h2 id="변수-호이스팅이란"><a href="#변수-호이스팅이란" class="headerlink" title="변수 호이스팅이란"></a>변수 호이스팅이란</h2><p>var 선언문이나 function 선언문을 해당 scope의 선두로 옮기는 것을 말한다.</p>
<h3 id="변수-호이스팅-과정-변수-생성-3단계"><a href="#변수-호이스팅-과정-변수-생성-3단계" class="headerlink" title="변수 호이스팅 과정 (변수 생성 3단계)"></a>변수 호이스팅 과정 (변수 생성 3단계)</h3><ol>
<li>var 키워드로 선언된 변수는 선언 단계(Variable Object에 등록, 스코프가 VO참조)와 초기화 단계(메모리할당, undefined)가 이루어진다.</li>
<li>변수 선언문 이전에 변수에 접근하면 undefined가 반환된다. =&gt; 변수 호이스팅</li>
<li>변수 할당문에 도달하면 할당 단계가 이루어진다.</li>
</ol>
<hr>
<h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><ul>
<li>함수를 정의하는 방법 3가지. </li>
<li>함수선언식</li>
<li>함수표현식</li>
<li>Function() 생성자 함수</li>
</ul>
<h2 id="함수선언식"><a href="#함수선언식" class="headerlink" title="함수선언식"></a>함수선언식</h2><ul>
<li>function 키워드 </li>
<li>function 함수명(매개변수){return 결과값;}</li>
<li>자바스크립트 엔진에 의해 함수표현식으로 형태가 변경되어, 함수참조값을 가진 변수명과 함수명이 일치하여 함수명으로 호출할 수 있다. (실제로는 아래처럼 <strong>기명 함수표현식</strong>으로 변경되어 변수명으로 호출한 것)</li>
<li>var foo = function foo(매개변수){return 결과값;}</li>
<li>결국 함수선언식도 함수 리터럴 방식으로 정의된다.</li>
</ul>
<h2 id="함수표현식"><a href="#함수표현식" class="headerlink" title="함수표현식"></a>함수표현식</h2><ul>
<li>리터럴 방식으로 함수를 정의, 변수에 할당한 방식(<strong>일급객체</strong>)을 함수 표현식이라 한다.</li>
<li>함수가 변수에 할당되면, 이 변수는 할당된 함수를 가리키는 참조값을 가지게 되며 함수 호출시 이 변수가 함수명처럼 사용된다.</li>
<li>함수표현식은 일반적으로 함수명을 생략하여 익명함수(무명함수표현식)로 사용한다.</li>
<li>var reply = function(a,b){return 결과값;}</li>
<li>console.log(reply(5,10)); // 함수호출<h3 id="일급객체"><a href="#일급객체" class="headerlink" title="일급객체"></a>일급객체</h3></li>
</ul>
<ol>
<li>무명의 리터럴로 표현이 가능하다.</li>
<li>변수나 자료구조에 저장할 수 있다.</li>
<li>함수의 파라미터로 전달할 수 있다.</li>
<li>반환값으로 사용할 수 있다.</li>
</ol>
<h2 id="Function-생성자-함수"><a href="#Function-생성자-함수" class="headerlink" title="Function() 생성자 함수"></a>Function() 생성자 함수</h2><ul>
<li>Function() 생성자 함수는 function.prototype.constructor 프로퍼티로 접근할 수 있다.</li>
<li>var foo = new function (‘a’, ‘return a’);</li>
<li>console.log(foo(100)); //100</li>
<li>foo()는 생성자를 통해 만들었기 때문에 객체이다.</li>
<li>함수는 function()이라는 기본 내장 생성자 함수로 생성된 객체이다.</li>
<li>리터럴 방식도 내부적으로는 function() 생성자 함수로 생성된다.</li>
<li>정의방식은 달라도 결국 function() 생성자 함수를 통해 함수가 생성된다.</li>
</ul>
<h2 id="함수선언식과-함수호이스팅"><a href="#함수선언식과-함수호이스팅" class="headerlink" title="함수선언식과 함수호이스팅"></a>함수선언식과 함수호이스팅</h2><ul>
<li>함수호이스팅은 코드를 실행하기전에 function 선언문을 해당 scope의 맨 위로 옮기는 것이다.</li>
<li>함수 선언 위치와는 상관없이 코드 내 어느곳에서든지 호출이 가능하다.</li>
<li>함수선언식은 함수 선언, 초기화, 할당이 한번에 이루어진다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foo()함수를 상단으로 호이스팅 시켜주기 때문에 에러발생 안함.</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello javascript"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="함수표현식과-변수호이스팅"><a href="#함수표현식과-변수호이스팅" class="headerlink" title="함수표현식과 변수호이스팅"></a>함수표현식과 변수호이스팅</h2><ul>
<li>변수호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다.</li>
<li>호이스팅된 변수는 undefined로 초기화되고 실제값의 할당은 할당문에서 이루어진다. =&gt; 상단에서 함수호출시 TypeError 발생<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var foo; 변수 생성</span></span><br><span class="line"><span class="comment">//foo = undefined; 변수 초기화</span></span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//여기서 함수 호출시 할당이 이루어지지 않았기 때문에 foo()는 TypeError를 발생시킨다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello javascript"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="함수-객체의-프로퍼티"><a href="#함수-객체의-프로퍼티" class="headerlink" title="함수 객체의 프로퍼티"></a>함수 객체의 프로퍼티</h2><ul>
<li>함수는 객체이므로 함수도 프로퍼티를 가질 수 있다.</li>
<li>함수 객체의 속성 : arguments, caller, length, name, prototype, [[prototype]]</li>
</ul>
<h3 id="arguments-프로퍼티"><a href="#arguments-프로퍼티" class="headerlink" title="arguments 프로퍼티"></a>arguments 프로퍼티</h3><ul>
<li>함수 호출시 전달된 인수들의 정보를 담고 있는 순회가능한 유사 배열 객체(length 프로퍼티를 가진 객체)이다.</li>
<li>매개변수의 갯수보다 인수를 적게 전달했을 때 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다.</li>
<li>매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다.</li>
<li>매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하다.</li>
<li>배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해야 한다.</li>
</ul>
<h3 id="caller-프로퍼티"><a href="#caller-프로퍼티" class="headerlink" title="caller 프로퍼티"></a>caller 프로퍼티</h3><ul>
<li>자신을 호출한 함수를 의미한다.</li>
</ul>
<h3 id="length-프로퍼티"><a href="#length-프로퍼티" class="headerlink" title="length 프로퍼티"></a>length 프로퍼티</h3><ul>
<li>함수 정의 시 작성된 매개변수 갯수를 의미한다.</li>
<li>function bar(a, b){ return a*b; } // bar.length: 2</li>
<li>arguments.length는 함수 호출시 호출된 인자의 갯수를 의미한다.</li>
</ul>
<h3 id="name-프로퍼티"><a href="#name-프로퍼티" class="headerlink" title="name 프로퍼티"></a>name 프로퍼티</h3><ul>
<li>함수명을 나타낸다.</li>
<li>기명함수일 때는 함수명을 값으로 갖고, 익명함수일 때는 빈문자열을 값으로 갖는다.</li>
</ul>
<h3 id="prototype-프로퍼티"><a href="#prototype-프로퍼티" class="headerlink" title="[[prototype]] 프로퍼티"></a>[[prototype]] 프로퍼티</h3><ul>
<li>모든 객체가 가지고 있는 프로퍼티이다.</li>
<li>객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며, 함수의 경우 Function.prototype을 가리킨다.</li>
</ul>
<h3 id="prototype-프로퍼티-1"><a href="#prototype-프로퍼티-1" class="headerlink" title="prototype 프로퍼티"></a>prototype 프로퍼티</h3><ul>
<li>함수 객체만 가지고 있는 프로퍼티이다.</li>
<li>함수객체가 생성자 함수로 사용되어 객체를 생성할 때, 생성된 객체의 부모 역할을 하는 객체를 가리킨다.</li>
<li>constructor 프로퍼티를 가지는 객체를 가리킨다. constructor 프로퍼티는 함수 객체 자신을 가리킨다.</li>
</ul>
<hr>
<h1 id="제어문-Control-Flow"><a href="#제어문-Control-Flow" class="headerlink" title="제어문(Control Flow)"></a>제어문(Control Flow)</h1><ul>
<li>조건에 따른 명령 실행(조건문)이나 반복 실행(반복문)이 필요할 때 사용된다.</li>
<li>조건문은 if문, switch문, 반복문은 for문, while문, do-while문 등이 있다.<h2 id="블록-구문-Block-Statement"><a href="#블록-구문-Block-Statement" class="headerlink" title="블록 구문(Block Statement)"></a>블록 구문(Block Statement)</h2></li>
<li>구문들의 집합, 중괄호로 그 범위를 정한다.</li>
<li>함수, 객체 리터럴, 흐름 제어 구문에서 사용된다.</li>
</ul>
<h2 id="평가"><a href="#평가" class="headerlink" title="평가"></a>평가</h2><ul>
<li>흐름제어를 위해서 논리적 참,거짓을 구별한 후 평과 결과에 따라 결정을 내린다.</li>
<li>이때 자바스크립트는 문맥을 고려하여 내부적으로 자료형을 암묵적으로 강제 형 변환할 수도 있다.</li>
</ul>
<h3 id="암묵적-형-변환"><a href="#암묵적-형-변환" class="headerlink" title="암묵적 형 변환"></a>암묵적 형 변환</h3><ul>
<li>자바스크립트 엔진이 필요에 의해 암시적으로 형을 자동으로 변환시키는 것이다.</li>
<li>문자와 숫자를 연산하는 것 자체가 불가능 하기에 형변환이 필요하다.</li>
</ul>
<h3 id="암묵적-형-변환-규칙"><a href="#암묵적-형-변환-규칙" class="headerlink" title="암묵적 형 변환 규칙"></a>암묵적 형 변환 규칙</h3><p>1) 숫자형 + 문자형 = 문자형<br>console.log(10 + ‘10’); // 1010</p>
<p>2) 숫자형 - 문자형 = 숫자형<br>console.log(2 - ‘1’) // 1</p>
<p>3) 불린형 + 문자형 = 문자형<br>console.log(true + ‘10’); // true10</p>
<p>4) 불린형 + 숫자형 = 숫자형<br>console.log(true + 10); // 11</p>
<p>5) 그 외의 규칙</p>
<ul>
<li>console.log(‘1’ &gt; 0); // true</li>
<li>console.log(‘10’ == 10); // true</li>
<li>console.log(‘10’ === 10); // false</li>
<li>console.log(undefined == null); // true</li>
<li>console.log(undefined === null); // false</li>
</ul>
<h2 id="명시적-형-변환"><a href="#명시적-형-변환" class="headerlink" title="명시적 형 변환"></a>명시적 형 변환</h2><ul>
<li>개발자가 직접 어떤 형으로 변경할 지를 명시해 주는 것을 명시적 형 변환이라고 한다.</li>
</ul>
<h3 id="1-문자를-숫자로-타입-변환"><a href="#1-문자를-숫자로-타입-변환" class="headerlink" title="1. 문자를 숫자로 타입 변환"></a>1. 문자를 숫자로 타입 변환</h3><table>
<thead>
<tr>
<th>변환 방법</th>
<th>예제 </th>
</tr>
</thead>
<tbody>
<tr>
<td>“+” operator 붙이기(권장)</td>
<td>var val=’123’; val = +val;</td>
</tr>
<tr>
<td>“ * 1”</td>
<td>var val=’123’; val = val*1;</td>
</tr>
<tr>
<td>Number()</td>
<td>var val=’123’; Number(val);</td>
</tr>
<tr>
<td>parseInt()</td>
<td>var val=’123’; parseInt(val);</td>
</tr>
</tbody>
</table>
<h3 id="2-숫자를-문자로-타입-변환"><a href="#2-숫자를-문자로-타입-변환" class="headerlink" title="2. 숫자를 문자로 타입 변환"></a>2. 숫자를 문자로 타입 변환</h3><table>
<thead>
<tr>
<th>변환 방법</th>
<th>예제 </th>
</tr>
</thead>
<tbody>
<tr>
<td>‘&nbsp;&nbsp;’ 붙이기(권장)</td>
<td>var val=123; val = val + ‘&nbsp;&nbsp;’;</td>
</tr>
<tr>
<td>String()</td>
<td>var val=123; String(val);</td>
</tr>
<tr>
<td>toString()</td>
<td>var val=123; toString(val);</td>
</tr>
</tbody>
</table>
<h2 id="Falsy-values와-Truthy-values"><a href="#Falsy-values와-Truthy-values" class="headerlink" title="Falsy values와 Truthy values"></a>Falsy values와 Truthy values</h2><ul>
<li>Falsy values : Boolean context에서 false로 평가되는 값</li>
<li>false, undefined, null, 0, NaN(Not a Number), ‘&nbsp;’(빈문자열)</li>
<li>Truty values : Boolean context에서 true로 평가되는 값</li>
<li>Falsy values 이외의 값들(객체)은 모두 Truthy values이다.</li>
</ul>
<hr>
<h1 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체(Object)"></a>객체(Object)</h1><ul>
<li>자바스크립트는 객체 기반의 스크립트 언어이며, 자바스크립트를 이루고 있는 것은 모두 객체이다.</li>
<li>객체는 데이터와 그 데이터에 관련된 동작을 모두 포함할 수 있는 개념적 존재이다.(프로퍼티와 메소드를 포함하고 있는 독립적 주체이다.)</li>
</ul>
<h2 id="객체는-Pass-by-reference"><a href="#객체는-Pass-by-reference" class="headerlink" title="객체는 Pass-by-reference"></a>객체는 Pass-by-reference</h2><ul>
<li>객체는 변경가능한 프로퍼티들의 집합</li>
<li>변수는 객체 자체가 아닌 생성된 객체의 참조값을 저장한다.</li>
<li>즉, 동일한 객체를 참조할 경우, 객체의 참조값(주소)를 공유하게 된다.</li>
</ul>
<h2 id="기본자료형은-Pass-by-value"><a href="#기본자료형은-Pass-by-value" class="headerlink" title="기본자료형은 Pass-by-value"></a>기본자료형은 Pass-by-value</h2><ul>
<li>기본자료형 값이 한번 정해지면 변경될 수 없다.(Immutable, 변경불가성)</li>
<li>변수에 참조형으로 저장되는 것이 아니라 값 자체가 저장된다.</li>
<li>새로운 변수에 값을 가진 또 다른 변수가 대입될 경우, 값이 복사되어 새로운 변수에 저장된다.</li>
</ul>
<h2 id="프로퍼티란"><a href="#프로퍼티란" class="headerlink" title="프로퍼티란"></a>프로퍼티란</h2><ul>
<li>객체에 속한 데이터(Data)로 이름(name)과 값(value)의 쌍으로 구성된다.</li>
</ul>
<h2 id="메소드란"><a href="#메소드란" class="headerlink" title="메소드란"></a>메소드란</h2><ul>
<li>객체 내부에서 프로퍼티로 선언된 함수를 뜻한다.</li>
<li>함수와 동일하지만 객체 내에 만들어 진다는 점이 다르다.</li>
</ul>
<h1 id="객체-생성-방식"><a href="#객체-생성-방식" class="headerlink" title="객체 생성 방식"></a>객체 생성 방식</h1><ul>
<li>객체리터럴, Object()생성자 함수, 생성자 함수 3가지 방식이 있다.</li>
<li>자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다.</li>
</ul>
<ol>
<li>객체리터럴</li>
</ol>
<ul>
<li>중괄호 {}를 사용하여 객체를 생성한다.</li>
<li>{} 내에 프로퍼티 이름: 프로퍼티 값을 기술하면 해당 프로퍼티가 추가된 객체를 생성한다.</li>
</ul>
<ol>
<li>Object() 생성자 함수</li>
</ol>
<ul>
<li>new 연산자와 Object() 생성자 함수로 빈 객체를 생성한 후, 프로퍼티와 메소드를 추가하여 객체를 생성한다.</li>
</ul>
<ol>
<li>생성자 함수</li>
</ol>
<ul>
<li>생성자 함수는 대문자로 시작한다.</li>
<li>프로퍼티 또는 메소드 앞의 this는 생성자 함수로 생성될 인스턴스를 가리킨다. this에 연결되있는 프로퍼티와 메소드는 외부에서 참조 가능하다.(일반함수의 this는 전역객체에 바인딩된다.)</li>
<li>생성자 함수 내의 일반 변수는 private로 외부에서 참조 불가능하다.</li>
</ul>
<h3 id="생성자-함수와-일반-함수의-혼란을-방지하기-위한-패턴-Scope-Safe-Constructor"><a href="#생성자-함수와-일반-함수의-혼란을-방지하기-위한-패턴-Scope-Safe-Constructor" class="headerlink" title="생성자 함수와 일반 함수의 혼란을 방지하기 위한 패턴(Scope-Safe Constructor)"></a>생성자 함수와 일반 함수의 혼란을 방지하기 위한 패턴(Scope-Safe Constructor)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//this가 호출된 함수(arguments.callee)의 인스턴스가 아니면</span></span><br><span class="line">  <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">arguments</span>.callee))&#123;</span><br><span class="line">   <span class="comment">//생성자 함수를 호출하여 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">arguments</span>.callee(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.value = arg ? arg : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">var</span> b = A(<span class="number">10</span>); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">//object</span></span><br></pre></td></tr></table></figure>
<h2 id="객체-프로퍼티-접근"><a href="#객체-프로퍼티-접근" class="headerlink" title="객체 프로퍼티 접근"></a>객체 프로퍼티 접근</h2><h3 id="프로퍼티-이름"><a href="#프로퍼티-이름" class="headerlink" title="프로퍼티 이름"></a>프로퍼티 이름</h3><ol>
<li>프로퍼티는 문자열(빈 문자열 포함)과 숫자가 올 수 있다.</li>
<li>‘ - ‘가 들어간 이름은 유효한 이름이 아니기 때문에 ‘’(따옴표)를 사용해야 한다.(연산자가 있는 표현식으로 인식)</li>
<li>예약어는 사용하지 말아야 한다.</li>
</ol>
<h3 id="프로퍼티-값-읽기"><a href="#프로퍼티-값-읽기" class="headerlink" title="프로퍼티 값 읽기"></a>프로퍼티 값 읽기</h3><ol>
<li>유효한 이름일 경우, 마침표 표기법(.), 대괄호 표기법([‘&nbsp;’]) 모두 사용할 수 있다.</li>
<li>유효한 이름이 아니거나 예약어일 경우, 대괄호([‘&nbsp;’])로 읽어야 한다.</li>
<li>대괄호 내의 프로퍼티 이름은 꼭 문자열이어야(‘&nbsp;’) 한다.</li>
<li>객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다.</li>
</ol>
<h3 id="프로퍼티-값-갱신-동적-생성-삭제"><a href="#프로퍼티-값-갱신-동적-생성-삭제" class="headerlink" title="프로퍼티 값 갱신 / 동적 생성 / 삭제"></a>프로퍼티 값 갱신 / 동적 생성 / 삭제</h3><ol>
<li>객체가 소유한 프로퍼티 값에 새로운 값을 할당하면 프로퍼티 값이 갱신된다.</li>
<li>객체가 소유하지 않은 프로퍼티에 값을 할당하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다.</li>
<li>delete 연산자로 객체의 프로퍼티를 삭제할 수 있다.</li>
</ol>
<h2 id="객체의-분류-용어-정리"><a href="#객체의-분류-용어-정리" class="headerlink" title="객체의 분류(용어 정리)"></a>객체의 분류(용어 정리)</h2><h3 id="내장객체-Built-in-Object"><a href="#내장객체-Built-in-Object" class="headerlink" title="내장객체(Built-in Object)"></a>내장객체(Built-in Object)</h3><ul>
<li>웹페이지 등을 표현하기 위한 공통의 기능을 제공하며 웹페이지가 브라우저에 의해 로드되자마자 바로 사용이 가능하다.</li>
<li>내장객체에는 Standard Built-in Objects(표준 빌트인 객체)와 Native Object(BOM,DOM)가 있다.</li>
</ul>
<h3 id="표준-내장-객체-Standard-Built-in-Objects-or-Global-Objects"><a href="#표준-내장-객체-Standard-Built-in-Objects-or-Global-Objects" class="headerlink" title="표준 내장 객체 Standard Built-in Objects (or Global Objects)"></a>표준 내장 객체 Standard Built-in Objects (or Global Objects)</h3><ul>
<li>자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다.</li>
<li>Javascript는 프로그램 전체의 영역에서 공통적으로 필요한 기능을 개발자 각자가 일일히 작성하는 수고를 줄이기 위해 Standard Built-in Objects(표준 빌트인 객체)를 제공한다.</li>
<li>전역객체와는 다른 의미이며, 전역객체의 자식이다.</li>
<li>Object, Function, Array, String, Number, Math, Date 등이 있다.</li>
</ul>
<h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM(Browser Object Model)"></a>BOM(Browser Object Model)</h3><ul>
<li>브라우저 객체 모델은 현재 브라우저 창 또는 탭을 표현하는 객체이다.</li>
<li>최상위 객체는 window로 Standard Built-in Objects가 구성된 후에 객체가 구성된다.</li>
<li>웹 브라우저의 버튼, URL 주소 입력창, 타이틀 바, 윈도우 크기 등  을 제어할 수 있는 객체 모델이다.</li>
<li>자식 객체로는 window, location, navigator, history, screen, document 등이 있다.</li>
</ul>
<h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM(Document Object Model)"></a>DOM(Document Object Model)</h3><ul>
<li>HTML 문서에 대한 모델을 트리로 구성하고, 문서 내의 각 요소에 접근하여 수정할 수 있도록 프로퍼티와 메소드를 재공한다.</li>
<li>최상위 객체는 document 객체로 전체 문서를 표현한다.</li>
</ul>
<hr>
<h1 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h1><h2 id="비교연산자-와"><a href="#비교연산자-와" class="headerlink" title="비교연산자( != 와 !== )"></a>비교연산자( != 와 !== )</h2><table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>!=</td>
<td>부등비교, 값이 같지 않을 경우 true</td>
</tr>
<tr>
<td>!==</td>
<td>불일치 비교, 데이터 타입이 다르거나 값이 다를 경우 true</td>
</tr>
</tbody>
</table>
<h2 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h2><ul>
<li>Boolean값으로 평가하기 위해 참조하여야 할 곳까지 진행한 후, 평가를 중지하게된 계기가 된 값을 반환한다.</li>
</ul>
<table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>true ll anything</td>
<td>true</td>
</tr>
<tr>
<td>false ll anything</td>
<td>anything</td>
</tr>
<tr>
<td>true &amp;&amp; anything</td>
<td>anything</td>
</tr>
<tr>
<td>false &amp;&amp; anything</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="타입-연산자"><a href="#타입-연산자" class="headerlink" title="타입 연산자"></a>타입 연산자</h2><table>
<thead>
<tr>
<th>연산자</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>typeof</td>
<td>데이터타입을 문자열로 반환한다. null과 배열은 object, 함수는 function</td>
</tr>
<tr>
<td>instanceof</td>
<td>객체가 동일 객체 타입의 인스턴스이면 true를 반환한다.</td>
</tr>
</tbody>
</table>
<h2 id="피연산자를-불린-값으로-변환하는-역할"><a href="#피연산자를-불린-값으로-변환하는-역할" class="headerlink" title="!! - 피연산자를 불린 값으로 변환하는 역할"></a>!! - 피연산자를 불린 값으로 변환하는 역할</h2><ul>
<li>객체(배열 포함)의 경우, 빈객체라도 존재한다면 true로 변환된다.</li>
<li>!!를 제거한 불린 값과 동일하다.</li>
<li>console.log(!!{}); //true</li>
<li>console.log(!![]); //true</li>
<li>console.log(!!1); // true</li>
<li>console.log(!!null); // false</li>
</ul>
<hr>
<h1 id="프로토타입-Prototype"><a href="#프로토타입-Prototype" class="headerlink" title="프로토타입(Prototype)"></a>프로토타입(Prototype)</h1><ul>
<li>자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있고, 부모 객체를 프로토타입(prototype)이라고 한다. </li>
<li>마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있다.</li>
<li>Object.prototype 객체는 프로토타입 체인의 종점이다.</li>
</ul>
<h2 id="Prototype-프로퍼티"><a href="#Prototype-프로퍼티" class="headerlink" title="[[Prototype]] 프로퍼티"></a>[[Prototype]] 프로퍼티</h2><ul>
<li><strong>proto</strong>와 같은 개념이다.</li>
<li>함수를 포함한 모든 객체가 가지고 있는 프로퍼티이다.</li>
<li>객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리킨다.</li>
<li>함수 객체는 <code>function.prototype</code>을 가리킨다.</li>
</ul>
<h2 id="prototype-프로퍼티-2"><a href="#prototype-프로퍼티-2" class="headerlink" title="prototype 프로퍼티"></a>prototype 프로퍼티</h2><ul>
<li>함수 객체만 가지고 있는 프로퍼티이다.</li>
<li>함수 객체가 생성자로 사용될 때, 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다.</li>
</ul>
<h2 id="constructor-프로퍼티"><a href="#constructor-프로퍼티" class="headerlink" title="constructor 프로퍼티"></a>constructor 프로퍼티</h2><ul>
<li>프로토타입 객체를 생성했던 함수에 대한 참조를 나타낸다.</li>
<li>constructor가 함수 또는 생성자 객체를 가리키는 참조값이므로 아래처럼 constructor 속성으로 함수를 호출하거나 객체를 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySon = <span class="keyword">new</span> Person(<span class="string">'daniel'</span>);</span><br><span class="line"><span class="keyword">var</span> myGrandSon = <span class="keyword">new</span> mySon.constructor(<span class="string">'jessica'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="객체-생성-방식에-따른-프로토타입의-차이"><a href="#객체-생성-방식에-따른-프로토타입의-차이" class="headerlink" title="객체 생성 방식에 따른 프로토타입의 차이"></a>객체 생성 방식에 따른 프로토타입의 차이</h2><ol>
<li>생성자 함수 방식<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> choi = <span class="keyword">new</span> Person(<span class="string">'choi'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>choi 객체의 [[prototype]]은 Person.prototype 이다.</li>
</ul>
<ol>
<li>객체 리터럴 방식<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> choi = &#123;</span><br><span class="line">    name : <span class="string">'min'</span>,</span><br><span class="line">    gender: <span class="string">'female'</span>,</span><br><span class="line">    year : <span class="number">2017</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>choi 객체의 [[prototype]]은 Object.prototype 이다.</li>
</ul>
<ol>
<li>Object() 생성자 함수 방식</li>
</ol>
<ul>
<li>생성자 함수 정의를 하기위한 방식은 함수선언식, 함수표현식, function() 3가지 방식이 있다. 3가지 함수 정의 방식은 결국 Function() 생성자 함수를 통해 함수 객체를 생성한다. 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 prototype객체는 Function.prototype이다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 빈 객체의 생성</span></span><br><span class="line"><span class="keyword">var</span> choi = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">person.name = <span class="string">'Choi'</span>;</span><br><span class="line">person.gender = <span class="string">'female'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi! My name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>choi 객체의 [[prototype]]은 Object.prototype 이다.</li>
</ul>
<h3 id="3가지-방식에-따라-생성된-객체의-prototype객체-정리"><a href="#3가지-방식에-따라-생성된-객체의-prototype객체-정리" class="headerlink" title="3가지 방식에 따라 생성된 객체의 prototype객체 정리"></a>3가지 방식에 따라 생성된 객체의 prototype객체 정리</h3><table>
<thead>
<tr>
<th>객체 생성 방식</th>
<th>엔진의 객체 생성</th>
<th>인스턴스의 prototype 객체</th>
</tr>
</thead>
<tbody>
<tr>
<td>생성자함수</td>
<td>생성자함수</td>
<td>생성자 함수 이름.prototype</td>
</tr>
<tr>
<td>객체리터럴</td>
<td>object()생성자함수</td>
<td>Object.prototype</td>
</tr>
<tr>
<td>object() 생성자함수</td>
<td>object()생성자함수</td>
<td>Object.prototype</td>
</tr>
</tbody>
</table>
<ul>
<li>객체리터럴, 생성자 함수는 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다. </li>
<li>Object() 생성자 함수는 함수 객체이기 때문에 일반 객체와 다르게 prototype 프로퍼티가 있다.</li>
</ul>
<h2 id="프로토타입-체인-Prototype-chain"><a href="#프로토타입-체인-Prototype-chain" class="headerlink" title="프로토타입 체인(Prototype chain)"></a>프로토타입 체인(Prototype chain)</h2><ul>
<li>해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색하는 것을 프로토타입 체인이라고 한다.</li>
</ul>
<h2 id="프로토타입-객체의-확장"><a href="#프로토타입-객체의-확장" class="headerlink" title="프로토타입 객체의 확장"></a>프로토타입 객체의 확장</h2><ul>
<li>프로토타입 객체도 객체이므로 프로퍼티를 추가,삭제할 수 있다.</li>
<li>아래 예는 Person.prototype 객체에 메소드 sayHello를 추가하였다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi~~ my name is '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="기본자료형의-확장"><a href="#기본자료형의-확장" class="headerlink" title="기본자료형의 확장"></a>기본자료형의 확장</h2><ul>
<li>기본자료형은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없다.</li>
<li>그러나 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다.</li>
<li>프로퍼티나 메소드를 직접 추가할 수는 없고, String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하면 메소드를 사용할 수 있다.</li>
<li>표준 내장 객체(Built-in object)의 프로토타입 객체(String.prototype, Number.prototype, Array.prototype 등)에 개발자가 정의한 메소드의 추가를 허용한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objStr = <span class="string">'this is string'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'String prototype'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objStr.myMethod()); <span class="comment">//String prototype 출력</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="프로토타입-객체의-변경"><a href="#프로토타입-객체의-변경" class="headerlink" title="프로토타입 객체의 변경"></a>프로토타입 객체의 변경</h2><ul>
<li>객체를 생성할 때 프로토타입이 결정되고, 부모 객체인 프로토타입을 동적으로 변경할 수 있다.</li>
<li>프로토타입 객체 변경 시점 이전에 생성된 객체의 constructor 속성은 해당 객체의 생성자 함수를 가르킨다.</li>
<li>프로토타입 객체 변경 시점 이후에 생성된 객체의 constructor는 Object() 생성자 함수를 가르킨다.</li>
<li>즉, Person(기존생성자명).prototype.constructor 프로퍼티가 삭제되고, Object.prototype.constructor 프로퍼티가 생성된다.</li>
</ul>
<h3 id="프로토타입-체인-동작-조건"><a href="#프로토타입-체인-동작-조건" class="headerlink" title="프로토타입 체인 동작 조건"></a>프로토타입 체인 동작 조건</h3><ul>
<li><p>객체의 프로퍼티를 참조하는 경우, 프로토타입 체인이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.gender = <span class="string">'male'</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Person(<span class="string">'Kim'</span>);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Choi'</span>);</span><br><span class="line">foo.gender = <span class="string">'female'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>위 예제처럼 새로 생성한 객체에 gender 프로퍼티의 값을 할당하면 프로토타입 체인이 동작하지 않고, 해당 객체에 프로퍼티를 동적으로 추가한다.</p>
</li>
</ul>
<hr>
<h1 id="Scope-유효범위"><a href="#Scope-유효범위" class="headerlink" title="Scope(유효범위)"></a>Scope(유효범위)</h1><ul>
<li>변수가 가지고 있는 참조범위이다.</li>
<li>변수가 유효한 범위, 변수에 접근할 수 있는 범위를 말한다.</li>
</ul>
<h2 id="function-level-scope"><a href="#function-level-scope" class="headerlink" title="function-level scope"></a>function-level scope</h2><ul>
<li>함수 코드 블럭 내에서 선언된 변수는 함수 코드 블럭 내에서만 유효하고 함수 외부에서는 참조할 수 없다.</li>
<li>단, ECMAScript 6에서 도입된 let keyword를 사용하면 block-level scope를 사용할 수 있다.</li>
<li>function 밖에 선언된 변수는 코드 블랙 내에 선언되었다 할지라도 전역 변수가 된다.(Global scope를 갖는다.)</li>
</ul>
<h2 id="Global-scope"><a href="#Global-scope" class="headerlink" title="Global scope"></a>Global scope</h2><ul>
<li>글로벌 영역에 변수를 선언하면 그 변수는 어디서나 참조할 수 있는 전역 변수가 된다.</li>
<li>전역 변수는 전역 객체 window의 프로퍼티이다.</li>
</ul>
<h2 id="암묵적-전역"><a href="#암묵적-전역" class="headerlink" title="암묵적 전역"></a>암묵적 전역</h2><ul>
<li>함수 내에서 var keyword 없이 변수를 선언하면 상위 지역(전역)에서 변수를 찾고 존재하지 않으면 암묵적으로 전역 변수로 선언한다.</li>
<li>의도치 않은 전역 변수가 될 수 있으므로 var keyword를 사용한다.</li>
</ul>
<h2 id="전역-변수-사용의-억제"><a href="#전역-변수-사용의-억제" class="headerlink" title="전역 변수 사용의 억제"></a>전역 변수 사용의 억제</h2><ul>
<li>암묵적 전역 변수화(var keyword가 없을 경우)와 변수명 중복 허용으로 변수의 값이 변경될 수 도 있다.</li>
<li>전역 변수를 반드시 사용해야 할 경우가 아니라면 지역 변수를 사용해야 한다.</li>
<li>코드가 길어지면 변수명의 중복이 발생하기 쉬워 예기치 못한 이상 동작의 원인이 되기 쉬우며, 전역변수는 지역변수보다 탐색에 걸리는 시간이 더 길다.</li>
<li>즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용한다.</li>
<li>즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다.</li>
<li>사용법 =&gt; (function () { 변수 선언, 실행할 내용… }());</li>
</ul>
<hr>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ol>
<li>함수 호출 패턴</li>
</ol>
<ul>
<li>this는 전역 객체에 바인딩된다.</li>
<li>전역함수, 내부함수, 메소드의 내부함수, 콜백함수 모두 전역 객체에 바인딩된다.</li>
</ul>
<ol>
<li>메소드 호출 패턴</li>
</ol>
<ul>
<li>this는 해당 메소드를 호출한 객체에 바인딩된다.</li>
<li>함수가 객체의 프로퍼티일 때, 메소드 내부의 this</li>
<li>프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다.</li>
</ul>
<ol>
<li>생성자 호출 패턴</li>
</ol>
<ul>
<li>this는 새로 생성된 객체를 가리킨다.</li>
<li>new 연산자로 생성자 함수를 호출하면</li>
</ul>
<ol>
<li>빈 객체 생성 및 this 바인딩: 빈 객체를 생성후 this는 이 빈 객체를 가리킨다.</li>
<li>this를 통한 프로퍼티 생성: 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성한다.</li>
<li>생성된 객체 반환 : 반환문이 없는 경우, 새로 생성된 객체가 반환된다.</li>
</ol>
<hr>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[프로토타입과 this]]></title>
      <url>/2017/09/29/TIL-0929/</url>
      <content type="html"><![CDATA[<h1 id="prototype-프로토타입"><a href="#prototype-프로토타입" class="headerlink" title="prototype 프로토타입"></a>prototype 프로토타입</h1><ul>
<li>prototype 프로퍼티:<br>생성자가 생성될 객체의 부모 역할을 하는 프로토타입을 찾아갈 때 사용한다.</li>
<li><code>__proto__</code> 프로퍼티:<br>생성된 객체가 부모 역할을 하는 프로토타입을 찾아갈 때<br>모든 객체는 [[prototype]]이라는 숨겨진 프로퍼티를 가진다. [[prototype]]이 정확한 명칭이고 <code>__proto__</code>와 의미는 같다.</li>
</ul>
<p>-constructor 프로퍼티:<br>프로토타입은 constructor 객체를 가진다.<br>생성된 객체가 생성자를 찾아갈수 있게 한다.</p>
<a id="more"></a>
<h2 id="즉시호출함수표현식-IIFE-Immediately-Invoke-Function-Expression"><a href="#즉시호출함수표현식-IIFE-Immediately-Invoke-Function-Expression" class="headerlink" title="즉시호출함수표현식 (IIFE, Immediately Invoke Function Expression)"></a>즉시호출함수표현식 (IIFE, Immediately Invoke Function Expression)</h2><ul>
<li>함수를 선언하자마자 호출한다.</li>
<li>딱 한번만 호출된다.</li>
<li>변수가 함수내에서만 유효하기 때문에 전역변수를 사용하지 않아서 변수 중복 선언 같은 문제를 방지할 수 있다.</li>
</ul>
<h2 id="내부함수"><a href="#내부함수" class="headerlink" title="내부함수"></a>내부함수</h2><ul>
<li>함수 내부에 정의된 함수이다.</li>
<li>부모함수, 외부에서는 내부함수에 접근할 수 없다.</li>
</ul>
<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  score: <span class="number">90</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// student에는 hasOwnProperty 메소드가 없지만 아래 구문은 동작한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(student.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(student);</span><br></pre></td></tr></table></figure>
<ul>
<li>student의 프로포타입은 Object이다. (생성자 함수명이 Object)</li>
</ul>
<h2 id="프로토타입-객체의-확장"><a href="#프로토타입-객체의-확장" class="headerlink" title="프로토타입 객체의 확장"></a>프로토타입 객체의 확장</h2><h2 id="기본자료형-Primitive-data-type-의-확장"><a href="#기본자료형-Primitive-data-type-의-확장" class="headerlink" title="기본자료형(Primitive data type)의 확장"></a>기본자료형(Primitive data type)의 확장</h2><ul>
<li>기본자료형은 객체가 아니므로 프로퍼티와 메서드가 없지만<br>프로퍼티나 메서드가 호출할 때 일시적으로 객체형이 된다.</li>
</ul>
<h1 id="Scope-유효범위"><a href="#Scope-유효범위" class="headerlink" title="Scope 유효범위"></a>Scope 유효범위</h1><h2 id="전역변수-Global-variable"><a href="#전역변수-Global-variable" class="headerlink" title="전역변수(Global variable)"></a>전역변수(Global variable)</h2><ul>
<li>코드 어디서든 참조할 수 있다.<h2 id="지역변수-Local-variable-or-function-level-variable"><a href="#지역변수-Local-variable-or-function-level-variable" class="headerlink" title="지역변수(Local variable or function-level variable)"></a>지역변수(Local variable or function-level variable)</h2></li>
<li>정의 된 함수 내에서만 참조할 수 있다.</li>
</ul>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul>
<li>메서드, 생성자를 제외한 모든 객체의 this는 window이다.</li>
<li>new 연산자가 없는 그냥 함수에서의 this는 window이다.</li>
<li>기존함수에 new 연산자를 붙여서 호출하면 생성자 함수로 동작한다.</li>
<li>생성자 함수로 동작할 때 this는 자신이 생성할 객체를 가리킨다.</li>
<li>메서드의 this는 해당 메서드의 소유주이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> prototype, this객체, scope </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[객체와 생성자함수]]></title>
      <url>/2017/09/28/TIL-0928/</url>
      <content type="html"><![CDATA[<h2 id="객체-Object"><a href="#객체-Object" class="headerlink" title="객체(Object)"></a>객체(Object)</h2><ul>
<li>프로퍼티(data)와 메소드(행위)로 구성된다.</li>
<li>data를 컨트롤하기 위한 행위를 객체라고 할 수 있다.</li>
<li>객체는 상속을 사용하여 중복을 막는다.</li>
<li>기본자료형을 제외한 모든 것은 객체이다.</li>
</ul>
<h3 id="추상화-특징-행위를-객체에-추가하는-것"><a href="#추상화-특징-행위를-객체에-추가하는-것" class="headerlink" title="추상화: 특징, 행위를 객체에 추가하는 것"></a>추상화: 특징, 행위를 객체에 추가하는 것</h3><h2 id="프로퍼티-Property"><a href="#프로퍼티-Property" class="headerlink" title="프로퍼티(Property)"></a>프로퍼티(Property)</h2><ul>
<li>key(이름)와 value(값)로 이루어져 있다.</li>
<li>프로퍼티 이름 : 빈문자열, 문자열, 숫자</li>
<li>프로퍼티 값 : undefined를 제외한 모든 값</li>
</ul>
<h2 id="메소드-Method"><a href="#메소드-Method" class="headerlink" title="메소드(Method)"></a>메소드(Method)</h2><ul>
<li>값(value)이 함수인 프로퍼티</li>
<li>일반 함수와 구분하기 위해 메소드라 부른다.</li>
</ul>
<a id="more"></a>
<h2 id="객체생성방법-ES5-3가지"><a href="#객체생성방법-ES5-3가지" class="headerlink" title="객체생성방법 ES5(3가지)"></a>객체생성방법 ES5(3가지)</h2><h3 id="1-객체-리터럴"><a href="#1-객체-리터럴" class="headerlink" title="1.객체 리터럴"></a>1.객체 리터럴</h3><ul>
<li>중괄호를 사용하여 객체를 생성한다.</li>
<li>중괄호 안에 프로퍼티가 없으면 빈 객체 리터럴이다.</li>
<li>var emptyObject = {}; //빈 객체 리터럴</li>
</ul>
<h4 id="참고-console-log"><a href="#참고-console-log" class="headerlink" title="[참고] console.log"></a><code>[참고] console.log</code></h4><ul>
<li>내장객체.메서드</li>
<li>내장객체(=built-in) : 자바스크립트가 원래부터 갖고 있는 함수이다.</li>
</ul>
<h3 id="2-Object-생성자-함수"><a href="#2-Object-생성자-함수" class="headerlink" title="2.Object()생성자 함수"></a>2.Object()생성자 함수</h3><ul>
<li>빈 객체 리턴 후, 동적으로 프로퍼티를 추가한다.</li>
<li>객체리터럴 방식으로 객체가 생성되는 동안 실제 내부적으로 처리되는 방식이다.</li>
<li>ES5에서 잘 사용하지 않는다.</li>
</ul>
<h3 id="3-생성자-함수"><a href="#3-생성자-함수" class="headerlink" title="3.생성자 함수"></a>3.생성자 함수</h3><ul>
<li>객체를 생성하기 위한 함수이다.</li>
<li>객체를 생성하기 위한 템플릿을 구성하여 재사용하기 때문에 여러 객체를 간편하게 생성할 수 있다.</li>
<li>인스턴스로 추가적인 객체를 생성할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, gender</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> married = <span class="literal">true</span>; <span class="comment">//private 외부에서 접근이 불가능하다.</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>,<span class="string">'male'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.gender);  <span class="comment">// 'male'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.married); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="객체-프로퍼티-접근"><a href="#객체-프로퍼티-접근" class="headerlink" title="객체 프로퍼티 접근"></a>객체 프로퍼티 접근</h2><h2 id="프로퍼티-이름"><a href="#프로퍼티-이름" class="headerlink" title="프로퍼티 이름"></a>프로퍼티 이름</h2><ul>
<li>‘first-name’는 반드시 따옴표를 사용한다. ‘-‘ 연산자로 인식한다. </li>
<li>예약어는 사용하면 안된다.</li>
<li>first-name, ‘first-name’, firstName </li>
</ul>
<h2 id="프로퍼티-값-읽기"><a href="#프로퍼티-값-읽기" class="headerlink" title="프로퍼티 값 읽기"></a>프로퍼티 값 읽기</h2><ul>
<li>프로퍼티가 gender:’male’일 경우, person.gender로 접근하거나, person[‘gender’]로 접근한다.</li>
<li>프로퍼티가 ‘first-name’:’Ung-mo’일 경우,  person[‘first-name’]로 접근한다. </li>
<li>대괄호 표기법을 사용할 때, 대괄호 안의 프로퍼티 이름은 반드시 문자열(‘ ‘)이어야 한다.</li>
</ul>
<h2 id="프로퍼티-동적-생성"><a href="#프로퍼티-동적-생성" class="headerlink" title="프로퍼티 동적 생성"></a>프로퍼티 동적 생성</h2><ul>
<li>객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다.</li>
<li>객체가 소유하지 않은 프로퍼티에 값을 할당하면 객체에 해당 프로퍼티를 추가하고 값을 할당한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="string">'first-name'</span>: <span class="string">'Ung-mo'</span>,</span><br><span class="line"><span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</span><br><span class="line">gender: <span class="string">'male'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.married); <span class="comment">// undefined;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h2 id="for-in-문"><a href="#for-in-문" class="headerlink" title="for-in 문"></a>for-in 문</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">': '</span> + person[prop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>프로퍼티 갯수만큼 순회한다.</li>
<li>순서가 보장되지 않으므로 배열에서는 for-of문을 사용한다.</li>
<li>for-of는 배열의 요소를 순회한다.</li>
</ul>
<h2 id="Pass-by-reference"><a href="#Pass-by-reference" class="headerlink" title="Pass-by-reference"></a>Pass-by-reference</h2><ul>
<li>객체: pass-by-reference, mutable</li>
<li>객체는 힙에 저장된다.</li>
<li>객체는 객체의 값(value)이 아니라 객체가 들어있는 주소값을 저장한다.(기본자료형은 값 자체가 저장된다.)</li>
<li>할당을 하면 같은 주소를 참조하게 된다.</li>
<li>var foo; var bar = foo; bar는 foo의 주소 값을 갖게 된다. 즉 같은 주소를 참조하게 된다.</li>
</ul>
<h2 id="객체의-분류-용어정리"><a href="#객체의-분류-용어정리" class="headerlink" title="객체의 분류 (용어정리)"></a>객체의 분류 (용어정리)</h2><h3 id="Built-in-Object-내장-객체"><a href="#Built-in-Object-내장-객체" class="headerlink" title="Built-in Object(내장 객체)"></a>Built-in Object(내장 객체)</h3><ul>
<li>내장 객체는 자바스크립트 엔진에 내장되어 있어, 필요한 경우 생성해 사용할 수 있다.</li>
<li>내장 객체로는 문자(String), 날짜(Date), 배열(Array), 수학(Math)객체 등이 있다.</li>
</ul>
<h3 id="BOM-Browser-Object-Model"><a href="#BOM-Browser-Object-Model" class="headerlink" title="BOM (Browser Object Model)"></a>BOM (Browser Object Model)</h3><ul>
<li>브라우저 객체 모델</li>
<li>브라우저에 계층적으로 내장되어 있는 객체로 window, screen, location, history, navigator 등이 있다.</li>
<li>window.location.href= “사이트 url”</li>
</ul>
<h3 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM (Document Object Model)"></a>DOM (Document Object Model)</h3><ul>
<li>문서 객체 모델</li>
<li>HTML 문서 구조를 말한다.</li>
<li>최상위 객체 <code>&lt;html&gt;</code> 그리고 <code>&lt;head&gt;, &lt;body&gt;</code> 등이 있다.</li>
</ul>
<h3 id="Host-Object-사용자-정의-객체"><a href="#Host-Object-사용자-정의-객체" class="headerlink" title="Host Object(사용자 정의 객체)"></a>Host Object(사용자 정의 객체)</h3><ul>
<li>사용자가 생성한 객체로 사용자가 constructor 혹은 객체리터럴을 통해 사용자가 객체를 정의하고 확장시킨 것들이기 때문에 Built-in Object 와 Native Object가 구성된 이후에 구성된다.</li>
</ul>
<hr>
<h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><ul>
<li>코드재사용</li>
<li>매개변수,인자(parameter) / 인수(argument)</li>
</ul>
<h2 id="함수-정의-방식-3가지"><a href="#함수-정의-방식-3가지" class="headerlink" title="함수 정의 방식 3가지"></a>함수 정의 방식 3가지</h2><h2 id="1-함수선언식"><a href="#1-함수선언식" class="headerlink" title="1.함수선언식"></a>1.함수선언식</h2><ul>
<li>함수 호이스팅이 발생한다.</li>
<li>함수를 선언하기 전에 상단에서 호출했을 때 함수를 선언한 것처럼 실행하는 것을 호이스팅이라고 한다.</li>
</ul>
<h2 id="2-함수표현식"><a href="#2-함수표현식" class="headerlink" title="2.함수표현식"></a>2.함수표현식</h2><ul>
<li>함수 선언식과는 달리 변수 호이스팅이 발생하고, 함수를 먼저 호출할 경우, TypeError가 발생한다.</li>
<li>자바스크립트의 함수는 <code>일급객체</code> 이다.</li>
<li>일급 객체의 특성을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이러한 방식을 함수표현식(Function expression)이라 한다. </li>
</ul>
<h4 id="일급객체-First-class-object"><a href="#일급객체-First-class-object" class="headerlink" title="일급객체(First-class object)"></a>일급객체(First-class object)</h4><ul>
<li>무명의 리터럴로 표현이 가능하다.</li>
<li>함수를 변수나 데이터 구조안에 담을 수 있다.</li>
<li>함수의 파라미터로 함수를 전달 할 수 있다.(함수를 값처럼 사용할 수 있다.)</li>
<li>함수를 반환값으로 사용할 수 있다.</li>
</ul>
<h3 id="함수표현식-두가지"><a href="#함수표현식-두가지" class="headerlink" title="함수표현식 두가지"></a>함수표현식 두가지</h3><p> 1.익명 함수표현식(anonymous function expression) : 함수명을 생략해서 함수를 선언한 것이다.<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 2.기명 함수표현식(named function expression) : 외부에서 호출할 수 없다.</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="function-생성자-함수"><a href="#function-생성자-함수" class="headerlink" title="function() 생성자 함수"></a>function() 생성자 함수</h2><ul>
<li>Function() 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다.</li>
<li>함수선언식과 함수표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨 것이다.</li>
<li>일반적으로 사용하지 않는다.</li>
</ul>
<h3 id="참고-함수-호이스팅과-변수-호이스팅"><a href="#참고-함수-호이스팅과-변수-호이스팅" class="headerlink" title="[참고] 함수 호이스팅과 변수 호이스팅"></a>[참고] 함수 호이스팅과 변수 호이스팅</h3><h4 id="함수-선언식-함수-호이스팅"><a href="#함수-선언식-함수-호이스팅" class="headerlink" title="함수 선언식 - 함수 호이스팅"></a>함수 선언식 - 함수 호이스팅</h4><p>함수 호이스팅은 함수 선언, 초기화, 할당이 한번에 이루어 진다.<br>따라서 함수 호출이 먼저 진행될 경우 에러가 발생하지 않는다.</p>
<h4 id="함수-표현식-변수-호이스팅"><a href="#함수-표현식-변수-호이스팅" class="headerlink" title="함수 표현식 - 변수 호이스팅"></a>함수 표현식 - 변수 호이스팅</h4><p>변수 호이스팅은 변수생성, 초기화, 할당이 분리되어 진행된다.<br>호이스팅된 변수는 undefined로 초기화되고 실제 값의 할당은 할당문에서 이루어진다.<br>따라서 함수 호출이 먼저 진행될 경우 TypeError가 발생하게 된다.</p>
<h2 id="arguments-프로퍼티"><a href="#arguments-프로퍼티" class="headerlink" title="arguments 프로퍼티"></a>arguments 프로퍼티</h2><ul>
<li>매개 변수 갯수가 확정되지 않은 <code>가변 인자 함수</code> 구현에 유용하다.</li>
<li>매개 변수의 갯수보다 인수를 적게 전달했을 때, 전달되지 않은 인수 값은 undefind로 초기화된다.</li>
<li>반대로 인수가 초과 전달되었을 때는 초과된 인수가 무시된다.</li>
<li>arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 <code>유사배열객체(array-like object)</code>이다.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> object, property, method, constructor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[알고리즘 문제풀이]]></title>
      <url>/2017/09/27/TIL-0927/</url>
      <content type="html"><![CDATA[<h3 id="1-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#1-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="1. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>1. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오"><a href="#2-for문을-사용하여-0부터-10미만의-정수-중에서-짝수만을-작은-수부터-문자열로-출력하시오" class="headerlink" title="2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오."></a>2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<h3 id="3-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오"><a href="#3-for문을-사용하여-0부터-10미만의-정수-중에서-홀수만을-큰수부터-출력하시오" class="headerlink" title="3. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오."></a>3. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-while문을-사용하여-0부터-10까지-정수-중에서-짝수만을-작은-수부터-출력하시오"><a href="#4-while문을-사용하여-0부터-10까지-정수-중에서-짝수만을-작은-수부터-출력하시오" class="headerlink" title="4. while문을 사용하여 0부터 10까지 정수 중에서 짝수만을 작은 수부터 출력하시오."></a>4. while문을 사용하여 0부터 10까지 정수 중에서 짝수만을 작은 수부터 출력하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//# 5. while문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">  num--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오"><a href="#6-for-문을-사용하여-0부터-10미만의-정수의-합을-출력하시오" class="headerlink" title="6.for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오."></a>6.for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<h3 id="7-1부터-20까지의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오"><a href="#7-1부터-20까지의-정수-중에서-2-또는-3의-배수가-아닌-수의-총합을-구하시오" class="headerlink" title="7. 1부터 20까지의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오."></a>7. 1부터 20까지의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    res += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>
<h3 id="8-1부터-20까지의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오"><a href="#8-1부터-20까지의-정수-중에서-2-또는-3의-배수인-수의-총합을-구하시오" class="headerlink" title="8. 1부터 20까지의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오."></a>8. 1부터 20까지의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span> || i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    res += i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>
<h3 id="9-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오"><a href="#9-두-개의-주사위를-던졌을-때-눈의-합이-6이-되는-모든-경우의-수를-출력하시오" class="headerlink" title="9. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오."></a>9. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</h3><ul>
<li>for문</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">var</span> num = i + j;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'['</span> + i + <span class="string">','</span> + j + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while문</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ju1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> res = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ju1 &lt; <span class="number">7</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> ju2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (ju2 &lt; <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = ju1 + ju2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum === <span class="number">6</span>) &#123;</span><br><span class="line">      res = [ju1, ju2];</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">    ju2++;</span><br><span class="line">  &#125;</span><br><span class="line">  ju1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-삼각형출력하기"><a href="#10-삼각형출력하기" class="headerlink" title="10. 삼각형출력하기"></a>10. 삼각형출력하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    result += <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<h3 id="11-트리-출력하기"><a href="#11-트리-출력하기" class="headerlink" title="11. 트리 출력하기"></a>11. 트리 출력하기</h3><ul>
<li>내풀이</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    result += <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    result += <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<ul>
<li>다른사람 풀이 (마지막 sum호출시 \n 때문에 줄바꿈이된다.)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  star += <span class="string">'*'</span>;</span><br><span class="line">  sum += star + <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure>
<h3 id="12-정삼각형-출력하기"><a href="#12-정삼각형-출력하기" class="headerlink" title="12. 정삼각형 출력하기"></a>12. 정삼각형 출력하기</h3><ul>
<li>for문</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span> - i; j++) &#123;</span><br><span class="line">    result += <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; (i * <span class="number">2</span>) + <span class="number">1</span>; k++) &#123;</span><br><span class="line">    result += <span class="string">"*"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<ul>
<li>내장함수 (Math,repeat 활용)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> star = <span class="string">'*'</span>;</span><br><span class="line"><span class="keyword">var</span> space = <span class="string">' '</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = <span class="built_in">Math</span>.floor((<span class="number">10</span> - i) / <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(space.repeat(temp) + star.repeat(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-역정삼각형-출력하기"><a href="#13-역정삼각형-출력하기" class="headerlink" title="13. 역정삼각형 출력하기"></a>13. 역정삼각형 출력하기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">5</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">1</span>; k &lt;= <span class="number">5</span> - i; k++) &#123;</span><br><span class="line">      result += <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= (<span class="number">2</span> * i) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      result += <span class="string">"*"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  result += <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript, algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript 연산자와 형변환]]></title>
      <url>/2017/09/26/TIL-0926-2/</url>
      <content type="html"><![CDATA[<h2 id="1-산술연산자-Arithmetic-Operators"><a href="#1-산술연산자-Arithmetic-Operators" class="headerlink" title="1. 산술연산자(Arithmetic Operators)"></a>1. 산술연산자(Arithmetic Operators)</h2><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>덧셈</td>
</tr>
<tr>
<td>-</td>
<td>뺄셈</td>
</tr>
<tr>
<td>*</td>
<td>곱셈</td>
</tr>
<tr>
<td>/</td>
<td>나눗셈</td>
</tr>
<tr>
<td>%</td>
<td>나머지</td>
</tr>
<tr>
<td>++</td>
<td>증가</td>
</tr>
<tr>
<td>–</td>
<td>감소</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h3 id="연산자"><a href="#연산자" class="headerlink" title="+ 연산자"></a>+ 연산자</h3><ul>
<li>연산 대상이 모두 숫자인 경우 : 덧셈 연산</li>
<li>문자나 문자열이 포함된 경우 : 문자열 연결 연산<br>[참고] 연산 대상을 같은 타입으로 맞춰서 덧셈 연산자를 수행하도록 하는 것이 좋다.</li>
</ul>
<h3 id="–-증감-연산자"><a href="#–-증감-연산자" class="headerlink" title="++, – (증감 연산자)"></a>++, – (증감 연산자)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z = x++;    // 5 선대입후증가</span><br><span class="line">z = ++x;    // 7 선증가후대입</span><br><span class="line">z = x--;    // 7 선대입후감소</span><br><span class="line">z = --x;    // 5 선감소후대입</span><br></pre></td></tr></table></figure>
<h2 id="2-대입연산자-Assignment-Operators"><a href="#2-대입연산자-Assignment-Operators" class="headerlink" title="2. 대입연산자(Assignment Operators)"></a>2. 대입연산자(Assignment Operators)</h2><table>
<thead>
<tr>
<th>Operator</th>
<th>Example</th>
<th>Same As</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>x = y</td>
<td>x = y</td>
</tr>
<tr>
<td>+=</td>
<td>x += y</td>
<td>x = x + y</td>
</tr>
<tr>
<td>-=</td>
<td>x -= y</td>
<td>x = x - y</td>
</tr>
<tr>
<td>*=</td>
<td>x *= y</td>
<td>x = x * y</td>
</tr>
<tr>
<td>/=</td>
<td>x /= y</td>
<td>x = x / y</td>
</tr>
<tr>
<td>%=</td>
<td>x %= y</td>
<td>x = x % y</td>
</tr>
</tbody>
</table>
<h2 id="3-비교연산자-Comparison-Operators"><a href="#3-비교연산자-Comparison-Operators" class="headerlink" title="3. 비교연산자(Comparison Operators)"></a>3. 비교연산자(Comparison Operators)</h2><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>동등비교 (loose equality) 형변환 후, 비교한다.</td>
</tr>
<tr>
<td>===</td>
<td>일치비교 (strict equality) 타입까지 일치하여야 true를 반환한다.</td>
</tr>
<tr>
<td>!=</td>
<td>부등비교</td>
</tr>
<tr>
<td>!==</td>
<td>불일치비교</td>
</tr>
<tr>
<td>&gt;</td>
<td>관계비교</td>
</tr>
<tr>
<td>&lt;</td>
<td>관계비교</td>
</tr>
<tr>
<td>&gt;=</td>
<td>관계비교</td>
</tr>
<tr>
<td>&lt;=</td>
<td>관계비교</td>
</tr>
<tr>
<td>?</td>
<td>삼항연산자</td>
</tr>
</tbody>
</table>
<h3 id="참고-와-연산자-비교"><a href="#참고-와-연산자-비교" class="headerlink" title="[참고] ==와 === 연산자 비교"></a>[참고] ==와 === 연산자 비교</h3><p>var num = 5;</p>
<p>x == 5 // true<br>x == ‘5’ // true, 데이터형이 달라도 같게 변환하여 true를 반환한다.</p>
<p>x === 5 // true<br>x === ‘5’ // false, 데이터형이 다르면 false를 반환한다.</p>
<h2 id="4-논리-연산자-Logical-Operator"><a href="#4-논리-연산자-Logical-Operator" class="headerlink" title="4. 논리 연산자(Logical Operator)"></a>4. 논리 연산자(Logical Operator)</h2><table>
<thead>
<tr>
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>`</td>
<td></td>
<td>`</td>
<td>or</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
</tr>
<tr>
<td>!</td>
<td>not</td>
</tr>
</tbody>
</table>
<h3 id="논리-합-연산자"><a href="#논리-합-연산자" class="headerlink" title="|| (논리 합) 연산자"></a>|| (논리 합) 연산자</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 =  <span class="literal">true</span> || <span class="literal">true</span>;     <span class="comment">// t || t returns true</span></span><br><span class="line"><span class="keyword">var</span> o2 = <span class="literal">false</span> || <span class="literal">true</span>;     <span class="comment">// f || t returns true</span></span><br><span class="line"><span class="keyword">var</span> o3 =  <span class="literal">true</span> || <span class="literal">false</span>;    <span class="comment">// t || f returns true</span></span><br><span class="line"><span class="keyword">var</span> o4 = <span class="literal">false</span> || (<span class="number">3</span> == <span class="number">4</span>); <span class="comment">// f || f returns false</span></span><br></pre></td></tr></table></figure>
<h3 id="amp-amp-논리곱-연산자"><a href="#amp-amp-논리곱-연산자" class="headerlink" title="&amp;&amp; (논리곱) 연산자"></a>&amp;&amp; (논리곱) 연산자</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 =  <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>;     <span class="comment">// t &amp;&amp; t returns true</span></span><br><span class="line"><span class="keyword">var</span> a2 =  <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>;    <span class="comment">// t &amp;&amp; f returns false</span></span><br><span class="line"><span class="keyword">var</span> a3 = <span class="literal">false</span> &amp;&amp; <span class="literal">true</span>;     <span class="comment">// f &amp;&amp; t returns false</span></span><br><span class="line"><span class="keyword">var</span> a4 = <span class="literal">false</span> &amp;&amp; (<span class="number">3</span> == <span class="number">4</span>); <span class="comment">// f &amp;&amp; f returns false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ! (논리 부정) 연산자</span></span><br><span class="line"><span class="keyword">var</span> n1 = !<span class="literal">true</span>;  <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> n2 = !<span class="literal">false</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> n3 = !<span class="string">'Cat'</span>; <span class="comment">// false (빈 문자열이 아닐 경우 true로 간주)</span></span><br></pre></td></tr></table></figure>
<h3 id="참고-논리-부정-연산자로-값의-유무를-판별할-수-있다"><a href="#참고-논리-부정-연산자로-값의-유무를-판별할-수-있다" class="headerlink" title="[참고] 논리 부정 연산자로 값의 유무를 판별할 수 있다"></a>[참고] 논리 부정 연산자로 값의 유무를 판별할 수 있다</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(!str); <span class="comment">// true - str에 값이 없다.</span></span><br></pre></td></tr></table></figure>
<h2 id="5-단축-평가-Short-Circuit-Evaluations"><a href="#5-단축-평가-Short-Circuit-Evaluations" class="headerlink" title="5. 단축 평가(Short-Circuit Evaluations)"></a>5. 단축 평가(Short-Circuit Evaluations)</h2><ul>
<li>Boolean값으로 평가하기 위해 참조하여야 할 곳까지 진행한 후, 평가를 중지하게된 계기가 된 값을 반환한다.</li>
</ul>
<table>
<thead>
<tr>
<th>평가식</th>
<th>평가결과</th>
</tr>
</thead>
<tbody>
<tr>
<td>true `</td>
<td></td>
<td>` anyting</td>
<td>true</td>
</tr>
<tr>
<td>false `</td>
<td></td>
<td>` anything</td>
<td>false</td>
</tr>
<tr>
<td>true <code>&amp;&amp;</code> anything</td>
<td>anyting</td>
</tr>
<tr>
<td>false <code>&amp;&amp;</code> anything</td>
<td>false</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>  <span class="comment">// t &amp;&amp; t returns 'Dog'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>‘Cat’은 true이므로 ‘Dog’까지 평가해 보아야 한다.</li>
<li>평가를 중지하게된 계기가 된 값 ‘Dog’을 반환한다. </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'Cat'</span> || <span class="string">'Dog'</span>  <span class="comment">// t || t returns 'Cat'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>‘Cat’은 true이므로 평가를 중지하고 ‘Cat’을 반환한다.</li>
</ul>
<h1 id="평가"><a href="#평가" class="headerlink" title="평가"></a>평가</h1><p>흐름제어를 위해서는 조건식을 평가하여 논리적 참, 거짓을 구별한 후 평가 결과에 따라 의사결정을 하는 것이 일반적이다.<br>이 때 자바스크립트는 암묵적 강제 형 변환을 통해 조건식을 평가한다.</p>
<hr>
<h2 id="암묵적-강제-형-변환-Type-coercion"><a href="#암묵적-강제-형-변환-Type-coercion" class="headerlink" title="암묵적 강제 형 변환 (Type coercion)"></a>암묵적 강제 형 변환 (Type coercion)</h2><p>Javascript는 context(문맥)을 고려하여 내부적으로 자료형을 암묵적으로 강제 변환하여 작업을 완료할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> &gt; <span class="number">0</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="string">'2'</span>) <span class="comment">// '12'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> - <span class="string">'1'</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'10'</span> == <span class="number">10</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="직접-형-변환"><a href="#직접-형-변환" class="headerlink" title="직접 형 변환"></a>직접 형 변환</h2><h3 id="string-gt-number"><a href="#string-gt-number" class="headerlink" title="string -&gt; number"></a><code>string -&gt; number</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="string">'123'</span>; <span class="comment">//문자열</span></span><br><span class="line"></span><br><span class="line">방법<span class="number">1</span>)</span><br><span class="line">val =+ val</span><br><span class="line"></span><br><span class="line">방법<span class="number">2</span>) </span><br><span class="line">val = val * <span class="number">1</span></span><br><span class="line"></span><br><span class="line">방법<span class="number">3</span>)</span><br><span class="line"><span class="built_in">Number</span>(value); <span class="comment">//객체를 만들때 사용, 사용권장안함</span></span><br><span class="line"></span><br><span class="line">방법<span class="number">4</span>)</span><br><span class="line"><span class="built_in">parseInt</span>(value);</span><br></pre></td></tr></table></figure>
<h3 id="number-gt-string"><a href="#number-gt-string" class="headerlink" title="number -&gt; string"></a><code>number -&gt; string</code></h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">123</span>; <span class="comment">//숫자</span></span><br><span class="line"></span><br><span class="line">방법<span class="number">1</span>) </span><br><span class="line">val = val + <span class="string">''</span>; <span class="comment">//권장</span></span><br><span class="line"></span><br><span class="line">방법<span class="number">2</span>) </span><br><span class="line">val = <span class="built_in">String</span>(val);</span><br><span class="line"></span><br><span class="line">방법<span class="number">3</span>)</span><br><span class="line">val = val.toString();</span><br></pre></td></tr></table></figure>
<h2 id="Truthy-amp-Falsy-values"><a href="#Truthy-amp-Falsy-values" class="headerlink" title="Truthy &amp; Falsy values"></a>Truthy &amp; Falsy values</h2><ul>
<li><code>Falsy values</code> : Boolean Context에서 false로 평가되는 값들</li>
<li><code>Truthy Values</code> : Falsy values 이외의 값들이며(object포함) true로 평가된다.</li>
</ul>
<h3 id="Falsy-Values"><a href="#Falsy-Values" class="headerlink" title="Falsy Values"></a>Falsy Values</h3><ul>
<li><code>false</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code></li>
<li><code>NaN (Not a Number)</code></li>
<li><code>&#39;&#39; (빈문자열)</code></li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> operator, javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript 자료형과 변수]]></title>
      <url>/2017/09/26/TIL-0926/</url>
      <content type="html"><![CDATA[<h1 id="Javascript-Data-type-amp-Variable"><a href="#Javascript-Data-type-amp-Variable" class="headerlink" title="Javascript Data type &amp; Variable"></a>Javascript Data type &amp; Variable</h1><h1 id="자료형과-변수"><a href="#자료형과-변수" class="headerlink" title="(자료형과 변수)"></a>(자료형과 변수)</h1><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><ul>
<li>미선언 변수를 호출하면 <strong>ReferenceError</strong> 예외가 발생한다.</li>
<li>변수의 중복 선언은 허용되지만 재할당으로 값이 변경된다.</li>
<li>var 키워드를 생략하면 전역변수가 된다.</li>
</ul>
<h3 id="참고-var-키워드로-선언된-변수의-문제점-ES5"><a href="#참고-var-키워드로-선언된-변수의-문제점-ES5" class="headerlink" title="[참고] var 키워드로 선언된 변수의 문제점(ES5)"></a>[참고] var 키워드로 선언된 변수의 문제점(ES5)</h3><p>전역 변수로 인해서 의도치 않은 변수의 변경이 발생할 가능성이 높다.<br>ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.</p>
<a id="more"></a>
<h4 id="1-Function-level-scope"><a href="#1-Function-level-scope" class="headerlink" title="1.Function-level scope"></a>1.Function-level scope</h4><ul>
<li>전역 변수의 남발</li>
<li>for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum:'</span>, sum); <span class="comment">// sum: 45</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'i:'</span>, i); <span class="comment">// i: 10</span></span><br></pre></td></tr></table></figure>
<p><strong>문제점:</strong><br>var로 선언한 변수는 if나 for같은 block-level이 아닌 function-level에서 범위가 정해지기 때문에 i의 값은 for문이 끝나도 유지된다.</p>
<h4 id="2-var-키워드-생략-허용"><a href="#2-var-키워드-생략-허용" class="headerlink" title="2.var 키워드 생략 허용"></a>2.var 키워드 생략 허용</h4><ul>
<li>의도하지 않은 변수의 전역화</li>
</ul>
<h4 id="3-중복-선언-허용"><a href="#3-중복-선언-허용" class="headerlink" title="3.중복 선언 허용"></a>3.중복 선언 허용</h4><ul>
<li>의도하지 않은 변수값 변경</li>
</ul>
<h4 id="4-변수-호이스팅"><a href="#4-변수-호이스팅" class="headerlink" title="4.변수 호이스팅"></a>4.변수 호이스팅</h4><ul>
<li>변수를 선언하기 전에 참조가 가능하다.</li>
</ul>
<h2 id="변수-호이스팅-Hoisting-이란"><a href="#변수-호이스팅-Hoisting-이란" class="headerlink" title="변수 호이스팅(Hoisting)이란?"></a>변수 호이스팅(Hoisting)이란?</h2><p>변수 Hoisting이란 var 키워드를 사용하여 변수를 선언 시,<br>해당 변수가 속한 범위(scope) 최상단으로 올려버리는 현상을 일컽습니다.<br>그리고 주목할 점은 여기서 속한 범위는 다른 언어처럼 block 레벨이 아니라 function 레벨이라는 점입니다.</p>
<h5 id="1-선언-단계-VO-Variable-Object"><a href="#1-선언-단계-VO-Variable-Object" class="headerlink" title="1.선언 단계 VO(Variable Object)"></a>1.선언 단계 VO(Variable Object)</h5><ul>
<li>변수객체(VO)에 변수를 등록한다.</li>
</ul>
<h5 id="2-초기화"><a href="#2-초기화" class="headerlink" title="2.초기화"></a>2.초기화</h5><ul>
<li>변수객체(VO)에 등록된 변수를 메모리에 할당된다. </li>
<li>이 단계에서 변수는 undefined로 초기화된다.</li>
</ul>
<h5 id="3-할당단계"><a href="#3-할당단계" class="headerlink" title="3.할당단계"></a>3.할당단계</h5><ul>
<li>undefined로 초기화된 변수에 실제값을 할당한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ① undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ② 123 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// ③ 456</span></span><br></pre></td></tr></table></figure>
<p>①에서는 변수가 선언되지 않았지만 referenceErorr가 아닌 undefined가 출력된다.</p>
<p>② var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.<br>즉, 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다.</p>
<p>①이 실행되기 이전에 var foo = 123;이 호이스팅되어 ①구문 앞에 var foo;가 옮겨진다.</p>
<p>블럭 내의 변수 foo는 전역변수이므로 전역에 선언된 변수 foo에 할당된 값을 재할당하기 때문에 ③의 결과는 456이 된다.</p>
<h3 id="변수-선언과-메모리-확보"><a href="#변수-선언과-메모리-확보" class="headerlink" title="변수 선언과 메모리 확보"></a>변수 선언과 메모리 확보</h3><h3 id="var-num"><a href="#var-num" class="headerlink" title="var num;"></a>var num;</h3><ul>
<li>변수의 선언과 초기화</li>
<li>현재 값은 undefined;</li>
<li>num은 메모리의 주소 값을 가리키고 있다.(=<strong>참조</strong>) </li>
</ul>
<h3 id="num-10"><a href="#num-10" class="headerlink" title="num = 10;"></a>num = 10;</h3><ul>
<li>변수 값의 할당</li>
</ul>
<h3 id="num-1000"><a href="#num-1000" class="headerlink" title="num = 1000;"></a>num = 1000;</h3><ul>
<li>변수 값의 재할당</li>
<li>다른 메모리에 값을 넣어두고, num이 해당하는 메모리의 주소를 참조하도록 한다.</li>
</ul>
<h3 id="유효범위-scope"><a href="#유효범위-scope" class="headerlink" title="유효범위(scope)"></a>유효범위(scope)</h3><p>유효범위는 변수의 수명<br>1.함수 레벨 스코프(function-level scope)</p>
<ul>
<li>함수내부 어디에서든지 myScope를 출력할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionLevelScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> myScope = <span class="string">"function level scope"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(myScope);</span><br><span class="line">&#125;</span><br><span class="line">출력 : <span class="function"><span class="keyword">function</span> <span class="title">leve</span> <span class="title">scope</span></span></span><br></pre></td></tr></table></figure>
<p>2.블록 레벨 스코프(block-level scope)<br>ES6에서 let, const 키워드는 블록 레벨 스코프 변수를 만들어 준다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blockLevelScope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> myScope = <span class="string">"block level scope"</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(myScope);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(myScope);</span><br><span class="line">&#125;</span><br><span class="line">출력: 에러(myScope는 <span class="keyword">if</span>문안에서만 유효하다)</span><br></pre></td></tr></table></figure>
<h3 id="기본자료형-Primitive-Data-Type"><a href="#기본자료형-Primitive-Data-Type" class="headerlink" title="기본자료형(Primitive Data Type)"></a>기본자료형(Primitive Data Type)</h3><ul>
<li>변경 불가능한 값(immutable)</li>
<li><strong>pass-by-value</strong></li>
</ul>
<p>[참고] pass-by-value 란?<br>var x = 10; var num = x;<br>num에게 x의 참조 정보를 주지 않고, 10값을 복사해서 새로운 메모리에 저장한 후에 num이 10의 주소값을 참조하도록 한다.</p>
<h3 id="6가지-기본자료형"><a href="#6가지-기본자료형" class="headerlink" title="6가지 기본자료형"></a>6가지 기본자료형</h3><h3 id="boolean-null-undefined-Number-String-Symbol"><a href="#boolean-null-undefined-Number-String-Symbol" class="headerlink" title="boolean, null, undefined, Number, String, Symbol"></a>boolean, null, undefined, Number, String, Symbol</h3><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><ul>
<li>논리적인 요소</li>
<li>true(1), false(0)</li>
</ul>
<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><ul>
<li>의도적으로 기본형 또는 object형 변수에 값이 없다는 것을 명시한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo; </span><br><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>; </span><br><span class="line">** 기존값(<span class="literal">undefined</span>)의 참조 정보(address)가 제거된다.**</span><br></pre></td></tr></table></figure>
<ul>
<li>null은 0 또는 false이다.</li>
</ul>
<p><strong>[참고] 자바스크립트 설계상의 오류</strong><br>null은 기본 자료형이지만, typeof는 object이다.<br>따라서 null로 자료형을 비교할 때는 typeof가 아닌 일치 연산자(===)를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo === <span class="literal">null</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">null</span>);        <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><ul>
<li>선언만 되어 있는 변수의 초기값</li>
<li>선언은 되었지만 할당된 적이 없는 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우, 오류 대신에 undefined가 출력된다.(javascript만)</li>
</ul>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul>
<li>정수, 실수</li>
<li>+/- Infinity 무한대</li>
<li>NaN(not a number)</li>
<li>정수만을 표현하기 위한 특별한 자료형은 없다.</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul>
<li>문자열</li>
<li>홀따옴표 권장(‘’) ex) ‘He is called “John”‘ </li>
<li>변경 불가능(immutable)</li>
</ul>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><ul>
<li>Symbol은 ES6에서 새롭게 추가된 7번째 타입이다. </li>
<li>Symbol은 애플리케이션 전체에서 유일하며 변경 불가능한(immutable) 기본 자료형(primitive)이다.</li>
</ul>
<h2 id="객체형-Object-type-참조형"><a href="#객체형-Object-type-참조형" class="headerlink" title="객체형(Object type, 참조형)"></a>객체형(Object type, 참조형)</h2><ul>
<li>pass by reference</li>
<li>내일모레설명.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dataType, variable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[자바스크립트 소개와 기본 규칙]]></title>
      <url>/2017/09/25/TIL-0925/</url>
      <content type="html"><![CDATA[<h1 id="자바스크립트-소개"><a href="#자바스크립트-소개" class="headerlink" title="자바스크립트 소개"></a>자바스크립트 소개</h1><ul>
<li>javascript는 <strong>인터프리터</strong> 언어이기 때문에 컴파일이 필요없다.</li>
<li>javaScript는 멀티-패러다임 언어로 명령형 (imperative), 함수형 (functional), <strong>프로토타입</strong> 기반 (prototype-based) 객체지향형 언어다. </li>
<li>구글의 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경(Runtime Environment)인 Node.js의 등장으로 JavaScript는 웹 브라우저를 벗어나 서버 사이드 어플리케이션 개발에서도 사용되는 Full stack 개발 언어가 되었다. </li>
<li>javascript는 <strong>크로스 플랫폼</strong>을 위한 모바일 웹/앱 개발 분야에서도 가장 중요한 언어로 주목받고 있다. 웹은 물론 모바일 하이브리드 앱(PhoneGap, Sencha Touch, Ionic), 서버 사이드(NodeJS), Desktop(Electron, AppJS), 로봇 제어(Cylon.js, NodeBots) 언어로서 세계에서 가장 인기있는 언어이다.</li>
</ul>
<a id="more"></a>
<h3 id="프로토타입-기반"><a href="#프로토타입-기반" class="headerlink" title="프로토타입 기반"></a>프로토타입 기반</h3><p>클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 프로토타입 기반 프로그래밍은 클래스가 없고 객체를 원형으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다.<br>자바스크립트는 클래스와 상속 개념은 없지만 비슷한 프로토타입 개념이 존재 한다.</p>
<h3 id="크로스-플랫폼"><a href="#크로스-플랫폼" class="headerlink" title="크로스 플랫폼"></a>크로스 플랫폼</h3><p>멀티 플랫폼이라고도 하며, 프로그램들을 하드웨어와 OS 상관없이 둘 이상의 플랫폼에서 실행할 수 있는 것을 말한다.<br>예전에 플랫폼은 특정 컴퓨터 시스템에 특정 프로그램만 실행이 가능했지만, 요즘은 특정 하드웨어나 OS에 상관없이 프로그램을 사용 가능하도록 발전하였다. 이러한 프로그램이나 소프트웨어를 지칭하여 크로스 플랫폼이라고 한다.</p>
<h1 id="자바스크립트-역사"><a href="#자바스크립트-역사" class="headerlink" title="자바스크립트 역사"></a>자바스크립트 역사</h1><ul>
<li>1995년 Javascript는 Brendan Eich가 초기 브라우저인 넷스케이프에 탑재하기 위해서 웹페이지에 포함되는 스크립트 언어로서 개발했다.</li>
<li>인터넷 익스플로러도 JScript라고 이름 붙인 자바스크립트를 지원하기 시작했다. 두 언어가 분화되는 것을 막기 위해 넷스케이프는 자바스크립트 표준화를 Ecma라는 국제 표준 단체로 넘겼다.</li>
<li>javaScript는 상표명이기 때문에 상표 분쟁을 막기 위해 Ecma에 등록된 자바스크립트의 이름은 EcmaScript가 되었다.</li>
<li>2015년 6월에 ECMAScript의 6번째 명세인 ECMAScript 2015(이하 ES6)가 발표됐고, let/const keyword, module system, Arrow Function, class 등이 추가되었다. </li>
<li>7번째 명세인 ECMAScript 2016(이하 ES7)이 2016년 6월에 발표되었다.</li>
</ul>
<h1 id="브라우저-지원"><a href="#브라우저-지원" class="headerlink" title="브라우저 지원"></a>브라우저 지원</h1><ul>
<li>모던 브라우저의 ES6 지원은 97%로 거의 100%에 육박하지만 IE 지원을 고려한다면 babel과 같은 Transpiler를 사용하여야 한다.</li>
</ul>
<h1 id="자바스크립트-용어와-기본규칙"><a href="#자바스크립트-용어와-기본규칙" class="headerlink" title="자바스크립트 용어와 기본규칙"></a>자바스크립트 용어와 기본규칙</h1><h3 id="1-구문-statement"><a href="#1-구문-statement" class="headerlink" title="1. 구문(statement)"></a>1. 구문(statement)</h3><ul>
<li>값, 연산자, 표현식, 키워드, 주석으로 구성되는 한줄의 명령.</li>
<li>세미콜론(;)으로 끝나는 영역.</li>
</ul>
<h3 id="2-코드블록-code-block"><a href="#2-코드블록-code-block" class="headerlink" title="2. 코드블록(code block)"></a>2. 코드블록(code block)</h3><ul>
<li>구문(statement)을 코드블록으로 그룹화할 수 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y; <span class="comment">// 구문</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-할당연산자-assign"><a href="#3-할당연산자-assign" class="headerlink" title="3. 할당연산자(assign, =)"></a>3. 할당연산자(assign, =)</h3><p>Ex) var x = 6;</p>
<ul>
<li>메모리(x)에 값(6)을 저장한다는 의미.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="number">10</span>; <span class="comment">// 변수 선언과 할당</span></span><br><span class="line"><span class="keyword">var</span> greeting; <span class="comment">// 변수 선언</span></span><br></pre></td></tr></table></figure>
<h3 id="4-흐름제어-Control-Flow"><a href="#4-흐름제어-Control-Flow" class="headerlink" title="4. 흐름제어(Control Flow)"></a>4. 흐름제어(Control Flow)</h3><ul>
<li>조건문, 반복문</li>
<li>조건이 참이면 해당 구문을 실행하고, 거짓이면 실행하지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (time &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  greeting = <span class="string">'Good morning'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (time &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  greeting = <span class="string">'Good day'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  greeting = <span class="string">'Good evening'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-변수-variable"><a href="#5-변수-variable" class="headerlink" title="5. 변수(variable)"></a>5. 변수(variable)</h3><ul>
<li>var 라고 쓴다.</li>
<li>자바스크립트에서는 정해진 변수 타입이 없다.</li>
<li>즉, var로 문자열, 문자, 숫자, 객체 모든 타입을 선언할 수 있다.</li>
<li>값을 할당, 참조하기 위해 사용된다.</li>
<li>Typescript는 javascript에서 데이터 타입이 없는 것과 다르게 데이터 타입은 선언할 수 있다.</li>
</ul>
<h2 id="자바스크립트-기본-규칙"><a href="#자바스크립트-기본-규칙" class="headerlink" title="자바스크립트 기본 규칙"></a>자바스크립트 기본 규칙</h2><ul>
<li>문자열은 홀 따옴표를 사용한다.(‘hello’)</li>
<li>자바스크립트는 아래 7가지 데이터 타입을 제공한다.(기본자료형6개 + 객체)</li>
<li>기본자료형(primitive data type) : Boolean, null, undefined, Number, String, Symbol(ES6에서 추가)</li>
<li>객체형 : Objcet</li>
</ul>
<h2 id="참고-null과-undefined의-차이"><a href="#참고-null과-undefined의-차이" class="headerlink" title="[참고] null과 undefined의 차이"></a>[참고] null과 undefined의 차이</h2><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><ul>
<li>null이라는 값을 가진다. </li>
<li>null은 객체 타입(자바스크립트 설계상 오류)으로 문자열일 경우 ‘’, 숫자의 경우 ‘0’과 같다.</li>
</ul>
<h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h4><ul>
<li>변수가 정의되었지만 값이 할당되지 않은 상태</li>
<li>ex) var foo; </li>
</ul>
<h2 id="참고-javascript-삽입-방식과-위치"><a href="#참고-javascript-삽입-방식과-위치" class="headerlink" title="[참고] javascript 삽입 방식과 위치"></a>[참고] javascript 삽입 방식과 위치</h2><p>간단한 스크립트일 경우 또는 해당 문서에만 적용되는 경우 HTML문서안에 스크립트 소스를 배치한다. 그러나 반복 사용되는 코드일 경우 파일별로 저장해두고 필요에 따라 링크해서 사용한다.</p>
<h3 id="자바스크립트-링크태그-삽입-위치"><a href="#자바스크립트-링크태그-삽입-위치" class="headerlink" title="자바스크립트 링크태그 삽입 위치"></a>자바스크립트 링크태그 삽입 위치</h3><h4 id="lt-head-gt-에-삽입되는-경우"><a href="#lt-head-gt-에-삽입되는-경우" class="headerlink" title="&lt;head&gt;에 삽입되는 경우"></a><code>&lt;head&gt;</code>에 삽입되는 경우</h4><ul>
<li>defer 속성은 HTML 구문 분석이 완전히 완료되면 스크립트 파일을 실행하도록 브라우저에 지시한다.</li>
<li>IE8이하는 지원하지 않으므로 두번째 경우를 사용하도록 한다. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  ...생략...</span><br><span class="line">  &lt;title&gt;메인 페이지&lt;/title&gt;</span><br><span class="line">  &lt;script defer src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>
<h4 id="lt-body-gt-앞에-삽입되는-경우"><a href="#lt-body-gt-앞에-삽입되는-경우" class="headerlink" title="&lt;/body&gt;앞에 삽입되는 경우"></a><code>&lt;/body&gt;</code>앞에 삽입되는 경우</h4><ul>
<li>문서의 DOM 로드가 완료된 시점에 javascript 로드가 실행된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  ...생략...</span><br><span class="line">  &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Javascript, 인터프리터, 객체지향언어 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css3 animation]]></title>
      <url>/2017/09/24/TIL-0924/</url>
      <content type="html"><![CDATA[<h3 id="CSS3-animation"><a href="#CSS3-animation" class="headerlink" title="CSS3 animation"></a>CSS3 animation</h3><h4 id="keyframes-규칙"><a href="#keyframes-규칙" class="headerlink" title="@keyframes 규칙"></a>@keyframes 규칙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@keyframes animation명&#123;</span><br><span class="line">    0% 또는 from&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    100% 또는 to&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="keyframes에-설정한-animation-사용하기"><a href="#keyframes에-설정한-animation-사용하기" class="headerlink" title="keyframes에 설정한 animation 사용하기"></a>keyframes에 설정한 animation 사용하기</h4><p>animaiton: 이름 진행시간 가속도 지연시간 반복횟수 연결방향;<br>animation: txt-ani 4s 2s infinite alterante;</p>
<h4 id="animation-속성"><a href="#animation-속성" class="headerlink" title="animation 속성"></a>animation 속성</h4><p>animation-delay : 애니메이션 로드 후 언제 다시 시작할지 지정한다.</p>
<p>animation-direction : 애니메이션이 종료되고 다시 처음부터 시작할지 역방향으로 진행할지 지정.<br>ex) normal,reverse,alternate,alternate-reverse,initial,inherit</p>
<p>animation-duration :애니메이션이 진행시간 (1초 = 1s 으로 표시) </p>
<p>animation-iteration-count :반복횟수 지정 (infinite : 계속반복) </p>
<p>animation-name<br>: 애니메이션이름<br>@keyframes 애니메이션이름{}으로 쓰임</p>
<p>animation-play-state<br>: 애니메이션 시작 또는 정지 상태<br>기본적으로 사용되는 것들 : running , paused</p>
<p>animation-timing-function<br>: 애니메이션 속도(가속/감속 시간간격등 설정)<br>기본적으로 사용되는 것들 : linear,ease,ease-in,ease-out,ease-in-out,step-start,step-end,steps(int,start|end),cubic-bezier(n,n,n,n),initial,inherit </p>
<p>animation-fill-mode<br>: 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정합니다.<br>애니메이션이 끝난후 처음상태로? 끝난 상태로?<br>기본적으로 사용되는 것들 : none,forwards,backwards,both,initial,inherit</p>
<p>몇가지 속성은 선택자의 display 속성이 block이어야만 작동한다.<br>inline일 경우에는 block을 적용한 후, 속성을 작성해야 한다.</p>
<p>translate() </p>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css3, animation </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[반응형웹과 css3]]></title>
      <url>/2017/09/21/TIL-0921/</url>
      <content type="html"><![CDATA[<p>viewport breakpoint는 통계자료를 확인해서 분기한다.</p>
<h3 id="반응형웹-RWD"><a href="#반응형웹-RWD" class="headerlink" title="반응형웹(RWD)"></a>반응형웹(RWD)</h3><p>모바일~ 태블릿 ~데스크탑 </p>
<h3 id="적응형웹-AWD"><a href="#적응형웹-AWD" class="headerlink" title="적응형웹(AWD)"></a>적응형웹(AWD)</h3><p>모바일 / 데스크탑<br>참조 : <a href="http://naradesign.net/wp/2012/05/30/1823/" target="_blank" rel="noopener">naradesign</a><br><a id="more"></a></p>
<h3 id="background-size-속성-익스9이상-지원"><a href="#background-size-속성-익스9이상-지원" class="headerlink" title="background-size 속성 (*익스9이상 지원)"></a>background-size 속성 (*익스9이상 지원)</h3><p>background-size:auto</p>
<ul>
<li>이미지가 원래 사이즈로 배치된다.</li>
<li>이미지가 크면 이미지 일부만 보일 수도 있다.<br>background-size:cover</li>
<li>이미지 비율을 맞춘 상태로 너비 높이 중에 큰 값에 맞추는 속성이다.</li>
<li>이미지의 일부가 보이지 않을 수도 있다.<br>background-size:contain</li>
<li>원하는 영역에 전체 이미지가 들어가도록 비율에 맞게 배치된다.</li>
<li>이미지가 잘리지 않는다. 원하는 영역에 꽉 차진 않지만 비율에 맞게 배치된다.</li>
</ul>
<p>장식용 이미지</p>
<ul>
<li>마크업에 이미지 넣어서(IR기법) 빈 태그로 활용한 경우</li>
<li>alt=”” 빈 속성으로 처리한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;이미지경로&quot; alt=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>복잡한 포털성 컨텐츠 -&gt; 반응형 적용이 어렵다.</p>
<h3 id="반응형-이미지-처리"><a href="#반응형-이미지-처리" class="headerlink" title="반응형 이미지 처리"></a>반응형 이미지 처리</h3><p>-부모 요소 크기에 맞게 늘어나도록 한다. (비율 유지)<br>flexible img {max-width:100%; height:auto}</p>
<h3 id="srcset-sizes-반응형웹-이미지-속성"><a href="#srcset-sizes-반응형웹-이미지-속성" class="headerlink" title="srcset, sizes 반응형웹 이미지 속성"></a>srcset, sizes 반응형웹 이미지 속성</h3><ul>
<li>여러 스크린별 사이즈를 제어하기 위해서 사용하는 속성이다.</li>
<li>뷰포트에 따라서 보이는 이미지를 다르게 적용한다.</li>
<li>모바일용으로만 만들때 사용한다.</li>
<li>IE 11 버전부터 지원</li>
</ul>
<h4 id="사용방식"><a href="#사용방식" class="headerlink" title="사용방식"></a>사용방식</h4><p>img src=”bird-wide.jpg” srcset=”bird-wide.jpg 640w, bird-narrow 320w” sizes=”(min-width:640px) 50vw, 100vw” alt=”날고있는새”</p>
<ul>
<li>sizes 속성 : 뷰포트가 640px이상일 경우, 뷰포트 사이즈의 50%만 지정합니다.  </li>
</ul>
<p>picture element - 익스11지원안함(picturefill로 대응가능)<br>-반응형웹만들때 사용<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;picture&gt;</span><br><span class="line">&lt;source media=&quot;&quot; srcset=&quot;&quot;&gt;</span><br><span class="line">&lt;img&gt;- picture , source 인식하지못할때 대비(속성은 위참고)</span><br><span class="line">&lt;/picture&gt;</span><br><span class="line">http://www.usefulparadigm.com/2014/11/03/processing-images-on-responsive-web/ </span><br><span class="line">참고해서 다시 정리</span><br></pre></td></tr></table></figure></p>
<h3 id="display-flex-버그"><a href="#display-flex-버그" class="headerlink" title="display:flex 버그"></a>display:flex 버그</h3><ol>
<li>크롬에서 Form요소에 flex 속성이 안먹힌다.</li>
<li>파이어폭스에서 fieldset 하위 요소가 block level 일때 flex가 안먹힌다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 크롬 버그 */</span><br><span class="line">/* fieldset 하위 요소가 inline level이므로, 파이어폭스에서는 잘 된다. */</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;검색 폼&lt;/legend&gt;</span><br><span class="line">        &lt;label for=&quot;keyward&quot;&gt;자료검색&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;search&quot; id=&quot;keyward&quot; required placeholder=&quot;검색어를 입력하세요.&quot;&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot; class=&quot;btn-search&quot;&gt;검색&lt;/button&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">fieldset &#123; </span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="해결법"><a href="#해결법" class="headerlink" title="해결법"></a>해결법</h3><p>-&gt; 버그 상태에서 flex를 사용하고 싶을때는 div로 묶어주고 해당영역에 flex 속성을 적용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;div class=&quot;flex-container&quot;&gt; /*div로 감싼다*/</span><br><span class="line">            &lt;legend&gt;검색 폼&lt;/legend&gt;</span><br><span class="line">            &lt;label for=&quot;keyward&quot;&gt;자료검색&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;search&quot; id=&quot;keyward&quot; required placeholder=&quot;검색어를 입력하세요.&quot;&gt;</span><br><span class="line">            &lt;button type=&quot;submit&quot; class=&quot;btn-search&quot;&gt;검색&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">.flex-container &#123; </span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 반응형웹, 미디어쿼리, css3 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[웹접근성 기술 WAI-ARIA]]></title>
      <url>/2017/09/19/TIL-0919/</url>
      <content type="html"><![CDATA[<h1 id="WAI-ARIA의-목적"><a href="#WAI-ARIA의-목적" class="headerlink" title="WAI-ARIA의 목적"></a>WAI-ARIA의 목적</h1><p>마크업에 역할, 속성, 상태 정보를 추가하여 스크린기기 및 보조 기기에서 접근성 및 상호 운용성을 향상시키고 보다 나은 사용자 경험을 제공하기 위함이다.</p>
<a id="more"></a>
<h1 id="ARIA의-기능-역할-Role"><a href="#ARIA의-기능-역할-Role" class="headerlink" title="ARIA의 기능 - 역할(Role)"></a>ARIA의 기능 - 역할(Role)</h1><ul>
<li>특정 요소(Element)에 역할을 정의하는것</li>
</ul>
<h2 id="역할-Role-작성-규칙"><a href="#역할-Role-작성-규칙" class="headerlink" title="역할(Role) 작성 규칙"></a>역할(Role) 작성 규칙</h2><h3 id="HTML5-섹션-관련-요소와-ARIA-Role"><a href="#HTML5-섹션-관련-요소와-ARIA-Role" class="headerlink" title="HTML5 섹션 관련 요소와 ARIA Role"></a>HTML5 섹션 관련 요소와 ARIA Role</h3><p>HTML5섹션을 div로 마크업할 때, div 요소에 역할(role)을 정의해준다.</p>
<table>
<thead>
<tr>
<th>Landmark Role</th>
<th>HTML5 섹션 관련 요소</th>
</tr>
</thead>
<tbody>
<tr>
<td>div role=”banner”</td>
<td>header</td>
</tr>
<tr>
<td>div role=”navigation”</td>
<td>nav</td>
</tr>
<tr>
<td>div role=”main”</td>
<td>main</td>
</tr>
<tr>
<td>div role=”complementary”</td>
<td>aside</td>
</tr>
<tr>
<td>role=”form”</td>
<td>form</td>
</tr>
<tr>
<td>role=”contentinfo”</td>
<td>footer</td>
</tr>
<tr>
<td>div role=”alertdialog”</td>
<td>대화상자, 팝업</td>
</tr>
<tr>
<td>role=”button”</td>
<td>버튼</td>
</tr>
</tbody>
</table>
<h1 id="ARIA의-기능-속성-Properties-상태-States"><a href="#ARIA의-기능-속성-Properties-상태-States" class="headerlink" title="ARIA의 기능 - 속성(Properties), 상태(States)"></a>ARIA의 기능 - 속성(Properties), 상태(States)</h1><ul>
<li>요소(Element)가 기본적으로 갖고 있는 특징이나 상황</li>
<li>‘aria - *’ 접두어를 가진다.</li>
</ul>
<h2 id="속성-Properties-작성-규칙"><a href="#속성-Properties-작성-규칙" class="headerlink" title="속성(Properties) 작성 규칙"></a>속성(Properties) 작성 규칙</h2><table>
<thead>
<tr>
<th>속성(Properties)</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>input aria-required=”true”</td>
<td>필수 항목 속성</td>
</tr>
<tr>
<td>input aria-label=”그룹제목”</td>
<td>그룹 제목 속성(그룹에 대한 제목정의)</td>
</tr>
<tr>
<td>input aria-labeledby=”참조그룹ID”</td>
<td>label for과 비슷한 역할의 속성 </td>
</tr>
<tr>
<td>input aria-describedby=”reference”</td>
<td>추가 설명 속성(경고텍스트)</td>
</tr>
<tr>
<td>aria-hidden=”true”</td>
<td>읽지않음</td>
</tr>
</tbody>
</table>
<h2 id="상태-State-작성-규칙"><a href="#상태-State-작성-규칙" class="headerlink" title="상태(State) 작성 규칙"></a>상태(State) 작성 규칙</h2><table>
<thead>
<tr>
<th>상태(State)</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>aria-expanded=”true”</td>
<td>확장되어 있는 상태의 탭패널</td>
</tr>
<tr>
<td>aria-invalid=”true”</td>
<td>오류가 발생한 상태의 입력상자</td>
</tr>
</tbody>
</table>
<h2 id="ARIA-사용시-주의할점"><a href="#ARIA-사용시-주의할점" class="headerlink" title="ARIA 사용시 주의할점"></a>ARIA 사용시 주의할점</h2><ol>
<li>ARIA Role과 HTML5를 중복해서 사용하지 않는다.</li>
<li>HTML Element의 기능 변경이 제한된다.<br>ex) h1 role=”button” - 원래의 의도를 바꿔쓴 잘못된 예 </li>
<li>키보드 접근이 보장되어야 한다.<br>ex) div role=”button” tabindex=”0”</li>
<li>div 태그로만 구성된 코드를 개선하기 위해 사용한다.</li>
</ol>
<h2 id="웹접근성-미준수-개선방법"><a href="#웹접근성-미준수-개선방법" class="headerlink" title="웹접근성 미준수 개선방법"></a>웹접근성 미준수 개선방법</h2><h3 id="1-로그인-화면에서-경고텍스트를-읽지-않는-경우"><a href="#1-로그인-화면에서-경고텍스트를-읽지-않는-경우" class="headerlink" title="1.로그인 화면에서 경고텍스트를 읽지 않는 경우"></a>1.로그인 화면에서 경고텍스트를 읽지 않는 경우</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;label for=&quot;user-id&quot;&gt;아이디&lt;/label&gt;</span><br><span class="line">&lt;input id=&quot;user-id&quot; aria-describedby=&quot;msg&quot;&gt;</span><br><span class="line">&lt;span id=&quot;msg&quot;&gt;이미 존재하는 아이디 입니다.&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-CSS-IR기법을-이용한-태그-또는-빈-태그일-경우"><a href="#2-CSS-IR기법을-이용한-태그-또는-빈-태그일-경우" class="headerlink" title="2. CSS IR기법을 이용한 태그 또는 빈 태그일 경우"></a>2. CSS IR기법을 이용한 태그 또는 빈 태그일 경우</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;#&quot;&gt;&lt;span role=&quot;img&quot; aria-label=&quot;대체텍스트-Connect via Facebook&quot;&gt;&lt;/span&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> WAI-ARIA, 웹접근성 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GIT 기초 정리]]></title>
      <url>/2017/09/17/TIL-0917/</url>
      <content type="html"><![CDATA[<p>로컬PC 작업 파일을 원격 저장소로 올리려면<br>1)add 2)commit 3)push 명령을 사용해야 한다.</p>
<p><img src="../images/git1.jpg" alt="git process"></p>
<a id="more"></a>
<p>1) 작업공간(local directory)에서 add 명령어를 통해 stage에 반영한다.<br>2) commit 명령어를 통해 저장소에 반영한다.stage에 올렸던 데이터를 확정하는 단계이다.<br>여기까지는 중간 단계로 원격 저장소에 파일이 반영되지 않고,<br>내 PC에 있는 Git 로컬 저장소에만 존재한다.<br>3) push 명령어를 통해 원격 저장소에 반영한다.<br>git clone을 통해 원격 저장소의 파일을 읽어와서 작업했을 때,<br>$git push origin “push할 브랜치 이름”<br>ex) $git push origin master<br>원격 저장소를 정의해야 할 때,<br>$git remote add “원격저장소명 원격저장소주소”<br>ex) $git remote add origin <a href="http://github.com/" target="_blank" rel="noopener">http://github.com/</a>…</p>
<h3 id="Repository-생성방법-1"><a href="#Repository-생성방법-1" class="headerlink" title="Repository 생성방법(1)"></a>Repository 생성방법(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$mkdir 디렉토리명</span><br><span class="line">$git init</span><br><span class="line">$git remote add origin 원격저장소주소</span><br></pre></td></tr></table></figure>
<h3 id="Repository-생성방법-2"><a href="#Repository-생성방법-2" class="headerlink" title="Repository 생성방법(2)"></a>Repository 생성방법(2)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">github.com 웹에서 repository 생성</span><br><span class="line">$git add 파일명</span><br><span class="line">$git commit -m &quot;메세지&quot;</span><br><span class="line">$git remote add origin 원격저장소주소</span><br><span class="line">$git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="갱신"><a href="#갱신" class="headerlink" title="갱신"></a>갱신</h3><pre><code>$git pull
</code></pre><p>원격 저장소의 변경내용이 로컬 작업 디렉토리에 받아지고(fetch) 병합(merge)된다.</p>
]]></content>
      
        <categories>
            
            <category> TIL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
