{"meta":{"title":"FRONT.DEV.MK","subtitle":null,"description":null,"author":"Min Kyung","url":"http://mkfdev.github.io"},"pages":[{"title":"categories","date":"2017-12-06T17:01:54.000Z","updated":"2017-12-07T17:55:17.300Z","comments":true,"path":"categories/index.html","permalink":"http://mkfdev.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"실행 컨텍스트와 클로저","slug":"TIL-1012","date":"2017-10-12T12:43:20.000Z","updated":"2017-12-17T15:48:35.106Z","comments":true,"path":"2017/10/12/TIL-1012/","link":"","permalink":"http://mkfdev.github.io/2017/10/12/TIL-1012/","excerpt":"실행 컨텍스트(Execution Context) 실행 가능한 코드가 실행되는 환경이다. 실행 가능한 코드 : 전역코드, Eval코드(안씀), 함수코드(호출) 변수와 함수가 호출되기 위한 환경이 만들어진다. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 정보를 알고 있으며, 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 실행에 필요한 정보 : 변수(객체의 프로퍼티, 전역변수, 지역변수, 매개변수), 함수선언(함수명, 함수), 변수의 유효범위(전역이냐 지역이냐), this(가리키고 있는 객체) 실행 컨텍스트 스택(=콜 스택) 실행 컨텍스트가 생성되서 쌓이는 영역 전역 실행 컨텍스트, 함수 실행 컨텍스트가 생성되면 실행 컨텍스트 스택에 쌓인다. 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며, 함수가 끝나면 해당 함수의 실행 컨텍스트가 사라진다.","text":"실행 컨텍스트(Execution Context) 실행 가능한 코드가 실행되는 환경이다. 실행 가능한 코드 : 전역코드, Eval코드(안씀), 함수코드(호출) 변수와 함수가 호출되기 위한 환경이 만들어진다. 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 정보를 알고 있으며, 실행 컨텍스트를 물리적 객체의 형태로 관리한다. 실행에 필요한 정보 : 변수(객체의 프로퍼티, 전역변수, 지역변수, 매개변수), 함수선언(함수명, 함수), 변수의 유효범위(전역이냐 지역이냐), this(가리키고 있는 객체) 실행 컨텍스트 스택(=콜 스택) 실행 컨텍스트가 생성되서 쌓이는 영역 전역 실행 컨텍스트, 함수 실행 컨텍스트가 생성되면 실행 컨텍스트 스택에 쌓인다. 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며, 함수가 끝나면 해당 함수의 실행 컨텍스트가 사라진다. 실행 컨텍스트 3가지 객체 Variable Object(VO), Scope Chain(SC), this value Variable Object 변수(함수표현식 포함), 매개변수와 인수, 함수선언의 정보를 담는 객체로 유일하며 최상위에 위치한 객체이다. 전역 컨텍스트의 VO는 전역객체(GO)를 가리키고, 함수 컨텍스트의 VO는 활성객체(AO)를 가리킨다. 전역 객체(GO)는 전역에 선언된 전역 변수, 전역 함수를 프로퍼티로 소유한다. 활성 객체(AO)는 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 arguments객체가 추가된다. 전역 객체(Global Object)는 1개 생성, 활성객체(Activation Object)는 여러개 생성이 가능하다. Scope Chain 스코프 체인은 일종의 리스트로서 중첩된 함수의 레퍼런스를 저장하고 있다. 마지막 리스트는 항상 전역 객체(GO)를 가리킨다. 함수 실행 컨텍스트의 스코프 체인의 경우, 레퍼런스로 자기 자신의 AO와 GO를 가리킨다. 스코프 체인(리스트)을 검색하면 함수가 중첩 상태일 때, 하위함수 내에서 상위함수의 유효 범위까지 참조할 수 있게 된다. this value this의 값이 할당된다. 함수 호출 패턴에 의해 결정된다. 전역 코드에의 진입 전역 객체 생성 컨트롤이 실행 컨텍스트에 접근하기 이전에 유일한 전역 객체(Global Object)가 생성된다. 전역 객체에는 빌트인 객체와 BOM, DOM이 설정되어 있다. 실행 컨텍스트 생성 후 스택 전역 코드로 컨트롤이 진입하면 실행 컨텍스트가 생성된 후, 실행 컨텍스트 스택에 쌓인다. 스코프 체인(SC)의 생성과 초기화 전역 객체의 레퍼런스를 포함하는 리스트가 된다. Variable Instantiation(변수 객체화) 실행 Variable Instantiation은 VO에 프로퍼티와 값을 추가하는 것이다. 변수, 매개변수, 인수정보(arguments), 함수선언을 VO에 추가하여 객체화한다. 함수부터 변수 순으로 저장된다. 4-1. “변수 객체화의 순서” Function일 경우 매개변수(parameter)가 VO의 프로퍼티로, 인수(arguments)가 값으로 설정된다. 함수선언(함수표현식 제외)을 대상으로 함수명이 VO(VO가 가리키고 있는 객체)프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅) 변수 선언을 대상으로 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅) 함수의 선언 처리(함수가 있다면) 변수 객체화의 순서 2번처럼 함수명이 프로퍼티로, 생성된 함숫 객체(몸체)가 값으로 설정된다.(전역 함수일 경우 GO에 설정) 생성된 함수 객체는 [[Scope]] 프로퍼티를 가지게 된다. (함수 호출 실행 이전)[[Scope]]는 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정하고, (함수 실행 후)스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 함수선언식 이전에 함수를 호출할 수 있다. (함수 호이스팅) 변수의 선언 처리(변수가 있을때) 변수 객체화의 순서 3번처럼 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다. var 키워드로 선언된 변수는 선언과 초기화 단계가 한번에 이루어진다. 변수 선언문 이전에 접근해도 VO에 변수가 undefined로 초기화된 상태로 존재하기 때문에 에러가 나지 않는다.(변수 호이스팅) this value의 결정 this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다. 전역 코드의 실행 변수값 할당 변수값을 할당할 때는 VO(VO가 가리키고 있는 객체, 전역의 경우 GO)를 선두(0)부터 검색하여 해당 변수의 프로퍼티를 발견하면 값을 할당 한다. 함수 실행 함수가 실행되면 새로운 함수 실행 컨텍스트가 생성된다. 해당 함수로 실행 컨텍스트의 컨트롤이 이동하면 전역 코드와 마찬가지로 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 실행된다. 함수 코드에의 진입 전역 코드에의 진입과 순서는 같지만 다른 룰이 적용된다. 스코프 체인의 생성과 초기화 Activation Object생성** AO에 대한 레퍼런스를 스코프 체인의 선두에 설정한다. Activation Object는 arguments 프로퍼티를 초기화한다. 스코프 체인의 마지막 레퍼런스 객체는 전역 객체를 참조한다. Variable Instantiation 실행 함수 객체와 변수를 VO에 바인딩한다.(선언, 초기화) 변수의 프로퍼티는 변수명, 값은 undefined로 VO에 저장한다. 함수의 프로퍼티는 함수명, 값은 Function Object로 VO에 저장한다. Function Object의 [[scope]] 프로퍼티가 생성된다. [[scope]] 프로퍼티는 AO와 전역을 참조하는 리스트의 값을 갖는다. this value 결정 this에 할당되는 값은 함수 호출 패턴에 의해 결정된다. 함수 코드의 실행(함수에 변수가 존재할때) 변수 값의 할당 지역변수를 할당할 때(현재는 내부함수일 경우), 스코프 체인이 참조하고 있는 VO를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값을 할당한다. (해당 영역에도 없으면 스코프 체인 리스트를 참조하여 GO를 검색하도록 한다.) 내부 함수 코드의 실행 내부 함수가 실행되기 시작하면 새로운 실행 컨텍스트가 생성된다. 여기서도 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 진행된다. 클로저(closure) 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다. 외부함수가 내부함수보다 더 오래 유지되는 경우에 내부함수가 외부함수의 지역변수에 접근할 수 있고 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해 소멸하게 되는 특성을 말한다. 클로저에 의해 참조되는 외부함수의 변수를 자유변수(Free variable)이라고 부른다. (실행 컨텍스트 관점에서)내부함수가 유효한 경우에 외부함수가 종료 되면 함수의 실행 컨텍스트도 소멸하지만, 함수 실행 컨텍스트의 AO는 유효하기 때문에 내부함수가 스코프 체인을 통해 참조할 수 있다. 클로저의 활용 성능적인 면과 자원적인 면에서 손해를 볼 수 있다. (실행 컨텍스트에서) 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당되어 있기 때문에 성능 상 좋다고 할 수 없다.(최소화하며 오남용하지 않아야 한다.) 12345678910111213141516&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;Count!&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;0&lt;/p&gt;&lt;script&gt; var add = (function () &#123; var counter = 0; return function () &#123; return ++counter; &#125;; &#125;()); function myFunction() &#123; document.getElementById(&apos;demo&apos;).innerHTML = add(); &#125;&lt;/script&gt; 전역 변수의 사용 억제를 위한 방식 즉시 실행함수는 한번만 실행되므로 counter가 다시 초기화되지 않는다. 외부함수의 변수 counter는 참조하는 함수(내부함수)가 소멸될때까지 유지된다. counter는 외부에서 접근할 수 없는 private 변수이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"closure","slug":"closure","permalink":"http://mkfdev.github.io/tags/closure/"}]},{"title":"빌트인객체-2","slug":"TIL-1011","date":"2017-10-11T10:39:18.000Z","updated":"2017-12-17T15:49:13.159Z","comments":true,"path":"2017/10/11/TIL-1011/","link":"","permalink":"http://mkfdev.github.io/2017/10/11/TIL-1011/","excerpt":"Number 생성자 함수가 없는 객체는 Static 함수. new Number(value) value에 문자열이 들어갔을때, 최대한 형변환된다.(숫자가 아니면 NaN 반환) 래퍼 객체를 통해 형변환하는 것은 좋은 것이 아니다.","text":"Number 생성자 함수가 없는 객체는 Static 함수. new Number(value) value에 문자열이 들어갔을때, 최대한 형변환된다.(숫자가 아니면 NaN 반환) 래퍼 객체를 통해 형변환하는 것은 좋은 것이 아니다. Number PropertyNumber.MAX-VALUENumber.MIN-VALUE 0에 가장 가까운 양수값 Number.POSITIVE_INFINITY INFINITY 양의무한대를 가지는 상수 Number.NEGATIVE_INFINITYNumber.NaNNumber method 기본적으로 형변환을 안한다.(엄격함) prototype.메서드를 쓰지 않음. static 함수이다. Number.isFinite() 숫자이고 유한한 값 전역함수의 isNaN()과의 차이 : 형변환을 안함(엄격함) Number.isInteger() Number.isInteger(0 / 0) // NaN(Not a Number) -&gt; false Number.isNaN() 이것도 전역함수의 isNaN()과 다르게 형변환을 안함(엄격함) Number.isSafeInteger() 자바스크립트에서 사용할 수 있는 정수인지를 검사하여 boolean을 반환 Number.isSafeInteger(10000000000000001) // false Number.prototype.toExponential()Number.prototype.toFixed() 매개변수(인자)로 받은 소수점자리수만큼 반올림하고 문자열로 반환. 소수점자리수가 넘칠때는 0을 넣어준다. Number.prototype.toPrecision()Number.prototype.toString() toString(‘정수로 진법을 나타낼수있음’) Number.prototype.valueOf() Number 객체의 값(기본자료형)을 반환한다. Math 정적 메소드 Math PropertyMath.PIMath Method Math.max()]0var max = Math.max.apply(null, arr); // 3 Math.in()]0var max = Math.max.apply(null, arr); // 3 정규 표현식RegExp 생성자 함수를 이용해서 정규표현식 객체가 생성된다. (var regex=~) 배열 1개의 변수에 여러 개의 값을 순차적으로 저장할 때 사용한다. 배열은 프로퍼티 이름이 필요없고 값만 나열하면 된다.(객체와 비교) 배열 생성방식 두가지. 배열리터럴, 배열 생성자함수 배열 리터럴을 사용- var arr = []; (내부적으로는 array생성자 함수를 사용해서 객체가 생성된다.) array에서 length : 요소의갯수(index+1개)순차적인 요소로 구성할 수 있는데요소는 undefined 이외 모든 값이 들어올 수 있다. Array생성자 함수인자값을 매개변수 갯수 또는 요소로 받는다.Array생성자함수는 코딩할때 사용하지 않을것. for-in문-for문을 사용하도록 한다.(속도차이) Array 프로퍼티Array.length 배열의 길이 Array MethodArray.prototype.concat(item…) concat 할때 배열이 아니라 요소로 추가한다. Array.prototype.pop() pop : 대상 요소를 꺼낸다. push: 새로운 요소를 뒤에 추가. unshift : 새로운 요소를 앞에 추가. pop과 push는 원본 배열을 변경한다. 빼낸 요소가 return 된다. 한두번 추가할땐 arr.push(6);(가독성높음, 퍼포먼스가 떨어짐) 여러번 추가할땐 arr[arr.length]=6; 사용. 속도면에서 차이가 있음. arr.unshift(0); [0].concat(arr); 도 마찬가지로 속도차이가 있음. *웹어플리케이션에서는 사용자가 화면 전환 시간을 오래 기다리지 않는다. Array.prototype.reverse() 원본 배열이 변경 Array.prototype.slice(start, end) var res5 = items.slice(); slice() 복사본생성* Array.prototype.splice delete 비교 요소를 제거한 후, 새로운 요소를 추가 Array.prototype.splice.apply ES6 Spread연산자?[참고] this window -&gt; 메소드 내부,생성자함수 제외 중요한 메소드들Array.prototype.forEach() 대상 배열을 알아서 순회한다. 내부에서 for문을 돌린다. 각각의 배열안의 요소에 대해서 콜백 함수를 실행시켜 준다. 매개변수는 필요하면 적어준다. (item, index, array) -&gt; 원본배열의 요소(인자값이 알아서 순서대로 들어온다), index, 원본배열(자신) for문을 간편화하기 위해 만들어짐 break문을 사용할 수 없다. 콜백함수의 this는 window, var that = this; 를 이용해서 this 참조 변경 / 또는 두번째 인자값에 this 전달 Array.prototype.map() 원본 배열과 매핑되는 새로운 배열을 만들어서 반환한다. return 하지 않으면 새로운 배열에 반영되지 않는다. return 필수.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"Built-in Object, Number, Math, Array","slug":"Built-in-Object-Number-Math-Array","permalink":"http://mkfdev.github.io/tags/Built-in-Object-Number-Math-Array/"}]},{"title":"빌트인객체-1","slug":"TIL-1010","date":"2017-10-10T09:36:48.000Z","updated":"2017-12-17T15:39:54.719Z","comments":true,"path":"2017/10/10/TIL-1010/","link":"","permalink":"http://mkfdev.github.io/2017/10/10/TIL-1010/","excerpt":"Built-in ObjectHost Object 개발자가 직접 만든 객체 표준 빌트인 객체 (= Global Objects) 공통적으로 필요한 기능을 제공한다. Stinrg,Array,Object,Function,Boolean,Number,Math,Date,RegExp, 등등 대문자로 시작. 표준 빌트인 객체들은 생성자 함수이다. 표준 빌트인 객체의 프로퍼티(예)1'abc'.length; //(문자-&gt;객체) length는 String의 프로퍼티.","text":"Built-in ObjectHost Object 개발자가 직접 만든 객체 표준 빌트인 객체 (= Global Objects) 공통적으로 필요한 기능을 제공한다. Stinrg,Array,Object,Function,Boolean,Number,Math,Date,RegExp, 등등 대문자로 시작. 표준 빌트인 객체들은 생성자 함수이다. 표준 빌트인 객체의 프로퍼티(예)1'abc'.length; //(문자-&gt;객체) length는 String의 프로퍼티. 전역 객체 전역 객체의 자식 객체를 사용할 때, window 생략이 가능하다. 예) window.alert(); -&gt; alert(); 전역변수를 프로퍼티로 가진다. 참고 : 프로퍼티, 메서드를 계속 전역으로 선언하면 window 객체 영역이 커진다. (전역 변수를 사용할 때는 즉시 호출 함수(IIFE)를 사용하도록 한다.) 전역 프로퍼티(window.프로퍼티) Infinity (Number.Infinity) : 양/음의 무한대를 나타내는 숫자값 NaN (Number.NaN) : 숫자가 아님을 나타내는 숫자값 undefined : 기본자료형 undefined를 값으로 갖는다. 전역 함수 eval() isFinite() : 숫자로 변환하여 유한수인지를 판단한 후, 결과값을 Boolean으로 나타낸다. isNaN() : NaN인지를 검사하여 Boolean으로 반환한다.(숫자면 false) parseFloat() : 부동소수점 숫자로 변환하여 반환한다. parseInt() : 정수형 숫자로 변환하여 반환한다. URI 형식 http, host(도메인), port 넘버, Path, Query(256개 가능), Pragment로 구성된다. encodeURI() / decodeURI() encodeURI() : URI의 문자들을 이스케이프 처리한다. decodeURI() : 이스케이프 처리된 문자를 다시 반환한다. 이스케이프 어떤 시스템에서도 읽을 수 있는 ASCII Character-set로 변환하는 것. 특수문자/공백/한글일 경우, 정규표현식으로 이스케이프 처리된다. encodeURIComponent() / decodeURIComponent() Query 부분의 =, ?, &amp;를 인코딩한다. encodeURI()와 차이점은 encodeURI()는 =, ?, &amp;을 인코딩하지 않는다. 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( )는 이스케이프에서 제외된다. Error자바스크립트는 비동기 처리하므로 try-catch문으로 에러 처리를 하지 않는다. 기본자료형과 래퍼객체 모든 기본자료형은 래퍼객체를 가지고 있다. 예) ‘str’ -&gt; new String(‘str’) 기본자료형을 객체처럼 사용할 수 있게 한다. (객체화되면 메소드 또는 프로퍼티를 호출할 수 있다.-&gt; str.length/ str.toUpperCase();) 메소드를 호출하는 시점에만 객체화. 호출이 종료되면 기본자료형으로 돌아온다. string를 위한 레퍼객체(String) 기본자료형이 String(레퍼객체)의 메소드를 사용할수 있는 이유는 메소드나 프로퍼티를 호출할때 순간적으로 레퍼객체로 변환되어 프로토타입 객체를 상속받기 때문이다. String Constructor String 객체는 String()생성자 함수로 생성됨. 전달되는 모든 인자는 문자열로 변환. length 프로퍼티를 가지고 있으며, 유사객체배열로 사용할 수 있다. String Property String은 원본(기본자료형)을 변경하지 않는다. String.length 문자열의 문자 갯수를 반환String MethodString.prototype.charAt() [프로토타입 붙어있는것 확인] index번호에 해당되는 위치의 문자 반환. 0부터 시작한다.String.prototype.indexOf() 문자또는 문자열을 검색해서 처음 찾은 곳의 index 반환. 못찾으면 -1 반환.String.prototype.lastIndexOf() 자또는 문자열을 검색해서 마지막에 찾은 곳의 index 반환. 못찾으면 -1 반환. 참고로 인덱스의 값은 변하지 않음.String.prototype.replace() 첫번째 인자의 문자열을 찾고 두번째 인자의 문자로 대처함. 원본 문자열은 변하지 않음. 첫번째 인자의 문자열이 검색된 문자열에 여러개 존재하면 첫번째만 바꿔줌. /hello/gi &lt;-첫번째 인자를 이렇게 넣으면 전체검색하여 다바꿔줌. 정규표현식은 어려우니까 나중에 공부하자.String.prototype.split() 인자값에 넣은 문자열을 검색하여 그것을 토대로 문자를 분리후 배열로 반환[배열은 문자열로 들어감] 마찬가지로 원본은 변하지 않는다.String.prototype.substring() 첫번째 인자에 전달된 인덱스값의 문자부터 두번째 인자의 인덱스 값-1까지의 문자를 반환. 두번째인수가 커야된다.String.prototype.toLowerCase() 모두 소문자로 바꿈.String.prototype.toUpperCase() 모두 대문자로 바꿈.3.9 String.prototype.trim() 문자열의 양끝 공백을 제거한 후 문자반환. 가운데 껴있는 공백은 제거안됨. DateDate객체는 날짜와 시간을 위한 빌트인객체 그러나 라이브러리로 대부분 사용.[알아만두자] 1000&lt;–밀리초단위로 1초이다. 1970년 1월 1일 00:00(UTC) 기점. UTC / GMT 같다고 보면되지만 UTC라 부르고 사용하자. Date Constructor var d = new Date(‘2017/08/08/20:00:00’); 이 방법을 쓰자. 월은 0~11까지의 정수로 표현되므로 주의하자.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"Built-in Object, String, Date","slug":"Built-in-Object-String-Date","permalink":"http://mkfdev.github.io/tags/Built-in-Object-String-Date/"}]},{"title":"한 주간 배운 내용 Summary2","slug":"TIL-1002","date":"2017-10-02T13:28:13.000Z","updated":"2017-12-17T15:36:06.395Z","comments":true,"path":"2017/10/02/TIL-1002/","link":"","permalink":"http://mkfdev.github.io/2017/10/02/TIL-1002/","excerpt":"map, filter, reduce* 원본 배열이 변경되지 않는다. Array.prototype.some()= 조건에 부합하는게 하나라도 있으면 참 Number 기본자료형 number를 위한 wrapper 객체 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문에 기본자료형이 wrapper 객체 메소드를 사용할 수 있다.","text":"map, filter, reduce* 원본 배열이 변경되지 않는다. Array.prototype.some()= 조건에 부합하는게 하나라도 있으면 참 Number 기본자료형 number를 위한 wrapper 객체 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문에 기본자료형이 wrapper 객체 메소드를 사용할 수 있다. Number Constructor new Number(value) 숫자로 변환할 수 없다면 NaN을 반환한다. 기본자료형 숫자 반환 방식은 Number(Value) new Number와 Number 형 비교12345678var x = 123;var y = new Number(123);console.log(x == y); // trueconsole.log(x === y); // false (타입이 다르다)console.log(typeof x); // numberconsole.log(typeof y); // object Number PropertyNumber.MAX_VALUE 자바스크립트에서 사용 가능한 가장 큰 숫자이다. MAX_VAULE보다 큰 숫자는 Infinity 이다. Number.MIN_VALUE 0에 가장 가까운 양수값이다. MIN_VALUE보다 작은 숫자는 0 이다. Number.POSITIVE_INFINITY 양의 무한대 Infinity를 반환한다. Number.NEGATIVE_INFINITY 음의 무한대 -Infinity를 반환한다. Number.NaN 숫자가 아님을 나타낸다. window.NaN과 같다. Number Method 숫자가 아닐 경우, 인수를 숫자로 변환하지 않고 false를 반환한다. Number.isFinite(value) 매개변수 값이 정상적인 유한수인지를 검사하여 Boolean값을 반환한다. 전역 함수 isFinite(value)는 인수를 숫자로 변환하여 결과값을 반환한다. Number.isInteger(value) 매개변수 값이 정수인지 검사하여 Boolean값으로 반환한다. Number.isNaN(value) 매개변수 값이 NaN인지를 검사하여 Boolean값을 반환한다. Not a Number 숫자가 아니면 true 반환한다. Number.isSafeInteger() 매개변수 값이 안전한 정수 값인지를 검사하여 Boolean값을 반환한다. 안전한 정수 값은 (253 - 1)와 -(253 - 1) 사이의 정수이다. Number.prototype.toExponential() 지수 표기법으로 변환하여 문자열로 반환한다. 예를들어, 1.234e+3는 e(xponential)의 앞에 있는 숫자의 10의 3승을 나타낸다. 변수.toExponential(n); 반올림하여 소수 n번째 짜리까지 지수 표기법으로 반환한다. 인수는 0~20까지 입력할 수 있다. Number.prototype.toFixed() 매개변수로 지정된 소수점 자리를 반올림하여 문자열로 반환한다. Number.prototype.toPrecision() 지정된 전체 자릿수까지 유효하도록 반올림하여 문자열로 반환한다. 지정된 전체 자릿수로 표현할 수 없을 경우 지수표기법으로 쓴다. Number.prototype.toString() 숫자를 문자열로 변환하여 반환한다. toString(n) n은 2~36값으로 진수를 나타낸다. Math 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다. Math PropertyMath.PI PI값을 반환한다. Math MethodMath.abs() 0 또는 양수인 절대값을 반환한다. 숫자가 아닐 경우 NaN을 반환한다. Math.round() 가장 인접한 정수로 올림/내림한다. x = Math.round(-20.5); // -20 x = Math.round(-20.51); // -21 Math.sqrt() 양의 제곱근을 반환한다. Math.ceil() 지정된 숫자를 자신보다 크고, 가까운 정수로 올림한다. Math.floor() 지정된 숫자를 자기보다 작고, 가까운 정수로 내림한다. Math.random() 0과 1 사이의 임의의 숫자를 반환한다. (Math.random() * 10) + 1 : 1에서 10까지의 임의의 숫자를 반환한다. Math.pow() 첫번째 인수를 밑, 두번째 인수를 지수로 하여 거듭제곱을 반환한다. Math.pow(7,2); // 49 Math.max() 인수중에 가장 큰 수를 반환한다. 배열을 인자값으로 받을때는 apply를 사용한다.12345var arr = [1, 2, 3, 4, 5];var max = Math.max.apply(null, arr);//ES6에서 사용법var max Math.max(...arr); Math.min() 인수중에 가장 작은 수를 반환한다. Date 날짜와 시간(년,월,일,시,분,초)을 위한 빌트인 객체이다. UTC(협정 세계시)는 GMT(그리니치 평균시)라고도 한다. KST(Korea Standard Time)은 UTC보다 9시간이 빠르다. 현재의 날짜와 시간은 자바스크립트 코드가 동작한 시스템의 시계에 의해 결정된다. Date의 Constructor Date 생성자를 이용하여 날짜와 시간을 가지는 인스턴스를 생성한다. 기본적으로 현재 날짜와 시간을 나타내는 값을 가진다. new Date() new 연산자 없이 Date()를 사용하면 결과값을 객체가 아닌 문자열로 반환한다. new Date() 매개변수가 없는 경우, 현재 날짜와 시간을 가지는 인스턴스를 반환한다. new Date(milliseconds) 1970년 1월 1일 00:00(UTC)을 기점으로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다. new Date(dateString) 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. var d = new Date(‘May 12, 2016 12:13:00’); var d = new Date(‘2017/08/08/20:00:00’); new Date(year, month[, day, hour, minute, second, millisecond]) 매개변수에 년,월,일,시,분,초,밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. year 1990년 이후의 년 month 월을 나타내는 0~11까지의 정수(1월은 0) Date MethodDate.now() 1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다. Date.parse() 1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. var d = Date.parse(‘Jan 2, 1970 00:00:00 UTC’); // UTC var d = Date.parse(‘Jan 2, 1970 09:00:00’); // KST var d = Date.parse(‘1970/01/02/09:00:00’); // KST Date.UTC() 1970년 1월 1일 00:00:00(UTC)을 기점으로 매개변수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. var d = Date.UTC(1970, 0, 2); var d = Date.UTC(‘1970/1/2’); //NaN 이 형식으로는 인식되지 않는다. Date.prototype.getFullYear() / getMonth() / getDate() / getDay() / getHours() / getMinutes() / getSeconds() / getMilliseconds() / getTime() 해당 연도/월/일/요일을 나타내는 4자리 숫자를 반환한다. getTime()은 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다. Date.prototype.setFullYear() / setMonth() / setDate() / setDay() / setHours() / setMinutes() / setSeconds() / setMilliseconds() / setTime() 해당 연도/월/일/요일을 나타내는 4자리 숫자를 설정한다. setFullYear() 연도 이외의 월,일을 설정할 수 있다. Date.prototype.getTimezoneOffset() UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다. Date.prototype.toDateString() / Date.prototype.toTimeString() 사람이 읽을 수 있는 형식의 문자열로 날짜 / 시간을 반환한다. var d = new Date(‘1988/8/17/13:30’); console.log(d.toDateString()); // Sat Sep 17 1988 String 기본자료형 String을 위한 wrapper 객체이다. 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하기 때문에 기본자료형이 wrppaer 객체 메소드를 사용할 수 있다. String Constructor new String(value) new 연산자를 사용하지 않고 String() 생성자 함수를 호출하면 String 객체가 아닌 문자열 리터럴을 반환한다. new없이 String() 생성자 함수를 호출했을 때는 string 이 된다.12345678var x = 'Lee';var y = new String('Lee');console.log(x == y); // trueconsole.log(x === y); // falseconsole.log(typeof x); // stringconsole.log(typeof y); // object String PropertyString.length 문자열 내의 문자 갯수를 반환한다. String MethodString.prototype.charAt() 매개변수로 전달한 index 위치의 문자를 반환한다. String.prototype.indexOf() 매개변수로 전달된 문자나 문자열을 처음 발견한 곳의 index를 반환한다. 발견하지 못한 경우 -1을 반환한다. String.prototype.lastIndexOf() 매개변수로 전달된 문자나 문자열을 마지막으로 발견된 곳의 index를 반환한다. 2번째 매개변수가 전달되면 해당 위치로 이동한 후, 역방향으로 검색을 시작하고 indexOf() 메소드 처럼 문자열을 처음 발견한 곳의 index를 반환한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153var str = 'Hello World';console.log(str.lastIndexOf('l', 10)); // 9``` ## String.prototype.replace()- 첫번째 인자의 값을 두번째 인자에 전달된 문자열로 대체한다.- 검색된 문자열이 복수로 존재할 경우, 첫번째 문자열만 대체된다.- 원본 문자열은 변경되지 않고 새로운 문자열을 반환한다.## String.prototype.split()- 첫번째 인자의 문자열로 구분하여 분리된 각 문자열로 이루어진 배열을 반환한다.- 전달된 인수가 없는 경우, 문자열 전체를 단일 요소로 하는 배열을 반환한다.- 원본 문자열은 변경되지 않는다.- splitStr = str.split(' ', 3); // 공백으로 구분하여 배열로 반환, 3개까지만 허용## String.prototype.substring()- substring(시작index, 종료index-1)- 첫번째 인자의 index에 있는 문자부터 두번째 인자의 index에 있는 문자의 바로 이전 문자까지를 반환한다.- 첫번째 인수 &gt; 두번째 인수 : 두 인수는 교환된다.- 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.- 인수 &lt; 0 또는 NaN인 경우 : 0으로 취급된다.- 인수 &gt; 문자열의 길이(str.length) : 인수는 문자열의 길이(str.length)으로 취급된다.## String.prototype.substr()- substr(시작index, 길이)- var str = 'Hello'; var res = str.substr(3,2); // lo## String.prototype.toLowerCase()- 문자열의 문자를 모두 소문자로 변경한다.## String.prototype.toUpperCase()- 문자열의 문자를 모두 대문자로 변경한다.## String.prototype.trim()- 문자열 양쪽 끝에 있는 공백 문자를 제거한 문자열을 반환한다.- 문자 사이의 공백은 제거하지 못한다.---# 실행 컨텍스트(Execution Context)- 실행 가능한 코드가 실행되는 환경이다.- 실행 가능한 코드 : 전역코드, Eval코드(안씀), 함수코드(호출)- 변수와 함수가 호출되기 위한 환경이 만들어진다.- 자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 정보를 알고 있으며, 실행 컨텍스트를 물리적 객체의 형태로 관리한다.- 실행에 필요한 정보 : 변수(객체의 프로퍼티, 전역변수, 지역변수, 매개변수), 함수선언(함수명, 함수), 변수의 유효범위(전역이냐 지역이냐), this(가리키고 있는 객체)# 실행 컨텍스트 스택(=콜 스택)- 실행 컨텍스트가 생성되서 쌓이는 영역- 전역 실행 컨텍스트, 함수 실행 컨텍스트가 생성되면 실행 컨텍스트 스택에 쌓인다.- 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며, 함수가 끝나면 해당 함수의 실행 컨텍스트가 사라진다.# 실행 컨텍스트 3가지 객체- Variable Object(VO), Scope Chain(SC), this value1. Variable Object- 변수(함수표현식 포함), 매개변수와 인수, 함수선언의 정보를 담는 객체로 유일하며 최상위에 위치한 객체이다.- 전역 컨텍스트의 VO는 전역객체(GO)를 가리키고, 함수 컨텍스트의 VO는 활성객체(AO)를 가리킨다.- 전역 객체(GO)는 전역에 선언된 전역 변수, 전역 함수를 프로퍼티로 소유한다.- 활성 객체(AO)는 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 arguments객체가 추가된다.- 전역 객체(Global Object)는 1개 생성, 활성객체(Activation Object)는 여러개 생성이 가능하다.2. Scope Chain- 스코프 체인은 일종의 리스트로서 중첩된 함수의 레퍼런스를 저장하고 있다.- 마지막 리스트는 항상 전역 객체(GO)를 가리킨다.- 함수 실행 컨텍스트의 스코프 체인의 경우, 레퍼런스로 자기 자신의 AO와 GO를 가리킨다.- 스코프 체인(리스트)을 검색하면 함수가 중첩 상태일 때, 하위함수 내에서 상위함수의 유효 범위까지 참조할 수 있게 된다.3. this value- this의 값이 할당된다.- 함수 호출 패턴에 의해 결정된다.## 전역 코드에의 진입1. 전역 객체 생성- 컨트롤이 실행 컨텍스트에 접근하기 이전에 유일한 전역 객체(Global Object)가 생성된다.- 전역 객체에는 빌트인 객체와 BOM, DOM이 설정되어 있다.2. 실행 컨텍스트 생성 후 스택- 전역 코드로 컨트롤이 진입하면 실행 컨텍스트가 생성된 후, 실행 컨텍스트 스택에 쌓인다.3. 스코프 체인(SC)의 생성과 초기화- 전역 객체의 레퍼런스를 포함하는 리스트가 된다.4. Variable Instantiation(변수 객체화) 실행- Variable Instantiation은 VO에 프로퍼티와 값을 추가하는 것이다.- 변수, 매개변수, 인수정보(arguments), 함수선언을 VO에 추가하여 객체화한다.- 함수부터 변수 순으로 저장된다.4-1. \"변수 객체화의 순서\"- 1. Function일 경우 매개변수(parameter)가 VO의 프로퍼티로, 인수(arguments)가 값으로 설정된다.- 2. 함수선언(함수표현식 제외)을 대상으로 함수명이 VO(VO가 가리키고 있는 객체)프로퍼티로, 생성된 함수 객체가 값으로 설정된다.(함수 호이스팅)- 3. 변수 선언을 대상으로 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.(변수 호이스팅)5. 함수의 선언 처리(함수가 있다면)- 변수 객체화의 순서 2번처럼 함수명이 프로퍼티로, 생성된 함숫 객체(몸체)가 값으로 설정된다.(전역 함수일 경우 GO에 설정)- 생성된 함수 객체는 [[Scope]] 프로퍼티를 가지게 된다.- (함수 호출 실행 이전)[[Scope]]는 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정하고, (함수 실행 후)스코프 체인이 가리키는 변수 객체에 이미 함수가 등록되어 있으므로 함수선언식 이전에 함수를 호출할 수 있다. (함수 호이스팅)6. 변수의 선언 처리(변수가 있을때)- 변수 객체화의 순서 3번처럼 변수명이 VO(VO가 가리키고 있는 객체)의 프로퍼티로, undefined가 값으로 설정된다.- var 키워드로 선언된 변수는 선언과 초기화 단계가 한번에 이루어진다.- 변수 선언문 이전에 접근해도 VO에 변수가 undefined로 초기화된 상태로 존재하기 때문에 에러가 나지 않는다.(변수 호이스팅)7. this value의 결정- this value가 결정되기 이전에 this는 전역 객체를 가리키고 있다가 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다.## 전역 코드의 실행1. 변수값 할당- 변수값을 할당할 때는 VO(VO가 가리키고 있는 객체, 전역의 경우 GO)를 선두(0)부터 검색하여 해당 변수의 프로퍼티를 발견하면 값을 할당 한다.2. 함수 실행- 함수가 실행되면 새로운 함수 실행 컨텍스트가 생성된다.- 해당 함수로 실행 컨텍스트의 컨트롤이 이동하면 전역 코드와 마찬가지로 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 실행된다.## 함수 코드에의 진입- 전역 코드에의 진입과 순서는 같지만 다른 룰이 적용된다.1. 스코프 체인의 생성과 초기화- Activation Object생성**- AO에 대한 레퍼런스를 스코프 체인의 선두에 설정한다.- Activation Object는 arguments 프로퍼티를 초기화한다.- 스코프 체인의 마지막 레퍼런스 객체는 전역 객체를 참조한다.2. Variable Instantiation 실행- 함수 객체와 변수를 VO에 바인딩한다.(선언, 초기화)- 변수의 프로퍼티는 변수명, 값은 undefined로 VO에 저장한다.- 함수의 프로퍼티는 함수명, 값은 Function Object로 VO에 저장한다.- Function Object의 [[scope]] 프로퍼티가 생성된다. - [[scope]] 프로퍼티는 AO와 전역을 참조하는 리스트의 값을 갖는다.3. this value 결정- this에 할당되는 값은 함수 호출 패턴에 의해 결정된다.## 함수 코드의 실행(함수에 변수가 존재할때)1. 변수 값의 할당- 지역변수를 할당할 때(현재는 내부함수일 경우), 스코프 체인이 참조하고 있는 VO를 선두(0)부터 검색하여 변수명에 해당하는 프로퍼티가 발견되면 값을 할당한다. (해당 영역에도 없으면 스코프 체인 리스트를 참조하여 GO를 검색하도록 한다.)## 내부 함수 코드의 실행- 내부 함수가 실행되기 시작하면 새로운 실행 컨텍스트가 생성된다.- 여기서도 1. 스코프 체인의 생성과 초기화, 2. Variable Instantiation 실행, 3. this value 결정이 순서대로 진행된다.---# 클로저(closure)- 내부함수가 참조하는 외부함수의 지역변수가 외부함수에 의해 내부함수가 반환된 이후에도 life-cycle이 유지되는 것을 의미한다.- 외부함수가 내부함수보다 더 오래 유지되는 경우에 내부함수가 외부함수의 지역변수에 접근할 수 있고 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 못하고 상태가 유지되며 내부함수에 의해 소멸하게 되는 특성을 말한다.- 클로저에 의해 참조되는 외부함수의 변수를 자유변수(Free variable)이라고 부른다.- (실행 컨텍스트 관점에서)내부함수가 유효한 경우에 외부함수가 종료 되면 함수의 실행 컨텍스트도 소멸하지만, 함수 실행 컨텍스트의 AO는 유효하기 때문에 내부함수가 스코프 체인을 통해 참조할 수 있다. # 클로저의 활용- 성능적인 면과 자원적인 면에서 손해를 볼 수 있다.- (실행 컨텍스트에서) 클로저로 참조하는 변수는 프로그램 종료 시까지 계속 메모리에 할당되어 있기 때문에 성능 상 좋다고 할 수 없다.(최소화하며 오남용하지 않아야 한다.) Count! 0 var add = (function () { var counter = 0; return function () { return ++counter; }; }()); function myFunction() { document.getElementById(&apos;demo&apos;).innerHTML = add(); }``` 전역 변수의 사용 억제를 위한 방식 즉시 실행함수는 한번만 실행되므로 counter가 다시 초기화되지 않는다. 외부함수의 변수 counter는 참조하는 함수(내부함수)가 소멸될때까지 유지된다. counter는 외부에서 접근할 수 없는 private 변수이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mkfdev.github.io/tags/javascript/"}]},{"title":"한 주간 배운 내용 Summary","slug":"TIL-1001","date":"2017-10-01T09:30:13.000Z","updated":"2017-12-17T15:33:05.549Z","comments":true,"path":"2017/10/01/TIL-1001/","link":"","permalink":"http://mkfdev.github.io/2017/10/01/TIL-1001/","excerpt":"한 주간 배운 내용 정리자료형(Data Type)기본자료형 boolean null undefined Number String Symbol 기본자료형 null 설계상의 문제 var name = null; console.log(typeof.name); -&gt; object typeof 연사자로 null값을 가진 변수를 연산해보면 object가 나온다. 따라서 null타입 변수인지 확인할 때는 일치연산자(===)를 사용해야 한다.","text":"한 주간 배운 내용 정리자료형(Data Type)기본자료형 boolean null undefined Number String Symbol 기본자료형 null 설계상의 문제 var name = null; console.log(typeof.name); -&gt; object typeof 연사자로 null값을 가진 변수를 연산해보면 object가 나온다. 따라서 null타입 변수인지 확인할 때는 일치연산자(===)를 사용해야 한다. 기본자료형 특징 변경 불가능한 값(immutable value) pass-by-value 객체형 object 객체형 특징 기본자료형을 제외한 모든 것 이름과 값을 가지는 데이터를 의미하는 프로퍼티 동작을 의미하는 메소드 pass-by-reference 변수(Variable) 변수는 위치(메모리 상의 주소)를 기억하는 저장소이다. 값을 할당하고 참조하기 위해 사용된다. 변수명 식별자(identifier)로도 불린다. 영문자, underscore(_), 달러기호($)로 시작해야 한다. 숫자는 이어지는 문자에 사용할 수 있다. 대소문자를 구별한다. 변수의 특징 선언만 된 변수는 undefined로 초기 값을 갖게 된다. 미선언 변수에 접근하면 ReferenceError 예외가 발생한다. 중복 선언이 가능하다. 변수 선언 시 var 키워드 생략이 가능하다.(=전역변수) 동적 타이핑 (Dynamic Typing) : 변수의 Type annotation이 필요없이 값이 할당되는 과정에서 자료형이 결정된다는 것 변수 호이스팅 var 키워드로 선언된 변수의 문제점(설계상의 오류) function-level scope :for loop 초기화 식에서 선언한 변수를 for loop 외부 또는 전역에서 참조할 수 있다. var 키워드 생략 허용 :의도하지 않은 변수 전역화 중복 선언 허용 : 의도하지 않은 변수값 변경 변수 호이스팅 : 변수를 선언하기 전에 참조가 가능하다. 변수 호이스팅이란var 선언문이나 function 선언문을 해당 scope의 선두로 옮기는 것을 말한다. 변수 호이스팅 과정 (변수 생성 3단계) var 키워드로 선언된 변수는 선언 단계(Variable Object에 등록, 스코프가 VO참조)와 초기화 단계(메모리할당, undefined)가 이루어진다. 변수 선언문 이전에 변수에 접근하면 undefined가 반환된다. =&gt; 변수 호이스팅 변수 할당문에 도달하면 할당 단계가 이루어진다. 함수 함수를 정의하는 방법 3가지. 함수선언식 함수표현식 Function() 생성자 함수 함수선언식 function 키워드 function 함수명(매개변수){return 결과값;} 자바스크립트 엔진에 의해 함수표현식으로 형태가 변경되어, 함수참조값을 가진 변수명과 함수명이 일치하여 함수명으로 호출할 수 있다. (실제로는 아래처럼 기명 함수표현식으로 변경되어 변수명으로 호출한 것) var foo = function foo(매개변수){return 결과값;} 결국 함수선언식도 함수 리터럴 방식으로 정의된다. 함수표현식 리터럴 방식으로 함수를 정의, 변수에 할당한 방식(일급객체)을 함수 표현식이라 한다. 함수가 변수에 할당되면, 이 변수는 할당된 함수를 가리키는 참조값을 가지게 되며 함수 호출시 이 변수가 함수명처럼 사용된다. 함수표현식은 일반적으로 함수명을 생략하여 익명함수(무명함수표현식)로 사용한다. var reply = function(a,b){return 결과값;} console.log(reply(5,10)); // 함수호출일급객체 무명의 리터럴로 표현이 가능하다. 변수나 자료구조에 저장할 수 있다. 함수의 파라미터로 전달할 수 있다. 반환값으로 사용할 수 있다. Function() 생성자 함수 Function() 생성자 함수는 function.prototype.constructor 프로퍼티로 접근할 수 있다. var foo = new function (‘a’, ‘return a’); console.log(foo(100)); //100 foo()는 생성자를 통해 만들었기 때문에 객체이다. 함수는 function()이라는 기본 내장 생성자 함수로 생성된 객체이다. 리터럴 방식도 내부적으로는 function() 생성자 함수로 생성된다. 정의방식은 달라도 결국 function() 생성자 함수를 통해 함수가 생성된다. 함수선언식과 함수호이스팅 함수호이스팅은 코드를 실행하기전에 function 선언문을 해당 scope의 맨 위로 옮기는 것이다. 함수 선언 위치와는 상관없이 코드 내 어느곳에서든지 호출이 가능하다. 함수선언식은 함수 선언, 초기화, 할당이 한번에 이루어진다.123456//foo()함수를 상단으로 호이스팅 시켜주기 때문에 에러발생 안함.foo();function foo()&#123; console.log(\"hello javascript\");&#125; 함수표현식과 변수호이스팅 변수호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화되고 실제값의 할당은 할당문에서 이루어진다. =&gt; 상단에서 함수호출시 TypeError 발생123456789//var foo; 변수 생성//foo = undefined; 변수 초기화foo();//여기서 함수 호출시 할당이 이루어지지 않았기 때문에 foo()는 TypeError를 발생시킨다.var foo = function()&#123; console.log(\"hello javascript\");&#125; 함수 객체의 프로퍼티 함수는 객체이므로 함수도 프로퍼티를 가질 수 있다. 함수 객체의 속성 : arguments, caller, length, name, prototype, [[prototype]] arguments 프로퍼티 함수 호출시 전달된 인수들의 정보를 담고 있는 순회가능한 유사 배열 객체(length 프로퍼티를 가진 객체)이다. 매개변수의 갯수보다 인수를 적게 전달했을 때 인수가 전달되지 않은 매개변수는 undefined으로 초기화된다. 매개변수의 갯수보다 인수를 더 많이 전달한 경우, 초과된 인수는 무시된다. 매개변수 갯수가 확정되지 않은 가변 인자 함수를 구현할 때 유용하다. 배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해야 한다. caller 프로퍼티 자신을 호출한 함수를 의미한다. length 프로퍼티 함수 정의 시 작성된 매개변수 갯수를 의미한다. function bar(a, b){ return a*b; } // bar.length: 2 arguments.length는 함수 호출시 호출된 인자의 갯수를 의미한다. name 프로퍼티 함수명을 나타낸다. 기명함수일 때는 함수명을 값으로 갖고, 익명함수일 때는 빈문자열을 값으로 갖는다. [[prototype]] 프로퍼티 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리키며, 함수의 경우 Function.prototype을 가리킨다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수객체가 생성자 함수로 사용되어 객체를 생성할 때, 생성된 객체의 부모 역할을 하는 객체를 가리킨다. constructor 프로퍼티를 가지는 객체를 가리킨다. constructor 프로퍼티는 함수 객체 자신을 가리킨다. 제어문(Control Flow) 조건에 따른 명령 실행(조건문)이나 반복 실행(반복문)이 필요할 때 사용된다. 조건문은 if문, switch문, 반복문은 for문, while문, do-while문 등이 있다.블록 구문(Block Statement) 구문들의 집합, 중괄호로 그 범위를 정한다. 함수, 객체 리터럴, 흐름 제어 구문에서 사용된다. 평가 흐름제어를 위해서 논리적 참,거짓을 구별한 후 평과 결과에 따라 결정을 내린다. 이때 자바스크립트는 문맥을 고려하여 내부적으로 자료형을 암묵적으로 강제 형 변환할 수도 있다. 암묵적 형 변환 자바스크립트 엔진이 필요에 의해 암시적으로 형을 자동으로 변환시키는 것이다. 문자와 숫자를 연산하는 것 자체가 불가능 하기에 형변환이 필요하다. 암묵적 형 변환 규칙1) 숫자형 + 문자형 = 문자형console.log(10 + ‘10’); // 1010 2) 숫자형 - 문자형 = 숫자형console.log(2 - ‘1’) // 1 3) 불린형 + 문자형 = 문자형console.log(true + ‘10’); // true10 4) 불린형 + 숫자형 = 숫자형console.log(true + 10); // 11 5) 그 외의 규칙 console.log(‘1’ &gt; 0); // true console.log(‘10’ == 10); // true console.log(‘10’ === 10); // false console.log(undefined == null); // true console.log(undefined === null); // false 명시적 형 변환 개발자가 직접 어떤 형으로 변경할 지를 명시해 주는 것을 명시적 형 변환이라고 한다. 1. 문자를 숫자로 타입 변환 변환 방법 예제 “+” operator 붙이기(권장) var val=’123’; val = +val; “ * 1” var val=’123’; val = val*1; Number() var val=’123’; Number(val); parseInt() var val=’123’; parseInt(val); 2. 숫자를 문자로 타입 변환 변환 방법 예제 ‘&nbsp;&nbsp;’ 붙이기(권장) var val=123; val = val + ‘&nbsp;&nbsp;’; String() var val=123; String(val); toString() var val=123; toString(val); Falsy values와 Truthy values Falsy values : Boolean context에서 false로 평가되는 값 false, undefined, null, 0, NaN(Not a Number), ‘&nbsp;’(빈문자열) Truty values : Boolean context에서 true로 평가되는 값 Falsy values 이외의 값들(객체)은 모두 Truthy values이다. 객체(Object) 자바스크립트는 객체 기반의 스크립트 언어이며, 자바스크립트를 이루고 있는 것은 모두 객체이다. 객체는 데이터와 그 데이터에 관련된 동작을 모두 포함할 수 있는 개념적 존재이다.(프로퍼티와 메소드를 포함하고 있는 독립적 주체이다.) 객체는 Pass-by-reference 객체는 변경가능한 프로퍼티들의 집합 변수는 객체 자체가 아닌 생성된 객체의 참조값을 저장한다. 즉, 동일한 객체를 참조할 경우, 객체의 참조값(주소)를 공유하게 된다. 기본자료형은 Pass-by-value 기본자료형 값이 한번 정해지면 변경될 수 없다.(Immutable, 변경불가성) 변수에 참조형으로 저장되는 것이 아니라 값 자체가 저장된다. 새로운 변수에 값을 가진 또 다른 변수가 대입될 경우, 값이 복사되어 새로운 변수에 저장된다. 프로퍼티란 객체에 속한 데이터(Data)로 이름(name)과 값(value)의 쌍으로 구성된다. 메소드란 객체 내부에서 프로퍼티로 선언된 함수를 뜻한다. 함수와 동일하지만 객체 내에 만들어 진다는 점이 다르다. 객체 생성 방식 객체리터럴, Object()생성자 함수, 생성자 함수 3가지 방식이 있다. 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다. 객체리터럴 중괄호 {}를 사용하여 객체를 생성한다. {} 내에 프로퍼티 이름: 프로퍼티 값을 기술하면 해당 프로퍼티가 추가된 객체를 생성한다. Object() 생성자 함수 new 연산자와 Object() 생성자 함수로 빈 객체를 생성한 후, 프로퍼티와 메소드를 추가하여 객체를 생성한다. 생성자 함수 생성자 함수는 대문자로 시작한다. 프로퍼티 또는 메소드 앞의 this는 생성자 함수로 생성될 인스턴스를 가리킨다. this에 연결되있는 프로퍼티와 메소드는 외부에서 참조 가능하다.(일반함수의 this는 전역객체에 바인딩된다.) 생성자 함수 내의 일반 변수는 private로 외부에서 참조 불가능하다. 생성자 함수와 일반 함수의 혼란을 방지하기 위한 패턴(Scope-Safe Constructor)1234567891011121314151617function A(arg) &#123; //this가 호출된 함수(arguments.callee)의 인스턴스가 아니면 if(!(this instanceof arguments.callee))&#123; //생성자 함수를 호출하여 인스턴스를 반환한다. return new arguments.callee(arg); &#125; this.value = arg ? arg : 0;&#125;var a = new A(100);var b = A(10); console.log(typeof a); //objectconsole.log(typeof b); //object 객체 프로퍼티 접근프로퍼티 이름 프로퍼티는 문자열(빈 문자열 포함)과 숫자가 올 수 있다. ‘ - ‘가 들어간 이름은 유효한 이름이 아니기 때문에 ‘’(따옴표)를 사용해야 한다.(연산자가 있는 표현식으로 인식) 예약어는 사용하지 말아야 한다. 프로퍼티 값 읽기 유효한 이름일 경우, 마침표 표기법(.), 대괄호 표기법([‘&nbsp;’]) 모두 사용할 수 있다. 유효한 이름이 아니거나 예약어일 경우, 대괄호([‘&nbsp;’])로 읽어야 한다. 대괄호 내의 프로퍼티 이름은 꼭 문자열이어야(‘&nbsp;’) 한다. 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 프로퍼티 값 갱신 / 동적 생성 / 삭제 객체가 소유한 프로퍼티 값에 새로운 값을 할당하면 프로퍼티 값이 갱신된다. 객체가 소유하지 않은 프로퍼티에 값을 할당하면 해당 프로퍼티를 객체에 추가하고 값을 할당한다. delete 연산자로 객체의 프로퍼티를 삭제할 수 있다. 객체의 분류(용어 정리)내장객체(Built-in Object) 웹페이지 등을 표현하기 위한 공통의 기능을 제공하며 웹페이지가 브라우저에 의해 로드되자마자 바로 사용이 가능하다. 내장객체에는 Standard Built-in Objects(표준 빌트인 객체)와 Native Object(BOM,DOM)가 있다. 표준 내장 객체 Standard Built-in Objects (or Global Objects) 자바스크립트가 기본적으로 가지고 있는 객체들을 의미한다. Javascript는 프로그램 전체의 영역에서 공통적으로 필요한 기능을 개발자 각자가 일일히 작성하는 수고를 줄이기 위해 Standard Built-in Objects(표준 빌트인 객체)를 제공한다. 전역객체와는 다른 의미이며, 전역객체의 자식이다. Object, Function, Array, String, Number, Math, Date 등이 있다. BOM(Browser Object Model) 브라우저 객체 모델은 현재 브라우저 창 또는 탭을 표현하는 객체이다. 최상위 객체는 window로 Standard Built-in Objects가 구성된 후에 객체가 구성된다. 웹 브라우저의 버튼, URL 주소 입력창, 타이틀 바, 윈도우 크기 등 을 제어할 수 있는 객체 모델이다. 자식 객체로는 window, location, navigator, history, screen, document 등이 있다. DOM(Document Object Model) HTML 문서에 대한 모델을 트리로 구성하고, 문서 내의 각 요소에 접근하여 수정할 수 있도록 프로퍼티와 메소드를 재공한다. 최상위 객체는 document 객체로 전체 문서를 표현한다. 연산자비교연산자( != 와 !== ) 연산자 설명 != 부등비교, 값이 같지 않을 경우 true !== 불일치 비교, 데이터 타입이 다르거나 값이 다를 경우 true 단축 평가 Boolean값으로 평가하기 위해 참조하여야 할 곳까지 진행한 후, 평가를 중지하게된 계기가 된 값을 반환한다. 연산자 설명 true ll anything true false ll anything anything true &amp;&amp; anything anything false &amp;&amp; anything false 타입 연산자 연산자 설명 typeof 데이터타입을 문자열로 반환한다. null과 배열은 object, 함수는 function instanceof 객체가 동일 객체 타입의 인스턴스이면 true를 반환한다. !! - 피연산자를 불린 값으로 변환하는 역할 객체(배열 포함)의 경우, 빈객체라도 존재한다면 true로 변환된다. !!를 제거한 불린 값과 동일하다. console.log(!!{}); //true console.log(!![]); //true console.log(!!1); // true console.log(!!null); // false 프로토타입(Prototype) 자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있고, 부모 객체를 프로토타입(prototype)이라고 한다. 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있다. Object.prototype 객체는 프로토타입 체인의 종점이다. [[Prototype]] 프로퍼티 proto와 같은 개념이다. 함수를 포함한 모든 객체가 가지고 있는 프로퍼티이다. 객체의 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리킨다. 함수 객체는 function.prototype을 가리킨다. prototype 프로퍼티 함수 객체만 가지고 있는 프로퍼티이다. 함수 객체가 생성자로 사용될 때, 생성될 객체의 부모 역할을 하는 객체(프로토타입 객체)를 가리킨다. constructor 프로퍼티 프로토타입 객체를 생성했던 함수에 대한 참조를 나타낸다. constructor가 함수 또는 생성자 객체를 가리키는 참조값이므로 아래처럼 constructor 속성으로 함수를 호출하거나 객체를 생성할 수 있다. 123456function Person(name)&#123; this.name = name;&#125;var mySon = new Person('daniel');var myGrandSon = new mySon.constructor('jessica'); 객체 생성 방식에 따른 프로토타입의 차이 생성자 함수 방식1234function Person(name)&#123; this.name = name;&#125;var choi = new Person('choi'); choi 객체의 [[prototype]]은 Person.prototype 이다. 객체 리터럴 방식12345var choi = &#123; name : 'min', gender: 'female', year : 2017&#125; choi 객체의 [[prototype]]은 Object.prototype 이다. Object() 생성자 함수 방식 생성자 함수 정의를 하기위한 방식은 함수선언식, 함수표현식, function() 3가지 방식이 있다. 3가지 함수 정의 방식은 결국 Function() 생성자 함수를 통해 함수 객체를 생성한다. 따라서 어떠한 방식으로 함수 객체를 생성하여도 모든 함수 객체의 prototype객체는 Function.prototype이다. 12345678// 빈 객체의 생성var choi = new Object();// 프로퍼티 추가person.name = 'Choi';person.gender = 'female';person.sayHello = function () &#123; console.log('Hi! My name is ' + this.name);&#125;; choi 객체의 [[prototype]]은 Object.prototype 이다. 3가지 방식에 따라 생성된 객체의 prototype객체 정리 객체 생성 방식 엔진의 객체 생성 인스턴스의 prototype 객체 생성자함수 생성자함수 생성자 함수 이름.prototype 객체리터럴 object()생성자함수 Object.prototype object() 생성자함수 object()생성자함수 Object.prototype 객체리터럴, 생성자 함수는 내부적으로 Object() 생성자 함수를 사용하여 객체를 생성한다. Object() 생성자 함수는 함수 객체이기 때문에 일반 객체와 다르게 prototype 프로퍼티가 있다. 프로토타입 체인(Prototype chain) 해당 객체에 접근하려는 프로퍼티나 메소드가 없다면 [[Prototype]] 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색하는 것을 프로토타입 체인이라고 한다. 프로토타입 객체의 확장 프로토타입 객체도 객체이므로 프로퍼티를 추가,삭제할 수 있다. 아래 예는 Person.prototype 객체에 메소드 sayHello를 추가하였다. 123Person.prototype.sayHello = function()&#123; console.log('Hi~~ my name is ' + this.name);&#125;; 기본자료형의 확장 기본자료형은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없다. 그러나 기본자료형으로 프로퍼티나 메소드를 호출할 때 기본자료형과 연관된 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 된다. 프로퍼티나 메소드를 직접 추가할 수는 없고, String 객체의 프로토타입 객체 String.prototype에 메소드를 추가하면 메소드를 사용할 수 있다. 표준 내장 객체(Built-in object)의 프로토타입 객체(String.prototype, Number.prototype, Array.prototype 등)에 개발자가 정의한 메소드의 추가를 허용한다.1234567var objStr = 'this is string';String.prototype.myMethod = function () &#123; return 'String prototype';&#125;;console.log(objStr.myMethod()); //String prototype 출력 프로토타입 객체의 변경 객체를 생성할 때 프로토타입이 결정되고, 부모 객체인 프로토타입을 동적으로 변경할 수 있다. 프로토타입 객체 변경 시점 이전에 생성된 객체의 constructor 속성은 해당 객체의 생성자 함수를 가르킨다. 프로토타입 객체 변경 시점 이후에 생성된 객체의 constructor는 Object() 생성자 함수를 가르킨다. 즉, Person(기존생성자명).prototype.constructor 프로퍼티가 삭제되고, Object.prototype.constructor 프로퍼티가 생성된다. 프로토타입 체인 동작 조건 객체의 프로퍼티를 참조하는 경우, 프로토타입 체인이 동작한다. 1234567function Person(name) &#123; this.name = name;&#125;Person.prototype.gender = 'male';var bar = new Person('Kim');var foo = new Person('Choi');foo.gender = 'female'; 위 예제처럼 새로 생성한 객체에 gender 프로퍼티의 값을 할당하면 프로토타입 체인이 동작하지 않고, 해당 객체에 프로퍼티를 동적으로 추가한다. Scope(유효범위) 변수가 가지고 있는 참조범위이다. 변수가 유효한 범위, 변수에 접근할 수 있는 범위를 말한다. function-level scope 함수 코드 블럭 내에서 선언된 변수는 함수 코드 블럭 내에서만 유효하고 함수 외부에서는 참조할 수 없다. 단, ECMAScript 6에서 도입된 let keyword를 사용하면 block-level scope를 사용할 수 있다. function 밖에 선언된 변수는 코드 블랙 내에 선언되었다 할지라도 전역 변수가 된다.(Global scope를 갖는다.) Global scope 글로벌 영역에 변수를 선언하면 그 변수는 어디서나 참조할 수 있는 전역 변수가 된다. 전역 변수는 전역 객체 window의 프로퍼티이다. 암묵적 전역 함수 내에서 var keyword 없이 변수를 선언하면 상위 지역(전역)에서 변수를 찾고 존재하지 않으면 암묵적으로 전역 변수로 선언한다. 의도치 않은 전역 변수가 될 수 있으므로 var keyword를 사용한다. 전역 변수 사용의 억제 암묵적 전역 변수화(var keyword가 없을 경우)와 변수명 중복 허용으로 변수의 값이 변경될 수 도 있다. 전역 변수를 반드시 사용해야 할 경우가 아니라면 지역 변수를 사용해야 한다. 코드가 길어지면 변수명의 중복이 발생하기 쉬워 예기치 못한 이상 동작의 원인이 되기 쉬우며, 전역변수는 지역변수보다 탐색에 걸리는 시간이 더 길다. 즉시 실행 함수(IIFE, Immediately-Invoked Function Expression)를 사용한다. 즉시 실행 함수는 즉시 실행되고 그 후 전역에서 바로 사라진다. 사용법 =&gt; (function () { 변수 선언, 실행할 내용… }()); this 함수 호출 패턴 this는 전역 객체에 바인딩된다. 전역함수, 내부함수, 메소드의 내부함수, 콜백함수 모두 전역 객체에 바인딩된다. 메소드 호출 패턴 this는 해당 메소드를 호출한 객체에 바인딩된다. 함수가 객체의 프로퍼티일 때, 메소드 내부의 this 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다. 생성자 호출 패턴 this는 새로 생성된 객체를 가리킨다. new 연산자로 생성자 함수를 호출하면 빈 객체 생성 및 this 바인딩: 빈 객체를 생성후 this는 이 빈 객체를 가리킨다. this를 통한 프로퍼티 생성: 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성한다. 생성된 객체 반환 : 반환문이 없는 경우, 새로 생성된 객체가 반환된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://mkfdev.github.io/tags/javascript/"}]},{"title":"프로토타입과 this","slug":"TIL-0929","date":"2017-09-29T13:26:14.000Z","updated":"2017-12-17T15:32:25.097Z","comments":true,"path":"2017/09/29/TIL-0929/","link":"","permalink":"http://mkfdev.github.io/2017/09/29/TIL-0929/","excerpt":"prototype 프로토타입 prototype 프로퍼티:생성자가 생성될 객체의 부모 역할을 하는 프로토타입을 찾아갈 때 사용한다. __proto__ 프로퍼티:생성된 객체가 부모 역할을 하는 프로토타입을 찾아갈 때모든 객체는 [[prototype]]이라는 숨겨진 프로퍼티를 가진다. [[prototype]]이 정확한 명칭이고 __proto__와 의미는 같다. -constructor 프로퍼티:프로토타입은 constructor 객체를 가진다.생성된 객체가 생성자를 찾아갈수 있게 한다.","text":"prototype 프로토타입 prototype 프로퍼티:생성자가 생성될 객체의 부모 역할을 하는 프로토타입을 찾아갈 때 사용한다. __proto__ 프로퍼티:생성된 객체가 부모 역할을 하는 프로토타입을 찾아갈 때모든 객체는 [[prototype]]이라는 숨겨진 프로퍼티를 가진다. [[prototype]]이 정확한 명칭이고 __proto__와 의미는 같다. -constructor 프로퍼티:프로토타입은 constructor 객체를 가진다.생성된 객체가 생성자를 찾아갈수 있게 한다. 즉시호출함수표현식 (IIFE, Immediately Invoke Function Expression) 함수를 선언하자마자 호출한다. 딱 한번만 호출된다. 변수가 함수내에서만 유효하기 때문에 전역변수를 사용하지 않아서 변수 중복 선언 같은 문제를 방지할 수 있다. 내부함수 함수 내부에 정의된 함수이다. 부모함수, 외부에서는 내부함수에 접근할 수 없다. 프로토타입 객체123456789var student = &#123; name: 'Lee', score: 90&#125;;// student에는 hasOwnProperty 메소드가 없지만 아래 구문은 동작한다.console.log(student.hasOwnProperty('name')); // trueconsole.dir(student); student의 프로포타입은 Object이다. (생성자 함수명이 Object) 프로토타입 객체의 확장기본자료형(Primitive data type)의 확장 기본자료형은 객체가 아니므로 프로퍼티와 메서드가 없지만프로퍼티나 메서드가 호출할 때 일시적으로 객체형이 된다. Scope 유효범위전역변수(Global variable) 코드 어디서든 참조할 수 있다.지역변수(Local variable or function-level variable) 정의 된 함수 내에서만 참조할 수 있다. this 메서드, 생성자를 제외한 모든 객체의 this는 window이다. new 연산자가 없는 그냥 함수에서의 this는 window이다. 기존함수에 new 연산자를 붙여서 호출하면 생성자 함수로 동작한다. 생성자 함수로 동작할 때 this는 자신이 생성할 객체를 가리킨다. 메서드의 this는 해당 메서드의 소유주이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"prototype, this객체, scope","slug":"prototype-this객체-scope","permalink":"http://mkfdev.github.io/tags/prototype-this객체-scope/"}]},{"title":"객체와 생성자함수","slug":"TIL-0928","date":"2017-09-28T11:23:34.000Z","updated":"2017-12-17T15:28:33.886Z","comments":true,"path":"2017/09/28/TIL-0928/","link":"","permalink":"http://mkfdev.github.io/2017/09/28/TIL-0928/","excerpt":"객체(Object) 프로퍼티(data)와 메소드(행위)로 구성된다. data를 컨트롤하기 위한 행위를 객체라고 할 수 있다. 객체는 상속을 사용하여 중복을 막는다. 기본자료형을 제외한 모든 것은 객체이다. 추상화: 특징, 행위를 객체에 추가하는 것프로퍼티(Property) key(이름)와 value(값)로 이루어져 있다. 프로퍼티 이름 : 빈문자열, 문자열, 숫자 프로퍼티 값 : undefined를 제외한 모든 값 메소드(Method) 값(value)이 함수인 프로퍼티 일반 함수와 구분하기 위해 메소드라 부른다.","text":"객체(Object) 프로퍼티(data)와 메소드(행위)로 구성된다. data를 컨트롤하기 위한 행위를 객체라고 할 수 있다. 객체는 상속을 사용하여 중복을 막는다. 기본자료형을 제외한 모든 것은 객체이다. 추상화: 특징, 행위를 객체에 추가하는 것프로퍼티(Property) key(이름)와 value(값)로 이루어져 있다. 프로퍼티 이름 : 빈문자열, 문자열, 숫자 프로퍼티 값 : undefined를 제외한 모든 값 메소드(Method) 값(value)이 함수인 프로퍼티 일반 함수와 구분하기 위해 메소드라 부른다. 객체생성방법 ES5(3가지)1.객체 리터럴 중괄호를 사용하여 객체를 생성한다. 중괄호 안에 프로퍼티가 없으면 빈 객체 리터럴이다. var emptyObject = {}; //빈 객체 리터럴 [참고] console.log 내장객체.메서드 내장객체(=built-in) : 자바스크립트가 원래부터 갖고 있는 함수이다. 2.Object()생성자 함수 빈 객체 리턴 후, 동적으로 프로퍼티를 추가한다. 객체리터럴 방식으로 객체가 생성되는 동안 실제 내부적으로 처리되는 방식이다. ES5에서 잘 사용하지 않는다. 3.생성자 함수 객체를 생성하기 위한 함수이다. 객체를 생성하기 위한 템플릿을 구성하여 재사용하기 때문에 여러 객체를 간편하게 생성할 수 있다. 인스턴스로 추가적인 객체를 생성할 수 있다. 1234567891011function Person(name, gender)&#123; var married = true; //private 외부에서 접근이 불가능하다. this.name = name; this.gender = gender;&#125;// 인스턴스 생성var Person = new Person('Lee','male');console.log(person.gender); // 'male'console.log(person.married); // undefined 객체 프로퍼티 접근프로퍼티 이름 ‘first-name’는 반드시 따옴표를 사용한다. ‘-‘ 연산자로 인식한다. 예약어는 사용하면 안된다. first-name, ‘first-name’, firstName 프로퍼티 값 읽기 프로퍼티가 gender:’male’일 경우, person.gender로 접근하거나, person[‘gender’]로 접근한다. 프로퍼티가 ‘first-name’:’Ung-mo’일 경우, person[‘first-name’]로 접근한다. 대괄호 표기법을 사용할 때, 대괄호 안의 프로퍼티 이름은 반드시 문자열(‘ ‘)이어야 한다. 프로퍼티 동적 생성 객체에 존재하지 않는 프로퍼티를 참조하면 undefined를 반환한다. 객체가 소유하지 않은 프로퍼티에 값을 할당하면 객체에 해당 프로퍼티를 추가하고 값을 할당한다. 123456789var person = &#123;'first-name': 'Ung-mo','last-name': 'Lee',gender: 'male',&#125;;person.age = 20;console.log(person.married); // undefined;console.log(person.age); // 20 for-in 문1234// prop에 객체의 프로퍼티 이름이 반환된다. 단, 순서는 보장되지 않는다.for (var prop in person) &#123; console.log(prop + ': ' + person[prop]);&#125; 프로퍼티 갯수만큼 순회한다. 순서가 보장되지 않으므로 배열에서는 for-of문을 사용한다. for-of는 배열의 요소를 순회한다. Pass-by-reference 객체: pass-by-reference, mutable 객체는 힙에 저장된다. 객체는 객체의 값(value)이 아니라 객체가 들어있는 주소값을 저장한다.(기본자료형은 값 자체가 저장된다.) 할당을 하면 같은 주소를 참조하게 된다. var foo; var bar = foo; bar는 foo의 주소 값을 갖게 된다. 즉 같은 주소를 참조하게 된다. 객체의 분류 (용어정리)Built-in Object(내장 객체) 내장 객체는 자바스크립트 엔진에 내장되어 있어, 필요한 경우 생성해 사용할 수 있다. 내장 객체로는 문자(String), 날짜(Date), 배열(Array), 수학(Math)객체 등이 있다. BOM (Browser Object Model) 브라우저 객체 모델 브라우저에 계층적으로 내장되어 있는 객체로 window, screen, location, history, navigator 등이 있다. window.location.href= “사이트 url” DOM (Document Object Model) 문서 객체 모델 HTML 문서 구조를 말한다. 최상위 객체 &lt;html&gt; 그리고 &lt;head&gt;, &lt;body&gt; 등이 있다. Host Object(사용자 정의 객체) 사용자가 생성한 객체로 사용자가 constructor 혹은 객체리터럴을 통해 사용자가 객체를 정의하고 확장시킨 것들이기 때문에 Built-in Object 와 Native Object가 구성된 이후에 구성된다. 함수 코드재사용 매개변수,인자(parameter) / 인수(argument) 함수 정의 방식 3가지1.함수선언식 함수 호이스팅이 발생한다. 함수를 선언하기 전에 상단에서 호출했을 때 함수를 선언한 것처럼 실행하는 것을 호이스팅이라고 한다. 2.함수표현식 함수 선언식과는 달리 변수 호이스팅이 발생하고, 함수를 먼저 호출할 경우, TypeError가 발생한다. 자바스크립트의 함수는 일급객체 이다. 일급 객체의 특성을 이용하여 함수 리터럴 방식으로 함수를 정의하고 변수에 할당할 수 있는데 이러한 방식을 함수표현식(Function expression)이라 한다. 일급객체(First-class object) 무명의 리터럴로 표현이 가능하다. 함수를 변수나 데이터 구조안에 담을 수 있다. 함수의 파라미터로 함수를 전달 할 수 있다.(함수를 값처럼 사용할 수 있다.) 함수를 반환값으로 사용할 수 있다. 함수표현식 두가지 1.익명 함수표현식(anonymous function expression) : 함수명을 생략해서 함수를 선언한 것이다. 123var bar = function(a, b) &#123; return a * b;&#125;; 2.기명 함수표현식(named function expression) : 외부에서 호출할 수 없다. 123var foo = function multiply(a, b) &#123; return a * b;&#125;; function() 생성자 함수 Function() 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다. 함수선언식과 함수표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function() 생성자 함수로 함수를 생성하는 것을 단순화 시킨 것이다. 일반적으로 사용하지 않는다. [참고] 함수 호이스팅과 변수 호이스팅함수 선언식 - 함수 호이스팅함수 호이스팅은 함수 선언, 초기화, 할당이 한번에 이루어 진다.따라서 함수 호출이 먼저 진행될 경우 에러가 발생하지 않는다. 함수 표현식 - 변수 호이스팅변수 호이스팅은 변수생성, 초기화, 할당이 분리되어 진행된다.호이스팅된 변수는 undefined로 초기화되고 실제 값의 할당은 할당문에서 이루어진다.따라서 함수 호출이 먼저 진행될 경우 TypeError가 발생하게 된다. arguments 프로퍼티 매개 변수 갯수가 확정되지 않은 가변 인자 함수 구현에 유용하다. 매개 변수의 갯수보다 인수를 적게 전달했을 때, 전달되지 않은 인수 값은 undefind로 초기화된다. 반대로 인수가 초과 전달되었을 때는 초과된 인수가 무시된다. arguments 객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"object, property, method, constructor","slug":"object-property-method-constructor","permalink":"http://mkfdev.github.io/tags/object-property-method-constructor/"}]},{"title":"알고리즘 문제풀이","slug":"TIL-0927","date":"2017-09-27T09:21:14.000Z","updated":"2017-12-17T15:28:29.437Z","comments":true,"path":"2017/09/27/TIL-0927/","link":"","permalink":"http://mkfdev.github.io/2017/09/27/TIL-0927/","excerpt":"","text":"1. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.1234for (var i = 0; i &lt; 10; i++) &#123; if (i % 2 == 0) console.log(i);&#125; 2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.123456var str = \"\";for (var i = 0; i &lt; 10; i++) &#123; if (i % 2 == 0) str += i;&#125;console.log(str); 3. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.1234for (var i = 10; i &gt; 0; i--) &#123; if (i % 2 != 0) console.log(i);&#125; 4. while문을 사용하여 0부터 10까지 정수 중에서 짝수만을 작은 수부터 출력하시오.123456var num = 0;while (num &lt; 10) &#123; if (num % 2 == 0) console.log(num); num++;&#125; //# 5. while문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 123456var num = 10;while (num &gt; 0) &#123; if (num % 2 != 0) console.log(num); num--;&#125; 6.for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.123456var sum = 0;for (var i = 0; i &lt; 10; i++) &#123; sum += i;&#125;console.log(sum); 7. 1부터 20까지의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.12345678var res = 0;for (var i = 1; i &lt; 21; i++) &#123; if (i % 2 !== 0 &amp;&amp; i % 3 !== 0) &#123; res += i; &#125;&#125;console.log(res); 8. 1부터 20까지의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.1234567var res = 0;for (var i = 1; i &lt; 21; i++) &#123; if (i % 2 == 0 || i % 3 == 0) &#123; res += i; &#125;&#125;console.log(res); 9. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오. for문 12345678for (var i = 1; i &lt;= 6; i++) &#123; for (var j = 1; j &lt;= 6; j++) &#123; var num = i + j; if (num == 6) &#123; console.log('[' + i + ',' + j + ']'); &#125; &#125;&#125; while문 1234567891011121314151617var ju1 = 1;var res = [];while (ju1 &lt; 7) &#123; var ju2 = 1; while (ju2 &lt; 7) &#123; var sum = ju1 + ju2; if (sum === 6) &#123; res = [ju1, ju2]; console.log(res); &#125; ju2++; &#125; ju1++;&#125; 10. 삼각형출력하기12345678var result = \"\";for (var i = 0; i &lt; 5; i++) &#123; for (var j = 0; j &lt;= i; j++) &#123; result += \"*\"; &#125; result += \"\\n\";&#125;console.log(result); 11. 트리 출력하기 내풀이 123456789101112131415var result = \"\";for (var i = 0; i &lt; 3; i++) &#123; for (var j = 0; j &lt;= i; j++) &#123; result += \"*\"; &#125; result += \"\\n\";&#125;console.log(result);for (var i = 0; i &lt; 5; i++) &#123; for (var j = 0; j &lt;= i; j++) &#123; result += \"*\"; &#125; result += \"\\n\";&#125;console.log(result); 다른사람 풀이 (마지막 sum호출시 \\n 때문에 줄바꿈이된다.) 123456789var star = '';var sum = '';for (var i = 1; i &lt;= 5; i++) &#123; star += '*'; sum += star + '\\n'; if (i === 3) console.log(sum);&#125;console.log(sum); 12. 정삼각형 출력하기 for문 1234567891011var result = \"\";for (var i = 0; i &lt; 5; i++) &#123; for (var j = 1; j &lt; 5 - i; j++) &#123; result += \" \"; &#125; for (var k = 0; k &lt; (i * 2) + 1; k++) &#123; result += \"*\"; &#125; result += \"\\n\";&#125;console.log(result); 내장함수 (Math,repeat 활용) 123456789var star = '*';var space = ' ';for (var i = 1; i &lt;= 10; i++) &#123; if (i % 2 === 1) &#123; var temp = 0; temp = Math.floor((10 - i) / 2); console.log(space.repeat(temp) + star.repeat(i)); &#125;&#125; 13. 역정삼각형 출력하기1234567891011var result = \"\";for (var i = 5; i &gt;= 1; i--) &#123; for (var k = 1; k &lt;= 5 - i; k++) &#123; result += \" \"; &#125; for (var j = 1; j &lt;= (2 * i) - 1; j++) &#123; result += \"*\"; &#125; result += \"\\n\";&#125;console.log(result);","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"javascript, algorithm","slug":"javascript-algorithm","permalink":"http://mkfdev.github.io/tags/javascript-algorithm/"}]},{"title":"javascript 연산자와 형변환","slug":"TIL-0926-2","date":"2017-09-26T11:20:16.000Z","updated":"2017-12-17T15:28:23.513Z","comments":true,"path":"2017/09/26/TIL-0926-2/","link":"","permalink":"http://mkfdev.github.io/2017/09/26/TIL-0926-2/","excerpt":"1. 산술연산자(Arithmetic Operators) Operator Description + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 % 나머지 ++ 증가 – 감소","text":"1. 산술연산자(Arithmetic Operators) Operator Description + 덧셈 - 뺄셈 * 곱셈 / 나눗셈 % 나머지 ++ 증가 – 감소 + 연산자 연산 대상이 모두 숫자인 경우 : 덧셈 연산 문자나 문자열이 포함된 경우 : 문자열 연결 연산[참고] 연산 대상을 같은 타입으로 맞춰서 덧셈 연산자를 수행하도록 하는 것이 좋다. ++, – (증감 연산자)1234z = x++; // 5 선대입후증가z = ++x; // 7 선증가후대입z = x--; // 7 선대입후감소z = --x; // 5 선감소후대입 2. 대입연산자(Assignment Operators) Operator Example Same As = x = y x = y += x += y x = x + y -= x -= y x = x - y *= x *= y x = x * y /= x /= y x = x / y %= x %= y x = x % y 3. 비교연산자(Comparison Operators) Operator Description == 동등비교 (loose equality) 형변환 후, 비교한다. === 일치비교 (strict equality) 타입까지 일치하여야 true를 반환한다. != 부등비교 !== 불일치비교 &gt; 관계비교 &lt; 관계비교 &gt;= 관계비교 &lt;= 관계비교 ? 삼항연산자 [참고] ==와 === 연산자 비교var num = 5; x == 5 // truex == ‘5’ // true, 데이터형이 달라도 같게 변환하여 true를 반환한다. x === 5 // truex === ‘5’ // false, 데이터형이 다르면 false를 반환한다. 4. 논리 연산자(Logical Operator) Operator Description ` ` or &amp;&amp; and ! not || (논리 합) 연산자1234var o1 = true || true; // t || t returns truevar o2 = false || true; // f || t returns truevar o3 = true || false; // t || f returns truevar o4 = false || (3 == 4); // f || f returns false &amp;&amp; (논리곱) 연산자123456789var a1 = true &amp;&amp; true; // t &amp;&amp; t returns truevar a2 = true &amp;&amp; false; // t &amp;&amp; f returns falsevar a3 = false &amp;&amp; true; // f &amp;&amp; t returns falsevar a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns false// ! (논리 부정) 연산자var n1 = !true; // falsevar n2 = !false; // truevar n3 = !'Cat'; // false (빈 문자열이 아닐 경우 true로 간주) [참고] 논리 부정 연산자로 값의 유무를 판별할 수 있다12var str='';console.log(!str); // true - str에 값이 없다. 5. 단축 평가(Short-Circuit Evaluations) Boolean값으로 평가하기 위해 참조하여야 할 곳까지 진행한 후, 평가를 중지하게된 계기가 된 값을 반환한다. 평가식 평가결과 true ` ` anyting true false ` ` anything false true &amp;&amp; anything anyting false &amp;&amp; anything false 1var foo = 'Cat' &amp;&amp; 'Dog' // t &amp;&amp; t returns 'Dog' ‘Cat’은 true이므로 ‘Dog’까지 평가해 보아야 한다. 평가를 중지하게된 계기가 된 값 ‘Dog’을 반환한다. 1var foo = 'Cat' || 'Dog' // t || t returns 'Cat' ‘Cat’은 true이므로 평가를 중지하고 ‘Cat’을 반환한다. 평가흐름제어를 위해서는 조건식을 평가하여 논리적 참, 거짓을 구별한 후 평가 결과에 따라 의사결정을 하는 것이 일반적이다.이 때 자바스크립트는 암묵적 강제 형 변환을 통해 조건식을 평가한다. 암묵적 강제 형 변환 (Type coercion)Javascript는 context(문맥)을 고려하여 내부적으로 자료형을 암묵적으로 강제 변환하여 작업을 완료할 수 있다. 1234console.log('1' &gt; 0) // trueconsole.log(1 + '2') // '12'console.log(2 - '1') // 1console.log('10' == 10) //true 직접 형 변환string -&gt; number12345678910111213var val = '123'; //문자열방법1)val =+ val방법2) val = val * 1방법3)Number(value); //객체를 만들때 사용, 사용권장안함방법4)parseInt(value); number -&gt; string12345678910var val = 123; //숫자방법1) val = val + ''; //권장방법2) val = String(val);방법3)val = val.toString(); Truthy &amp; Falsy values Falsy values : Boolean Context에서 false로 평가되는 값들 Truthy Values : Falsy values 이외의 값들이며(object포함) true로 평가된다. Falsy Values false undefined null 0 NaN (Not a Number) &#39;&#39; (빈문자열)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"operator, javascript","slug":"operator-javascript","permalink":"http://mkfdev.github.io/tags/operator-javascript/"}]},{"title":"javascript 자료형과 변수","slug":"TIL-0926","date":"2017-09-26T11:15:16.000Z","updated":"2017-12-17T15:28:26.612Z","comments":true,"path":"2017/09/26/TIL-0926/","link":"","permalink":"http://mkfdev.github.io/2017/09/26/TIL-0926/","excerpt":"Javascript Data type &amp; Variable(자료형과 변수)변수 미선언 변수를 호출하면 ReferenceError 예외가 발생한다. 변수의 중복 선언은 허용되지만 재할당으로 값이 변경된다. var 키워드를 생략하면 전역변수가 된다. [참고] var 키워드로 선언된 변수의 문제점(ES5)전역 변수로 인해서 의도치 않은 변수의 변경이 발생할 가능성이 높다.ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.","text":"Javascript Data type &amp; Variable(자료형과 변수)변수 미선언 변수를 호출하면 ReferenceError 예외가 발생한다. 변수의 중복 선언은 허용되지만 재할당으로 값이 변경된다. var 키워드를 생략하면 전역변수가 된다. [참고] var 키워드로 선언된 변수의 문제점(ES5)전역 변수로 인해서 의도치 않은 변수의 변경이 발생할 가능성이 높다.ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다. 1.Function-level scope 전역 변수의 남발 for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다. 123456var sum = 0;for (var i = 0; i &lt; 10; i++) &#123;sum += i;&#125;console.log('sum:', sum); // sum: 45console.log('i:', i); // i: 10 문제점:var로 선언한 변수는 if나 for같은 block-level이 아닌 function-level에서 범위가 정해지기 때문에 i의 값은 for문이 끝나도 유지된다. 2.var 키워드 생략 허용 의도하지 않은 변수의 전역화 3.중복 선언 허용 의도하지 않은 변수값 변경 4.변수 호이스팅 변수를 선언하기 전에 참조가 가능하다. 변수 호이스팅(Hoisting)이란?변수 Hoisting이란 var 키워드를 사용하여 변수를 선언 시,해당 변수가 속한 범위(scope) 최상단으로 올려버리는 현상을 일컽습니다.그리고 주목할 점은 여기서 속한 범위는 다른 언어처럼 block 레벨이 아니라 function 레벨이라는 점입니다. 1.선언 단계 VO(Variable Object) 변수객체(VO)에 변수를 등록한다. 2.초기화 변수객체(VO)에 등록된 변수를 메모리에 할당된다. 이 단계에서 변수는 undefined로 초기화된다. 3.할당단계 undefined로 초기화된 변수에 실제값을 할당한다. 1234567console.log(foo); // ① undefinedvar foo = 123;console.log(foo); // ② 123 &#123;var foo = 456;&#125;console.log(foo); // ③ 456 ①에서는 변수가 선언되지 않았지만 referenceErorr가 아닌 undefined가 출력된다. ② var 키워드로 선언된 변수는 선언 단계와 초기화 단계가 한번에 이루어진다.즉, 스코프에 변수가 등록되고 변수는 메모리에 공간을 확보한 후 undefined로 초기화된다. 따라서 변수 선언문 이전에 변수에 접근하여도 Variable Object에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이러한 현상을 변수 호이스팅(Variable Hoisting)이라한다. ①이 실행되기 이전에 var foo = 123;이 호이스팅되어 ①구문 앞에 var foo;가 옮겨진다. 블럭 내의 변수 foo는 전역변수이므로 전역에 선언된 변수 foo에 할당된 값을 재할당하기 때문에 ③의 결과는 456이 된다. 변수 선언과 메모리 확보var num; 변수의 선언과 초기화 현재 값은 undefined; num은 메모리의 주소 값을 가리키고 있다.(=참조) num = 10; 변수 값의 할당 num = 1000; 변수 값의 재할당 다른 메모리에 값을 넣어두고, num이 해당하는 메모리의 주소를 참조하도록 한다. 유효범위(scope)유효범위는 변수의 수명1.함수 레벨 스코프(function-level scope) 함수내부 어디에서든지 myScope를 출력할 수 있다. 1234567function functionLevelScope() &#123; if (true) &#123; var myScope = \"function level scope\"; &#125; console.log(myScope);&#125;출력 : function leve scope 2.블록 레벨 스코프(block-level scope)ES6에서 let, const 키워드는 블록 레벨 스코프 변수를 만들어 준다. 12345678function blockLevelScope() &#123; if (true) &#123; let myScope = \"block level scope\"; console.log(myScope); &#125; console.log(myScope);&#125;출력: 에러(myScope는 if문안에서만 유효하다) 기본자료형(Primitive Data Type) 변경 불가능한 값(immutable) pass-by-value [참고] pass-by-value 란?var x = 10; var num = x;num에게 x의 참조 정보를 주지 않고, 10값을 복사해서 새로운 메모리에 저장한 후에 num이 10의 주소값을 참조하도록 한다. 6가지 기본자료형boolean, null, undefined, Number, String, Symbolboolean 논리적인 요소 true(1), false(0) null 의도적으로 기본형 또는 object형 변수에 값이 없다는 것을 명시한다. 123var foo; var foo = null; ** 기존값(undefined)의 참조 정보(address)가 제거된다.** null은 0 또는 false이다. [참고] 자바스크립트 설계상의 오류null은 기본 자료형이지만, typeof는 object이다.따라서 null로 자료형을 비교할 때는 typeof가 아닌 일치 연산자(===)를 사용한다. 123var foo = null;console.log(typeof foo === null); // falseconsole.log(foo === null); // true undefined 선언만 되어 있는 변수의 초기값 선언은 되었지만 할당된 적이 없는 변수에 접근하거나 존재하지 않는 객체 프로퍼티에 접근할 경우, 오류 대신에 undefined가 출력된다.(javascript만) Number 정수, 실수 +/- Infinity 무한대 NaN(not a number) 정수만을 표현하기 위한 특별한 자료형은 없다. String 문자열 홀따옴표 권장(‘’) ex) ‘He is called “John”‘ 변경 불가능(immutable) Symbol Symbol은 ES6에서 새롭게 추가된 7번째 타입이다. Symbol은 애플리케이션 전체에서 유일하며 변경 불가능한(immutable) 기본 자료형(primitive)이다. 객체형(Object type, 참조형) pass by reference 내일모레설명.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"dataType, variable","slug":"dataType-variable","permalink":"http://mkfdev.github.io/tags/dataType-variable/"}]},{"title":"자바스크립트 소개와 기본 규칙","slug":"TIL-0925","date":"2017-09-25T12:09:47.000Z","updated":"2017-12-17T15:28:42.979Z","comments":true,"path":"2017/09/25/TIL-0925/","link":"","permalink":"http://mkfdev.github.io/2017/09/25/TIL-0925/","excerpt":"자바스크립트 소개 javascript는 인터프리터 언어이기 때문에 컴파일이 필요없다. javaScript는 멀티-패러다임 언어로 명령형 (imperative), 함수형 (functional), 프로토타입 기반 (prototype-based) 객체지향형 언어다. 구글의 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경(Runtime Environment)인 Node.js의 등장으로 JavaScript는 웹 브라우저를 벗어나 서버 사이드 어플리케이션 개발에서도 사용되는 Full stack 개발 언어가 되었다. javascript는 크로스 플랫폼을 위한 모바일 웹/앱 개발 분야에서도 가장 중요한 언어로 주목받고 있다. 웹은 물론 모바일 하이브리드 앱(PhoneGap, Sencha Touch, Ionic), 서버 사이드(NodeJS), Desktop(Electron, AppJS), 로봇 제어(Cylon.js, NodeBots) 언어로서 세계에서 가장 인기있는 언어이다.","text":"자바스크립트 소개 javascript는 인터프리터 언어이기 때문에 컴파일이 필요없다. javaScript는 멀티-패러다임 언어로 명령형 (imperative), 함수형 (functional), 프로토타입 기반 (prototype-based) 객체지향형 언어다. 구글의 Chrome V8 JavaScript 엔진으로 빌드된 JavaScript 런타임 환경(Runtime Environment)인 Node.js의 등장으로 JavaScript는 웹 브라우저를 벗어나 서버 사이드 어플리케이션 개발에서도 사용되는 Full stack 개발 언어가 되었다. javascript는 크로스 플랫폼을 위한 모바일 웹/앱 개발 분야에서도 가장 중요한 언어로 주목받고 있다. 웹은 물론 모바일 하이브리드 앱(PhoneGap, Sencha Touch, Ionic), 서버 사이드(NodeJS), Desktop(Electron, AppJS), 로봇 제어(Cylon.js, NodeBots) 언어로서 세계에서 가장 인기있는 언어이다. 프로토타입 기반클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 프로토타입 기반 프로그래밍은 클래스가 없고 객체를 원형으로 하여 복제의 과정을 통해 객체의 동작 방식을 다시 사용할 수 있다.자바스크립트는 클래스와 상속 개념은 없지만 비슷한 프로토타입 개념이 존재 한다. 크로스 플랫폼멀티 플랫폼이라고도 하며, 프로그램들을 하드웨어와 OS 상관없이 둘 이상의 플랫폼에서 실행할 수 있는 것을 말한다.예전에 플랫폼은 특정 컴퓨터 시스템에 특정 프로그램만 실행이 가능했지만, 요즘은 특정 하드웨어나 OS에 상관없이 프로그램을 사용 가능하도록 발전하였다. 이러한 프로그램이나 소프트웨어를 지칭하여 크로스 플랫폼이라고 한다. 자바스크립트 역사 1995년 Javascript는 Brendan Eich가 초기 브라우저인 넷스케이프에 탑재하기 위해서 웹페이지에 포함되는 스크립트 언어로서 개발했다. 인터넷 익스플로러도 JScript라고 이름 붙인 자바스크립트를 지원하기 시작했다. 두 언어가 분화되는 것을 막기 위해 넷스케이프는 자바스크립트 표준화를 Ecma라는 국제 표준 단체로 넘겼다. javaScript는 상표명이기 때문에 상표 분쟁을 막기 위해 Ecma에 등록된 자바스크립트의 이름은 EcmaScript가 되었다. 2015년 6월에 ECMAScript의 6번째 명세인 ECMAScript 2015(이하 ES6)가 발표됐고, let/const keyword, module system, Arrow Function, class 등이 추가되었다. 7번째 명세인 ECMAScript 2016(이하 ES7)이 2016년 6월에 발표되었다. 브라우저 지원 모던 브라우저의 ES6 지원은 97%로 거의 100%에 육박하지만 IE 지원을 고려한다면 babel과 같은 Transpiler를 사용하여야 한다. 자바스크립트 용어와 기본규칙1. 구문(statement) 값, 연산자, 표현식, 키워드, 주석으로 구성되는 한줄의 명령. 세미콜론(;)으로 끝나는 영역. 2. 코드블록(code block) 구문(statement)을 코드블록으로 그룹화할 수 있다. 123function myFunction(x, y) &#123; return x + y; // 구문&#125; 3. 할당연산자(assign, =)Ex) var x = 6; 메모리(x)에 값(6)을 저장한다는 의미. 12var time = 10; // 변수 선언과 할당var greeting; // 변수 선언 4. 흐름제어(Control Flow) 조건문, 반복문 조건이 참이면 해당 구문을 실행하고, 거짓이면 실행하지 않는다.1234567if (time &lt; 10) &#123; greeting = 'Good morning';&#125; else if (time &lt; 20) &#123; greeting = 'Good day';&#125; else &#123; greeting = 'Good evening';&#125; 5. 변수(variable) var 라고 쓴다. 자바스크립트에서는 정해진 변수 타입이 없다. 즉, var로 문자열, 문자, 숫자, 객체 모든 타입을 선언할 수 있다. 값을 할당, 참조하기 위해 사용된다. Typescript는 javascript에서 데이터 타입이 없는 것과 다르게 데이터 타입은 선언할 수 있다. 자바스크립트 기본 규칙 문자열은 홀 따옴표를 사용한다.(‘hello’) 자바스크립트는 아래 7가지 데이터 타입을 제공한다.(기본자료형6개 + 객체) 기본자료형(primitive data type) : Boolean, null, undefined, Number, String, Symbol(ES6에서 추가) 객체형 : Objcet [참고] null과 undefined의 차이null null이라는 값을 가진다. null은 객체 타입(자바스크립트 설계상 오류)으로 문자열일 경우 ‘’, 숫자의 경우 ‘0’과 같다. undefined 변수가 정의되었지만 값이 할당되지 않은 상태 ex) var foo; [참고] javascript 삽입 방식과 위치간단한 스크립트일 경우 또는 해당 문서에만 적용되는 경우 HTML문서안에 스크립트 소스를 배치한다. 그러나 반복 사용되는 코드일 경우 파일별로 저장해두고 필요에 따라 링크해서 사용한다. 자바스크립트 링크태그 삽입 위치&lt;head&gt;에 삽입되는 경우 defer 속성은 HTML 구문 분석이 완전히 완료되면 스크립트 파일을 실행하도록 브라우저에 지시한다. IE8이하는 지원하지 않으므로 두번째 경우를 사용하도록 한다. 12345&lt;head&gt; ...생략... &lt;title&gt;메인 페이지&lt;/title&gt; &lt;script defer src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;/body&gt;앞에 삽입되는 경우 문서의 DOM 로드가 완료된 시점에 javascript 로드가 실행된다. 1234&lt;body&gt; ...생략... &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"Javascript, 인터프리터, 객체지향언어","slug":"Javascript-인터프리터-객체지향언어","permalink":"http://mkfdev.github.io/tags/Javascript-인터프리터-객체지향언어/"}]},{"title":"css3 animation","slug":"TIL-0924","date":"2017-09-24T13:03:01.000Z","updated":"2017-12-17T15:09:06.734Z","comments":true,"path":"2017/09/24/TIL-0924/","link":"","permalink":"http://mkfdev.github.io/2017/09/24/TIL-0924/","excerpt":"CSS3 animation@keyframes 규칙12345678@keyframes animation명&#123; 0% 또는 from&#123; &#125; 100% 또는 to&#123; &#125;&#125;","text":"CSS3 animation@keyframes 규칙12345678@keyframes animation명&#123; 0% 또는 from&#123; &#125; 100% 또는 to&#123; &#125;&#125; keyframes에 설정한 animation 사용하기animaiton: 이름 진행시간 가속도 지연시간 반복횟수 연결방향;animation: txt-ani 4s 2s infinite alterante; animation 속성animation-delay : 애니메이션 로드 후 언제 다시 시작할지 지정한다. animation-direction : 애니메이션이 종료되고 다시 처음부터 시작할지 역방향으로 진행할지 지정.ex) normal,reverse,alternate,alternate-reverse,initial,inherit animation-duration :애니메이션이 진행시간 (1초 = 1s 으로 표시) animation-iteration-count :반복횟수 지정 (infinite : 계속반복) animation-name: 애니메이션이름@keyframes 애니메이션이름{}으로 쓰임 animation-play-state: 애니메이션 시작 또는 정지 상태기본적으로 사용되는 것들 : running , paused animation-timing-function: 애니메이션 속도(가속/감속 시간간격등 설정)기본적으로 사용되는 것들 : linear,ease,ease-in,ease-out,ease-in-out,step-start,step-end,steps(int,start|end),cubic-bezier(n,n,n,n),initial,inherit animation-fill-mode: 시작되기 전이나 끝나고 난 후 어떤 값이 적용될지 지정합니다.애니메이션이 끝난후 처음상태로? 끝난 상태로?기본적으로 사용되는 것들 : none,forwards,backwards,both,initial,inherit 몇가지 속성은 선택자의 display 속성이 block이어야만 작동한다.inline일 경우에는 block을 적용한 후, 속성을 작성해야 한다. translate()","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"css3, animation","slug":"css3-animation","permalink":"http://mkfdev.github.io/tags/css3-animation/"}]},{"title":"반응형웹과 css3","slug":"TIL-0921","date":"2017-09-21T14:52:41.000Z","updated":"2017-12-17T15:02:35.175Z","comments":true,"path":"2017/09/21/TIL-0921/","link":"","permalink":"http://mkfdev.github.io/2017/09/21/TIL-0921/","excerpt":"viewport breakpoint는 통계자료를 확인해서 분기한다. 반응형웹(RWD)모바일~ 태블릿 ~데스크탑 적응형웹(AWD)모바일 / 데스크탑참조 : naradesign","text":"viewport breakpoint는 통계자료를 확인해서 분기한다. 반응형웹(RWD)모바일~ 태블릿 ~데스크탑 적응형웹(AWD)모바일 / 데스크탑참조 : naradesign background-size 속성 (*익스9이상 지원)background-size:auto 이미지가 원래 사이즈로 배치된다. 이미지가 크면 이미지 일부만 보일 수도 있다.background-size:cover 이미지 비율을 맞춘 상태로 너비 높이 중에 큰 값에 맞추는 속성이다. 이미지의 일부가 보이지 않을 수도 있다.background-size:contain 원하는 영역에 전체 이미지가 들어가도록 비율에 맞게 배치된다. 이미지가 잘리지 않는다. 원하는 영역에 꽉 차진 않지만 비율에 맞게 배치된다. 장식용 이미지 마크업에 이미지 넣어서(IR기법) 빈 태그로 활용한 경우 alt=”” 빈 속성으로 처리한다.1&lt;img src=&quot;이미지경로&quot; alt=&quot;&quot;&gt; 복잡한 포털성 컨텐츠 -&gt; 반응형 적용이 어렵다. 반응형 이미지 처리-부모 요소 크기에 맞게 늘어나도록 한다. (비율 유지)flexible img {max-width:100%; height:auto} srcset, sizes 반응형웹 이미지 속성 여러 스크린별 사이즈를 제어하기 위해서 사용하는 속성이다. 뷰포트에 따라서 보이는 이미지를 다르게 적용한다. 모바일용으로만 만들때 사용한다. IE 11 버전부터 지원 사용방식img src=”bird-wide.jpg” srcset=”bird-wide.jpg 640w, bird-narrow 320w” sizes=”(min-width:640px) 50vw, 100vw” alt=”날고있는새” sizes 속성 : 뷰포트가 640px이상일 경우, 뷰포트 사이즈의 50%만 지정합니다. picture element - 익스11지원안함(picturefill로 대응가능)-반응형웹만들때 사용123456&lt;picture&gt;&lt;source media=&quot;&quot; srcset=&quot;&quot;&gt;&lt;img&gt;- picture , source 인식하지못할때 대비(속성은 위참고)&lt;/picture&gt;http://www.usefulparadigm.com/2014/11/03/processing-images-on-responsive-web/ 참고해서 다시 정리 display:flex 버그 크롬에서 Form요소에 flex 속성이 안먹힌다. 파이어폭스에서 fieldset 하위 요소가 block level 일때 flex가 안먹힌다. 123456789101112131415/* 크롬 버그 *//* fieldset 하위 요소가 inline level이므로, 파이어폭스에서는 잘 된다. */&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;검색 폼&lt;/legend&gt; &lt;label for=&quot;keyward&quot;&gt;자료검색&lt;/label&gt; &lt;input type=&quot;search&quot; id=&quot;keyward&quot; required placeholder=&quot;검색어를 입력하세요.&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn-search&quot;&gt;검색&lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt;fieldset &#123; display: flex; justify-content: flex-end;&#125; 해결법-&gt; 버그 상태에서 flex를 사용하고 싶을때는 div로 묶어주고 해당영역에 flex 속성을 적용한다. 123456789101112131415&lt;form&gt; &lt;fieldset&gt; &lt;div class=&quot;flex-container&quot;&gt; /*div로 감싼다*/ &lt;legend&gt;검색 폼&lt;/legend&gt; &lt;label for=&quot;keyward&quot;&gt;자료검색&lt;/label&gt; &lt;input type=&quot;search&quot; id=&quot;keyward&quot; required placeholder=&quot;검색어를 입력하세요.&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn-search&quot;&gt;검색&lt;/button&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt;.flex-container &#123; display: flex; justify-content: flex-end;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"반응형웹, 미디어쿼리, css3","slug":"반응형웹-미디어쿼리-css3","permalink":"http://mkfdev.github.io/tags/반응형웹-미디어쿼리-css3/"}]},{"title":"웹접근성 기술 WAI-ARIA","slug":"TIL-0919","date":"2017-09-19T14:48:11.000Z","updated":"2017-12-17T14:51:32.938Z","comments":true,"path":"2017/09/19/TIL-0919/","link":"","permalink":"http://mkfdev.github.io/2017/09/19/TIL-0919/","excerpt":"WAI-ARIA의 목적마크업에 역할, 속성, 상태 정보를 추가하여 스크린기기 및 보조 기기에서 접근성 및 상호 운용성을 향상시키고 보다 나은 사용자 경험을 제공하기 위함이다.","text":"WAI-ARIA의 목적마크업에 역할, 속성, 상태 정보를 추가하여 스크린기기 및 보조 기기에서 접근성 및 상호 운용성을 향상시키고 보다 나은 사용자 경험을 제공하기 위함이다. ARIA의 기능 - 역할(Role) 특정 요소(Element)에 역할을 정의하는것 역할(Role) 작성 규칙HTML5 섹션 관련 요소와 ARIA RoleHTML5섹션을 div로 마크업할 때, div 요소에 역할(role)을 정의해준다. Landmark Role HTML5 섹션 관련 요소 div role=”banner” header div role=”navigation” nav div role=”main” main div role=”complementary” aside role=”form” form role=”contentinfo” footer div role=”alertdialog” 대화상자, 팝업 role=”button” 버튼 ARIA의 기능 - 속성(Properties), 상태(States) 요소(Element)가 기본적으로 갖고 있는 특징이나 상황 ‘aria - *’ 접두어를 가진다. 속성(Properties) 작성 규칙 속성(Properties) 의미 input aria-required=”true” 필수 항목 속성 input aria-label=”그룹제목” 그룹 제목 속성(그룹에 대한 제목정의) input aria-labeledby=”참조그룹ID” label for과 비슷한 역할의 속성 input aria-describedby=”reference” 추가 설명 속성(경고텍스트) aria-hidden=”true” 읽지않음 상태(State) 작성 규칙 상태(State) 의미 aria-expanded=”true” 확장되어 있는 상태의 탭패널 aria-invalid=”true” 오류가 발생한 상태의 입력상자 ARIA 사용시 주의할점 ARIA Role과 HTML5를 중복해서 사용하지 않는다. HTML Element의 기능 변경이 제한된다.ex) h1 role=”button” - 원래의 의도를 바꿔쓴 잘못된 예 키보드 접근이 보장되어야 한다.ex) div role=”button” tabindex=”0” div 태그로만 구성된 코드를 개선하기 위해 사용한다. 웹접근성 미준수 개선방법1.로그인 화면에서 경고텍스트를 읽지 않는 경우123&lt;label for=&quot;user-id&quot;&gt;아이디&lt;/label&gt;&lt;input id=&quot;user-id&quot; aria-describedby=&quot;msg&quot;&gt;&lt;span id=&quot;msg&quot;&gt;이미 존재하는 아이디 입니다.&lt;/span&gt; 2. CSS IR기법을 이용한 태그 또는 빈 태그일 경우1&lt;a href=&quot;#&quot;&gt;&lt;span role=&quot;img&quot; aria-label=&quot;대체텍스트-Connect via Facebook&quot;&gt;&lt;/span&gt;&lt;/a&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"WAI-ARIA, 웹접근성","slug":"WAI-ARIA-웹접근성","permalink":"http://mkfdev.github.io/tags/WAI-ARIA-웹접근성/"}]},{"title":"GIT 기초 정리","slug":"TIL-0917","date":"2017-09-17T09:19:46.000Z","updated":"2017-12-17T15:28:58.392Z","comments":true,"path":"2017/09/17/TIL-0917/","link":"","permalink":"http://mkfdev.github.io/2017/09/17/TIL-0917/","excerpt":"로컬PC 작업 파일을 원격 저장소로 올리려면1)add 2)commit 3)push 명령을 사용해야 한다.","text":"로컬PC 작업 파일을 원격 저장소로 올리려면1)add 2)commit 3)push 명령을 사용해야 한다. 1) 작업공간(local directory)에서 add 명령어를 통해 stage에 반영한다.2) commit 명령어를 통해 저장소에 반영한다.stage에 올렸던 데이터를 확정하는 단계이다.여기까지는 중간 단계로 원격 저장소에 파일이 반영되지 않고,내 PC에 있는 Git 로컬 저장소에만 존재한다.3) push 명령어를 통해 원격 저장소에 반영한다.git clone을 통해 원격 저장소의 파일을 읽어와서 작업했을 때,$git push origin “push할 브랜치 이름”ex) $git push origin master원격 저장소를 정의해야 할 때,$git remote add “원격저장소명 원격저장소주소”ex) $git remote add origin http://github.com/… Repository 생성방법(1)123$mkdir 디렉토리명$git init$git remote add origin 원격저장소주소 Repository 생성방법(2)12345github.com 웹에서 repository 생성$git add 파일명$git commit -m &quot;메세지&quot;$git remote add origin 원격저장소주소$git push origin master 갱신$git pull 원격 저장소의 변경내용이 로컬 작업 디렉토리에 받아지고(fetch) 병합(merge)된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://mkfdev.github.io/categories/TIL/"}],"tags":[{"name":"git","slug":"git","permalink":"http://mkfdev.github.io/tags/git/"}]}]}